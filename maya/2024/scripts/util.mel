//=== 2004 felix balbas
//=== bunch of utility scripts for the fc_rig_builder
//=== list of utilities:
//
// source fcdbDisableWarnings
// source fcConstraint
// resetVar
// getGlobVar

// u_fcdb_element_path
// ctl
// stretch_ctl
// updateGeo
// stretchy_chain
// printNode
// get_creature_root
// fxArrayToString
// average_aim
// zeroT
// copyT, copyR, copyS and copyTrans
// getRigPose
// getPose
// zeroJointOrient
// hide_locs
// show_locs
// hide_joints
// aim_locs
// get_distance
// pullCage
// zeroJointOrient
// placePoleVectorObject
// build_joints
// build_new_joints
// build_joints_msl
// build_3_chain_joints
// strip_suffix
// strip_prefix
// get_prefix
// fcSearchReplace
// joints_on_path_upv2
// joints_on_path_upv
// averagePointConstraint
// averageOrient
// averageScale
// averageCopyOrient
// splitNames
// makeCurveDyn
// aim_locus
// memberCage
// get_dist
// find_closest
// chain_multi_ik
// joints_on_path
// chain_multi_ik
// updown_chain
// closestValueOnCurve
// change_suffix
// rename_control
// sceneRigPref
// sceneRigName
// joints_on_path_upv_fin
// hdMakeCurvesDynamicHairs
// simmetry
// sceneRigPref
// sceneRigName
// mpa
// mpa_vel
// loadWeightMap
// saveWeightMap
// getClosestPoint
// die_LL_die
// store_pose
// store_simple_pose
// pose
// cleanAttr
// fsGetSel
// store_sel
// removeMultipleLightLinkers
// rename_chain
// ikSplineChain
// bridge
// clean_scene
// splineIk
// switchNodeState
// autoPullCage
// cleanRig
// dynCurve
// mergeHS
// bindPose
// doPose
// parent_loc
// cleanit
// blend_shapes
// getPlugIndex
// get_ctl
// switch_skin
// mirror_nodes
// reset_muscles
// copy_msl_locs
// base_muscle
// base_muscle2
// fcDrainShape
// copy_ctls
// setPose
// saveFcWrinkle
// wrinkle_ctl
// getAllConDef
// fxImportSkinWeightMap
// changeShape
// uvXfer
// fxFlesh
// posit
// fxGetClosestPoint
// fx_control
// cluster_curve
// blend_con
// find_spine_crv
// avSkinWeight
// cpSkinWeight
// fcEnv2bind
// fxEnvAddFcEnvNode
// makeCurveDynForMuscle
// joints_on_curve_for_msl
// eMuscle
// invConnect
// negConnect
// cleanWeights
// averagePointConstraintMO
// fkChainHandle
// showmeAll
// lock_trans
// lock_trans_min
// lock_trans_max
// lock_rot
// lock_scale
// swap_parent_cons
// findRelatedSkinCluster
// print_parent
// chain_on_curve
// colour_ctls
// repeats
// cleanShapes
// auto_ctl
// cleanNames
// switchDeformingMesh
// switchDeformers
// jointPerVertex
// fxSkinSmooth
// averageParentConstraint
// skinValue
// distance_DST
// reverseAim
// mySculpt
// printCon
// fxGetPose
// exportPose
// saveAll
// frameAnim
// renameJoints
// skinMuscle
// cleanSelection
// autoVolumeCages
// cageSkinWeights
// saveCages
// loadCages
// returnChildren
// buildCurve
// lockTrans
// poseNormals
// wireCleanSet
// sculptCleanSet
// mirror_sculpts
// fxRenameSuff
// paramVOC
// uv2param
// select_asfJoints
// reverseString
// lockTrans
// fxGetConstraintPose
// swap_suffix
// fxDeleteEmptyLayers
// fxPrefixHierarchy
// import
// dnJointShape
// build_fk_joints
// dnDoConstraint
// fuckThePass
// adjustIkChainLength
// dnSwapEnvs
// updateConstraints
// averageSkinWeights
// fxSmooth
// toParametric
// make_sec
// connect_sec
// myMotionPath
// cluster_circle
// locs_on_path
// returnClosestValueOnCurve
// sumTwoAttr
// subTwoAttr

source "generateChannelMenu.mel" ;
source channelBoxCommand;
evalDeferred("autoLoadPlugin(\"\", \"dnPoseDeformer\", \"dnPoseDeformer\")");

/*
	if (! `artAttrSkinPaintCtx -exists artAttrSkinContext`) 
    {
    // create the context if it does not yet exist so we can
    // query its settings
    //
    string $currCtx = `currentCtx`;
    artAttrSkinToolScript 4;
    setToolTo $currCtx;
	}
*/


//============================================
//============================================
//============================================
//============================================

global proc string[] ctl(string $name, int $rot, int $upv, float $scale)
{

string $list[] = `ls -sl`;
string $nodes[];

    if(`size($list)`>1)
    {
    print "select one object MAX";
    }
    else
    {
        curve -name ($name+"_ctrl") -d 1 -p 0.5 0.5 0.5 -p 0.5 -0.5 0.5 -p
-0.5 -0.5 0.5 -p -0.5 0.5 0.5 -p 0.5 0.5 0.5 -p 0.5 0.5 -0.5 -p -0.5 0.5
-0.5 -p -0.5 0.5 0.5 -p 0.5 0.5 0.5 -p 0.5 -0.5 0.5 -p 0.5 -0.5 -0.5 -p
0.5 0.5 -0.5 -p 0.5 0.5 0.5 -p -0.5 0.5 0.5 -p -0.5 -0.5 0.5 -p -0.5
-0.5 -0.5 -p -0.5 0.5 -0.5 -p -0.5 -0.5 -0.5 -p 0.5 -0.5 -0.5 -k 0 -k 1
-k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k
15 -k 16 -k 17 -k 18 ;
        
        string $shape[] = `listRelatives -s ($name+"_ctrl")`;
        rename $shape[0] ($name+"_ctrlShape");
        spaceLocator -name ($name+"_ctrl_LOC");
        parent ($name+"_ctrl") ($name+"_ctrl_LOC");
        setAttr ($name+"_ctrl_LOCShape.v") 0;

        $nodes[size($nodes)] = ($name+"_ctrl");
        $nodes[size($nodes)] = ($name+"_ctrl_LOC");
        
        if($upv>0)
        {
        select -cl;
        spaceLocator -name ($name+"_ctrl_UPV");
        parent ($name+"_ctrl_UPV") ($name+"_ctrl");
        setAttr .t 0 1 0;
        setAttr ($name+"_ctrl_UPVShape.v") 0;
        $nodes[size($nodes)] = ($name+"_ctrl_UPV");
        }
        
        
        if($rot>0)
        {
        curve -name ($name+"_rot_ctrl") -d 1 -p 0 0 0 -p 0 1 0 -p 0 0 2 -p 0 0 0 -k 0 -k 1 -k 2 -k 3 ;
        string $shape[] = `listRelatives -s ($name+"_rot_ctrl")`;
        rename $shape[0] ($name+"_rot_ctrlShape");
        spaceLocator -name ($name+"_rot_ctrl_LOC");
        parent ($name+"_rot_ctrl") ($name+"_rot_ctrl_LOC");
        parent ($name+"_rot_ctrl_LOC") ($name+"_ctrl");
        setAttr ($name+"_rot_ctrl_LOCShape.v") 0;

//==========================================================================================                
//=== rot sec
//==========================================================================================                

        addAttr -ln "sec"  -at bool ($name+"_rot_ctrl");
        setAttr ($name+"_rot_ctrl.sec") 1;
        connectAttr -f ($name+"_rot_ctrl.sec") ($name+"_rot_ctrlShape.v");

        $nodes[size($nodes)] = ($name+"_rot_ctrl");
        $nodes[size($nodes)] = ($name+"_rot_ctrl_LOC");

            if($upv>0)
            {
            select -cl;
            spaceLocator -name ($name+"_rot_ctrl_UPV");
            parent ($name+"_rot_ctrl_UPV") ($name+"_rot_ctrl");
            setAttr .t 0 1 0;
            setAttr ($name+"_rot_ctrl_UPVShape.v") 0;
            $nodes[size($nodes)] = ($name+"_rot_ctrl_UPV");
            }
        }
        
        if(`size($list)`==1)
        {
        select  $list[0] ($name+"_ctrl_LOC"); delete `parentConstraint`;
        }
        
    setAttr ($name+"_ctrl.s") $scale $scale $scale;
    makeIdentity -a 1 -s 1 ($name+"_ctrl");
    }

select -cl;
if(size($list))
select $list;

return $nodes;
}


//============================================
//============================================
//============================================
//============================================

global proc string[] stretch_ctl(string $name, string $ctl, string
$startNode, string $endNode)
{

string $stretchName = ($name + "_stretch");
string $squashName = ($name + "_squash");
string $limbName = $name;

string $obj[] = `ls -sl`;
float $sp[] = `xform -query -worldSpace -translation $startNode`;
float $ep[] = `xform -query -worldSpace -translation $endNode`;
string $curve = ($stretchName + "_CRV");
string $stretchAttr = ($ctl + ".stretch");
string $nodes[];

addAttr -k 1 -ln "stretch" -at double  -min 0 -max 1 -dv 0 $ctl;
addAttr -ln "scale_limb" -at double -dv 1 $ctl;

curve -name $curve -d 1 -p $sp[0] $sp[1] $sp[2] -p $ep[0] $ep[1]
$ep[2];

float $cvs[] = `getAttr ($curve + ".cv[*]")`;
$num = `getAttr ($curve + ".spans")`;
$arcLengthNodes = `arcLengthDimension ($curve + ".u[" + $num + "]")`;
float $arcLength = `getAttr ($arcLengthNodes + ".arcLength")`;

shadingNode -asUtility multiplyDivide -name ($stretchName + "_MUL");
setAttr ($stretchName + "_MUL.operation") 2;
connectAttr -f ($arcLengthNodes + ".arcLength") ($stretchName +  "_MUL.input1X");
setAttr ($stretchName + "_MUL.input2X") $arcLength;

shadingNode -asUtility plusMinusAverage -name ($stretchName + "_ADD");
connectAttr -f ($stretchName + "_MUL.outputX") ($stretchName +  "_ADD.input1D[0]");
setAttr ($stretchName + "_ADD.input1D[1]") 1;
setAttr ($stretchName + "_ADD.operation") 2;

shadingNode -asUtility multiplyDivide -name ($stretchName + "_2_MUL");
connectAttr $stretchAttr ($stretchName + "_2_MUL.input1X");
connectAttr ($stretchName + "_ADD.output1D") ($stretchName +  "_2_MUL.input2X");

shadingNode -asUtility plusMinusAverage -name ($stretchName +  "_2_ADD");
setAttr ($stretchName + "_2_ADD.input1D[0]") 1;
connectAttr ($stretchName + "_2_MUL.outputX") ($stretchName +  "_2_ADD.input1D[1]");


shadingNode -asUtility multiplyDivide -name ($stretchName +  "_scale_MUL");
connectAttr -f ($ctl + ".scale_limb") ($stretchName +  "_scale_MUL.input1X");
connectAttr -f ($stretchName + "_2_ADD.output1D") ($stretchName +  "_scale_MUL.input2X");

/*
for($i = 0;$i<size($obj);$i++)
{
connectAttr ($stretchName + "_2_ADD.output1D") ($obj[$i] + ".sx");
connectAttr ($stretchName + "_2_ADD.output1D") ($obj[$i] + ".sy");
connectAttr ($stretchName + "_2_ADD.output1D") ($obj[$i] + ".sz");
}
*/
for($i = 0;$i<size($obj);$i++)
{
connectAttr ($stretchName + "_scale_MUL.outputX") ($obj[$i] + ".sx");
connectAttr ($stretchName + "_scale_MUL.outputX") ($obj[$i] + ".sy");
connectAttr ($stretchName + "_scale_MUL.outputX") ($obj[$i] + ".sz");
}


select ($curve + ".cv[0]");
string $clus[] = `newCluster " -envelope 1"`;
rename $clus[0] ($stretchName + "_start_CLS");
rename $clus[1] ($stretchName + "_start_CLH");
select $startNode ($stretchName + "_start_CLH");
pointConstraint -name ($stretchName + "_start_POC");

$nodes = {$curve, ($stretchName + "_start_CLH")};

select ($curve + ".cv[1]");
string $clus[] = `newCluster " -envelope 1"`;
rename $clus[0] ($stretchName + "_end_CLS");
rename $clus[1] ($stretchName + "_end_CLH");
select $endNode ($stretchName + "_end_CLH");
pointConstraint -name ($stretchName + "_end_POC");

$nodes[size($nodes)] = ($stretchName + "_end_CLH");

///=============================
//=== squash

//if(`objExists ($name + "*ENV")`)
//{
string $pulls[] = `ls ($limbName + "*ENV")`;
string $children[];
string $conn[];


addAttr -k 1 -ln "squash" -at double  -min 0 -max 1 -dv 0 $ctl;
shadingNode -asUtility plusMinusAverage -name ($squashName + "_ADD");
shadingNode -asUtility plusMinusAverage -name ($squashName + "_2_ADD");
setAttr ($squashName + "_2_ADD.operation") 2;
setAttr ($squashName + "_2_ADD.input1D[0]") 1;
setAttr ($squashName + "_ADD.input1D[0]") 1;
shadingNode -asUtility multiplyDivide -name ($squashName + "_MUL");

connectAttr ($obj[0] + ".sz") ($squashName + "_2_ADD.input1D[1]");
connectAttr ($ctl + ".squash") ($squashName + "_MUL.input1X");
connectAttr ($squashName + "_2_ADD.output1D") ($squashName +  "_MUL.input2X");
connectAttr ($squashName + "_MUL.outputX") ($squashName +  "_ADD.input1D[1]");
    for($i = 0;$i<size($pulls);$i++)
    {
    $conn = `listConnections ($pulls[$i] + ".sx")`;
    $children = `listRelatives -c -type transform $pulls[$i]`;
   
        if(size($conn) > 0)
        {
        spaceLocator -name ($pulls[$i] + "_xtra_LOC");
        select $pulls[$i] ($pulls[$i] + "_xtra_LOC");
        delete `pointConstraint`; delete `orientConstraint`; delete
`scaleConstraint`;
        parent ($pulls[$i] + "_xtra_LOC") $pulls[$i];
        print "\nchildren are: ";
        print $children;
        parent $children ($pulls[$i] + "_xtra_LOC");
        connectAttr ($squashName + "_ADD.output1D") ($pulls[$i] + "_xtra_LOC.sx");
        //connectAttr ($squashName + "_ADD.output1D") ($pulls[$i] + "_xtra_LOC.sy");
        connectAttr ($squashName + "_ADD.output1D") ($pulls[$i] + "_xtra_LOC.sz");
        }
        else
        {
        connectAttr ($squashName + "_ADD.output1D") ($pulls[$i] + ".sx");
        //connectAttr ($squashName + "_ADD.output1D") ($pulls[$i] + ".sy");
        connectAttr ($squashName + "_ADD.output1D") ($pulls[$i] + ".sz");
        }
    }
//}


return $nodes;

}


///=============================
///=============================
///=============================

global proc updateGeo(string $geo)
{
dgdirty -a;
xform -q -ws -bb $geo;
dgdirty -a;
}

///=============================
///=============================
///=============================


global proc string printNode()
{

string $nodes[] = `ls -sl`;
string $print;

    if(size($nodes) == 0)
    {
    print "select something, you idiot";
    }
    else
    {
   
        for($i = 0; $i < size($nodes); $i++)
        {
        string $parent[] = `listRelatives -p $nodes[$i]`;
        float $t[] = `getAttr ($nodes[$i] + ".t")`;
        float $r[] = `getAttr ($nodes[$i] + ".r")`;
        float $s[] = `getAttr ($nodes[$i] + ".s")`;
       
        print ("spaceLocator -name " + $nodes[$i] + ";\n");
        print ("parent " + $nodes[$i] + " " + $parent[0] + ";\n");
        print (" catchQuiet(`setAttr " + $nodes[$i] + ".t " + $t[0] + " " + $t[1] +  " " + $t[2] + "`);\n");
        print (" catchQuiet(`setAttr " + $nodes[$i] + ".r " + $r[0] + " " + $r[1] +  " " + $r[2] + "`);\n");
        print (" catchQuiet(`setAttr " + $nodes[$i] + ".s " + $s[0] + " " + $s[1] +  " " + $s[2] + "`);\n");
       
        $print +=  ("spaceLocator -name " + $nodes[$i] + ";\n");
        $print +=  ("parent " + $nodes[$i] + " " + $parent[0] + ";\n");
        $print +=  (" catchQuiet(`setAttr " + $nodes[$i] + ".t " + $t[0] + " " +  $t[1] + " " + $t[2] + "`);\n");
        $print +=  (" catchQuiet(`setAttr " + $nodes[$i] + ".r " + $r[0] + " " +  $r[1] + " " + $r[2] + "`);\n");
        $print +=  (" catchQuiet(`setAttr " + $nodes[$i] + ".s " + $s[0] + " " +  $s[1] + " " + $s[2] + "`);\n");
       
        }

    }

return $print;

}
   
//=== end prinNode

global proc string get_creature_root()
{

string $sel[] = `ls -sl`;
string $hierarchy[] = `listRelatives -f -ap $sel[0]`;
string $parents[];
string $root;

$numTokens = `tokenize $hierarchy[0] "|" $parents`;

if(`size($hierarchy)` == 0)
{
    if(`gmatch $sel[0] "*ROOT*"` == 1)
    {
    $root = $sel[0];
    }
}

for($i = 0; $i<size($parents);$i++)
{
    if(`gmatch $parents[$i] "*ROOT*"`)
    {
    $root = $parents[$i];
    }
}



return $root;
}

//=== end get_creature_root

global proc string fxArrayToString(int $array[])
{

    string $s = "";
    int $f;
    for($f in $array)
        $s += $f + " ";
   
    return $s;

}


global proc averageAim(int $axes)
{

string $list[] = `ls -sl`;
int $aim[];
int $upv[];

if($axes == 1)
{
$aim = {-1,0,0};
$upv = {0,1,0};
}

if($axes == 2)
{
$aim = {0,-1,0};
$upv = {1,0,0};
}

if($axes == 3)
{
$aim = {0,0,-1};
$upv = {0,1,0};
}


    for( $i = 0; $i < size($list); $i++ )
    {
   
        if($i < (size($list)-2))
        {
        select $list[$i] $list[$i+1];
        aimConstraint -name ($list[$i+1] + "_AIC") -offset 0 0 0 -weight 1
-aimVector $aim[0] $aim[1] $aim[2] -upVector $upv[0] $upv[1] $upv[2]
-worldUpType "objectrotation" -worldUpVector $upv[0] $upv[1] $upv[2]
-worldUpObject $list[$i];
        }
        else
        {
        print "\the end\n";
        }
       
    }

select -cl;

}

//=== end average_aim


global proc resetVar()
{

textField -e -tx 0 normal_spines ;
textField -e -tx 0 reptile_spines ;
textField -e -tx 0 long_necks ;
textField -e -tx 0 short_necks ;
textField -e -tx 0 heads ;
textField -e -tx 0 human_arms ;
textField -e -tx 0 human_legs ;
textField -e -tx 0 quadr_legs ;
textField -e -tx 0 human_feet ;
textField -e -tx 0 one_fing_hands ;
textField -e -tx 0 two_fing_hands ;
textField -e -tx 0 three_fing_hands ;
textField -e -tx 0 four_fing_hands ;
textField -e -tx 0 five_fing_hands ;
textField -e -tx 0 bird_wings ;
textField -e -tx 0 bat_wings ;
textField -e -tx 0 tentacles ;
textField -e -tx 0 tails ;
textField -e -tx 0 fins ;
textField -e -tx 0 flippers ;

}

global proc resetRes()
{
checkBox -e -v 0 doStretch;
checkBox -e -v 0 doToes ;
checkBox -e -v 0 hiresSpine ;
checkBox -e -v 0 hiresReptSpine ;
checkBox -e -v 0 hiresHead ;
checkBox -e -v 0 hiresQuadrLeg ;
checkBox -e -v 0 hiresShortNeck ;
checkBox -e -v 0 hiresLongNeck ;
checkBox -e -v 0 hiresArm ;
checkBox -e -v 0 hiresTentacle ;
checkBox -e -v 0 hiresLeg ;
checkBox -e -v 0 hiresFlipper ;
checkBox -e -v 0 hiresFin ;
checkBox -e -v 0 hires1FingHand ;
checkBox -e -v 0 hiresBirdWing ;
checkBox -e -v 0 hires2FingHand ;
checkBox -e -v 0 hiresBatWing ;
checkBox -e -v 0 hires3FingHand ;
checkBox -e -v 0 hiresTail ;
checkBox -e -v 0 hires4FingHand ;
checkBox -e -v 0 hires5FingHand ;
}

//===== creature global proc

global proc getGlobVar()
{

//==== global variables

global string $FsRigName;
global string $FsRigPrefix;

//=== names

global string $rig_pref;
global string $rig_name;
global string $rig_prefix;
global string $prefixL;
global string $prefixR;
global string $rig_dir;
global string $rig_dir;
//=== modules

global int $rig_type;
global int $quad_rig_type;
global int $bird_rig_type;
global int $rept_rig_type;
global int $hires;
global int $normal_spines;
global int $long_spines;
global int $long_necks;
global int $short_necks;
global int $heads;
global int $human_arms;
global int $human_legs;
global int $quadr_legs;
global int $human_feet;
global int $one_finger_hands;
global int $two_finger_hands;
global int $three_finger_hands;
global int $four_finger_hands;
global int $five_finger_hands;
global int $bird_wings;
global int $bat_wings;
global int $tentacles;
global int $tails;
global int $fins;
global int $flippers;
global int $doStretch;
global int $doToes;
global int $hiresSpine;
global int $hiresReptSpine;
global int $hiresHead;
global int $hiresQuadrLeg;
global int $hiresShortNeck;
global int $hiresLongNeck;
global int $hiresArm;
global int $hiresTentacle;
global int $hiresLeg;
global int $hiresFlipper;
global int $hiresFin;
global int $hires1FingHand;
global int $hiresBirdWing;
global int $hires2FingHand;
global int $hiresBatWing;
global int $hires3FingHand;
global int $hiresTail;
global int $hires4FingHand;
global int $hires5FingHand;

//=== scripts and models

global string $model;
global int $doPost ;
global int $doEnv ;
global int $doToes ;
global string $postScript;
global string $geo;


//==== end global variables

    if ( `window -exists fs_rig_builder` )
    {

        $rig_type = `optionMenuGrp -q -sl GEC`;
        $rig_pref = `textField -q -tx RIG_PREFIX`;
        $rig_name = `textField -q -tx RIG_NAME`;
        $rig_prefix = ($rig_pref + "_");
        $prefixL = ($rig_prefix + "L_");
        $prefixR = ($rig_prefix + "R_");
        $rig_dir = `textFieldButtonGrp -q -tx ENV`;
        $hires = (`optionMenuGrp -q -sl RES` - 1);
        $quad_rig_type = `optionMenuGrp -q -sl QT`;
        $bird_rig_type = `optionMenuGrp -q -sl BT`;
        $rept_rig_type = `optionMenuGrp -q -sl RT`;
        $normal_spines = `intField -q -v normal_spines`;
        $long_spines = `intField -q -v reptile_spines`;
        $long_necks = `intField -q -v long_necks`;
        $short_necks = `intField -q -v short_necks`;
        $heads = `intField -q -v heads`;
        $human_arms = `intField -q -v human_arms`;
        $human_legs = `intField -q -v human_legs`;
        $quadr_legs = `intField -q -v quadr_legs`;
        $human_feet = `intField -q -v human_feet`;
        $one_finger_hands = `intField -q -v one_fing_hands`;
        $two_finger_hands = `intField -q -v two_fing_hands`;
        $three_finger_hands = `intField -q -v three_fing_hands`;
        $four_finger_hands = `intField -q -v four_fing_hands`;
        $five_finger_hands = `intField -q -v five_fing_hands`;
        $bird_wings = `intField -q -v bird_wings`;
        $bat_wings = `intField -q -v bat_wings`;
        $tentacles = `intField -q -v tentacles`;
        $tails = `intField -q -v tails`;
        $fins = `intField -q -v fins`;
        $flippers = `intField -q -v flippers`;
        $doPost = `checkBox -q -v doPost`;
        $doToes = `checkBox -q -v doToes`;
        $doEnv = `checkBox -q -v doEnv`;
        $doStretch = `checkBox -q -v doStretch`;
        $postScript = `textFieldButtonGrp -q -tx MEL`;
        $geo = `textFieldButtonGrp -q -tx fcdbGEO`;
        $doToes = `checkBox -q -v doToes`;
        $hiresSpine = `checkBox -q -v hiresSpine`;
        $hiresReptSpine = `checkBox -q -v hiresReptSpine`;
        $hiresHead = `checkBox -q -v hiresHead`;
        $hiresQuadrLeg = `checkBox -q -v hiresQuadrLeg`;
        $hiresShortNeck = `checkBox -q -v hiresShortNeck`;
        $hiresLongNeck = `checkBox -q -v hiresLongNeck`;
        $hiresArm = `checkBox -q -v hiresArm`;
        $hiresTentacle = `checkBox -q -v hiresTentacle`;
        $hiresLeg = `checkBox -q -v hiresLeg`;
        $hiresFlipper = `checkBox -q -v hiresFlipper`;
        $hiresFin = `checkBox -q -v hiresFin`;
        $hires1FingHand = `checkBox -q -v hires1FingHand`;
        $hiresBirdWing = `checkBox -q -v hiresBirdWing`;
        $hires2FingHand = `checkBox -q -v hires2FingHand`;
        $hiresBatWing = `checkBox -q -v hiresBatWing`;
        $hires3FingHand = `checkBox -q -v hires3FingHand`;
        $hiresTail = `checkBox -q -v hiresTail`;
        $hires4FingHand = `checkBox -q -v hires4FingHand`;
        $hires5FingHand = `checkBox -q -v hires5FingHand`;
       
        /*
        if($doToes == 1)
        {
        int $tmp = ($five_finger_hands + $human_feet);
        $human_feet = 0;
        $five_finger_hands = $tmp;
        }
        */
    }
    else
    {
    print "no window up";
    }
   
select -cl;
}

//======== end global creature variables
//======================================
//======================================
//======================================
//======================================




global proc string u_fcdb_element_path()
{
   string $fcdb_id = system ("fcdbPicker -width 1000 -height 500");
   string $id;
   string $element_path;
   if (`gmatch $fcdb_id "Id=*"`)
   {          string $bbuf[];
       tokenize $fcdb_id "=" $bbuf;                  $id = $bbuf[1];
         string $element_path_tmpx[] = `fcdbMaya EPI $id` ;
         tokenize $element_path_tmpx[0] "=" $bbuf;
       $element_path = $bbuf[1];
   }
   print $element_path;
   return $element_path;
}


//========= end u_fcdb_element_path
//======================================
//======================================
//======================================
//======================================



global proc string stretchy_chain(string $curve, string $joint)
{

//===

string $jnt;

if(`gmatch $joint "*_JNT"` == 1)
{
$jnt = `substring $joint 1 (size($joint)-4)`;
}
else
{
$jnt = $joint;
}

//===

string $stretchAttr = ($curve + ".stretch");

if(`objExists ($curve + ".stretch")` == 0)
{
addAttr -ln stretch -at double  -min 0 -max 1 -dv 0 $curve;
setAttr -e -keyable true ($curve + ".stretch");
}

float $cvs[] = `getAttr ($curve + ".cv[*]")`;
$num = `getAttr ($curve + ".spans")`;
$arcLengthNodes = `arcLengthDimension ($curve + ".u[" + $num + "]")`;
setAttr ($arcLengthNodes +".uParamValue") 10000000;
float $arcLength = `getAttr ($arcLengthNodes + ".arcLength")`;

//string $arcLengthNodes = `arcLengthDimension ($curve + ".u[1]")`;
//float $arcLength = `getAttr ($arcLengthNodes + ".arcLength")`;

shadingNode -asUtility multiplyDivide -name ($jnt + "_MUL");
setAttr ($jnt + "_MUL.operation") 2;
connectAttr -f ($arcLengthNodes + ".arcLength") ($jnt +  "_MUL.input1X");
setAttr ($jnt + "_MUL.input2X") $arcLength;

shadingNode -asUtility plusMinusAverage -name ($jnt + "_ADD");
connectAttr -f ($jnt + "_MUL.outputX") ($jnt + "_ADD.input1D[0]");
setAttr ($jnt + "_ADD.input1D[1]") 1;
setAttr ($jnt + "_ADD.operation") 2;

shadingNode -asUtility multiplyDivide -name ($jnt + "_2_MUL");
connectAttr $stretchAttr ($jnt + "_2_MUL.input1X");
connectAttr ($jnt + "_ADD.output1D") ($jnt + "_2_MUL.input2X");

shadingNode -asUtility plusMinusAverage -name ($jnt + "_2_ADD");
setAttr ($jnt + "_2_ADD.input1D[0]") 1;
connectAttr ($jnt + "_2_MUL.outputX") ($jnt + "_2_ADD.input1D[1]");

connectAttr ($jnt + "_2_ADD.output1D") ($joint + ".sx");
connectAttr ($jnt + "_2_ADD.output1D") ($joint + ".sy");
connectAttr ($jnt + "_2_ADD.output1D") ($joint + ".sz");

//===

string $joints[] = `listRelatives -ad -type joint $joint`;

for($i = 0; $i<size($joints);$i++)
{
 catchQuiet(`connectAttr -f ($joint + ".s") ($joints[$i] + ".s")`);
}

select -cl;
print "DONE";

return $stretchAttr;

}



//======================================
//======================================
//======================================
//======================================



global proc zeroT(string $node)
{

    setAttr ($node + ".t") 0 0 0;
    setAttr ($node + ".r") 0 0 0;
    setAttr ($node + ".s") 1 1 1;
}

global proc copyS()
{
$NC = `scaleConstraint -weight 1`;
delete $NC;
}

global proc copyR()
{
string $list[] = `ls -sl`;

    if(!size($list) == 2)
    {
    print "\nselect source and destination object\n";
    }
    else
    {
    float $rot[] = `xform -q -ws -ro $list[0]`;
    xform -a -ws -ro $rot[0] $rot[1] $rot[2] $list[1];
    }
}

global proc copyTrans() {

string $list[] = `ls -sl`;

    if(!size($list) == 2)
    {
    print "\nselect source and destination object\n";
    }
    else
    {
    float $pos[] = `xform -q -ws -t $list[0]`;
    float $rot[] = `xform -q -ws -ro $list[0]`;
    xform -a -ws -t $pos[0] $pos[1] $pos[2] $list[1];
    xform -a -ws -ro $rot[0] $rot[1] $rot[2] $list[1];
    }

}

global proc copyT()
{

string $list[] = `ls -sl`;

    if(!size($list) == 2)
    {
    print "\nselect source and destination object\n";
    }
    else
    {
    float $pos[] = `xform -q -ws -t $list[0]`;
    xform -a -ws -t $pos[0] $pos[1] $pos[2] $list[1];
    }
}

global proc string[] getRigPose( )
{

    //== generic rig variables
   
//==== global variables

//=== names

global string $rig_pref;
global string $rig_name;
global string $rig_prefix;
global string $prefixL;
global string $prefixR;
global string $rig_dir;

//=== modules

global int $hires;
global int $normal_spines;
global int $long_spines;
global int $long_necks;
global int $short_necks;
global int $heads;
global int $human_arms;
global int $human_legs;
global int $quadr_legs;
global int $human_feet;;
global int $one_finger_hands;
global int $two_finger_hands;
global int $three_finger_hands;
global int $four_finger_hands;
global int $five_finger_hands;
global int $bird_wings;
global int $bat_wings;
global int $tentacles;
global int $tails;
global int $fins;
global int $flippers;
global int $doStretch;
global int $doToes;
global int $hiresSpine;
global int $hiresReptSpine;
global int $hiresHead;
global int $hiresQuadrLeg;
global int $hiresShortNeck;
global int $hiresLongNeck;
global int $hiresArm;
global int $hiresTentacle;
global int $hiresLeg;
global int $hiresFlipper;
global int $hiresFin;
global int $hires1FingHand;
global int $hiresBirdWing;
global int $hires2FingHand;
global int $hiresBatWing;
global int $hires3FingHand;
global int $hiresTail;
global int $hires4FingHand;
global int $hires5FingHand;

//==== end global variables

getGlobVar ;
   
    //========================
   

string $list[] = `ls -sl`;
string $item;
string $print[];
int $nb = size($print);
int $start = size($rig_pref);

    for($item in $list)
    {
    string $lista[] = `listAttr -v -k -u -s $item`;
    string $name;
   
        $name = substring($item, $start, size($item));
       
        string $itema;
        for($itema in $lista)
        {
        float $pip = `getAttr ($item + "." + $itema)`;
        string $line = (" catchQuiet(`setAttr ($rig_pref + \"" + $name + "." +  $itema + "\") " + $pip + "`);\n");
        $print[$nb++] = $line;
        }
    }

return $print;
}


global proc string[] getPose( )
{

string $list[] = `ls -sl`;
string $item;
string $print[];
int $nb = size($print);

    for($item in $list)
    {
    string $lista[] = `listAttr -c -v -k -sa -u -s $item`;
    //string $type[] = `ls -type fcEnv $item`;
    string $type[];
       
//=== check if fcEnv node

        if(size($type) > 0)
        {
        $lista[size($lista)] = "excfl";
       
            if(`getAttr ($item + ".weightMult")` == 0)
            {
            string $par[] = `listRelatives -p $item`;
            string $line = (" catchQuiet(`setAttr " + $par[0] + ".v 0`);");
            $print[$nb++] = $line;
            }
        }

        string $itema;
       
        string $wrd[] = `ls -type wire $item`;   
       
        if(size($wrd) > 0)
        {
            $lista = {
            "envelope",
            "crossingEffect",
            "tension",
            "localInfluence",
            "rotation",
            "dropoffDistance[0]",
            "scale[0]"
            };   
        }
       
       
        for($itema in $lista)
        {
       
            if(`gmatch $itema "excfl"` == 1)
            {
            int $p[] = `getAttr ($item + "." + $itema)`;
            string $value = `fxArrayToString $p`;
            $num = size($p);
                       
            string $line = (" catchQuiet(`setAttr -typ Int32Array " + $item + "." + $itema + " " + $num + " " + $value + "`);");
            $print[$nb++] = $line;
            }
            else
            {
                if(`gmatch $itema "*visibility"` == 1)
                {
                }
                else
                {
                    if(`gmatch $itema "*.*"` == 1)
                    {
                    }
                    else
                    {
                       float $pip = `getAttr ($item + "." + $itema)`;
                    string $line = (" catchQuiet(`setAttr " + $item + "." + $itema + " " + $pip + "`);");
                    $print[$nb++] = $line;
                    }
                }
            }
        }
    }

return $print;
}

//====================================
//====================================
//====================================


global proc zeroJointOrient (){

float $rot = 1;
string $NA[] = `ls -sl -l`;
        $children = `listRelatives -type joint`;
        if(size($children) == 1) {

$jntOrX = `getAttr ($NA[0] + ".rotateX")`;
$jntOrY = `getAttr ($NA[0] + ".rotateY")`;
$jntOrZ = `getAttr ($NA[0] + ".rotateZ")`;
float $rot = $jntOrZ + $jntOrY + $jntOrX;
    if($rot == 0){
    print "\n";
    }
    else
    {

setAttr ($NA[0] + ".jointOrientX") $jntOrX;
setAttr ($NA[0] + ".jointOrientY") $jntOrY;       
setAttr ($NA[0] + ".jointOrientZ") $jntOrZ;
setAttr ($NA[0] + ".rotateX") 0;
setAttr ($NA[0] + ".rotateY") 0;
setAttr ($NA[0] + ".rotateZ") 0;
    }
                    }
                    else
                    {
                    print "\n";
                    }

$children = `listRelatives -ad -type joint`;
$howMany = `size $children`;
$i = 0;
if ($howMany > 0) {
    for( $i=0; $i < $howMany; $i++ ) {

        $children = `listRelatives -type joint`;
        if(size($children) == 1) {
       
        pickWalk -d down;       
        string $na[] = `ls -sl -l`;
        $jntOrX = `getAttr ($na[0] + ".rotateX")`;
        $jntOrY = `getAttr ($na[0] + ".rotateY")`;
        $jntOrZ = `getAttr ($na[0] + ".rotateZ")`;
        float $rot = $jntOrZ + $jntOrY + $jntOrX;
        if($rot == 0){
        print "\n";
        }
        else
        {
        setAttr ($na[0] + ".jointOrientX") $jntOrX;
        setAttr ($na[0] + ".jointOrientY") $jntOrY;       
        setAttr ($na[0] + ".jointOrientZ") $jntOrZ;
        setAttr ($na[0] + ".rotateX") 0;
        setAttr ($na[0] + ".rotateY") 0;
        setAttr ($na[0] + ".rotateZ") 0;
//        print "   ciao  ";
        }
                }
                else
                {
                print "\n";
                }
                    }
        }

}


global proc hide_locs()
{
    string $list[] = `ls -type locator`;

        for($item in $list)
        {
        catchQuiet(`setAttr ($item + ".lodVisibility") 0`);
        }

}

global proc show_locs()
{
    string $list[] = `ls -type locator`;

        for($item in $list)
        {
        catchQuiet(`setAttr ($item + ".lodVisibility") 1`);
        }

}

global proc hide_joints()
{

    string $list[] = `ls -typ joint`;
    string $item;

        for($item in $list)
        {
            setAttr ($item + ".v") 0;
        }

}


global proc string[] aim_locs(string $name)
{
string $sel[] = `ls -sl`;

    if(size($sel) > 2)
    {
    print "\nselect only two nodes\n";
    }
    else
    {
    string $name1[] = `spaceLocator -name ($name + "_ENV")`;
    string $name2[] = `spaceLocator -name ($name + "_end_ENV")`;
    select $sel[0] ($name + "_ENV");
    copyT;
    select $sel[1] ($name + "_end_ENV");
    copyT;
    select ($name + "_end_ENV") ($name + "_ENV");
   
    if(`objExists axes_ref_LOC`)
    {
    aimConstraint -name ($name + "_env_AIC") -aimVector 0 -1 0 -upVector 1
0 0 -worldUpType "objectrotation" -worldUpVector 1 0 0 -worldUpObject
axes_ref_LOC;
    }
    else
    {
    aimConstraint -name ($name + "_env_AIC") -aimVector 0 -1 0 -upVector 1
0 0 -worldUpType "scene";
    }
   
    select ($name + "_ENV") ($name + "_end_ENV");

    if(`objExists axes_ref_LOC`)
    {
    aimConstraint -name ($name + "_end_env_AIC") -aimVector 0 1 0
-upVector 1 0 0 -worldUpType "objectrotation" -worldUpVector 1 0 0
-worldUpObject axes_ref_LOC;
    }
    else
    {
    aimConstraint -name ($name + "_end_env_AIC") -aimVector 0 1 0
-upVector 1 0 0 -worldUpType "scene";
    }
   
    delete ($name + "_end_env_AIC") ($name + "_env_AIC");
    return {$name1[0], $name2[0]};
    }


}

global proc float get_distance()
{

string $locs[] = `ls -sl`;
float $dist;

    if(size($locs)>1)
    {
    //print ("\ngetting distance between this: "+$locs[0]+" and this: "+$locs[1]+"\n");
    float $uno[] = `xform -query -worldSpace -translation $locs[0]`;
    float $due[] = `xform -query -worldSpace -translation $locs[1]`;
               
    float $X = $uno[0] - $due[0];
    float $Y = $uno[1] - $due[1];
    float $Z = $uno[2] - $due[2];

    $dist = sqrt($X*$X + $Y*$Y + $Z*$Z);
    }

return $dist;
}


//====================================================================================
//====================================================================================
//====================================================================================
//====================================================================================


global proc string pullCage(string $name, float $ratio, float $length)
{

string $list[] = `ls -sl`;
string $name;
string $new_name;

    if(`gmatch $name "*_"` == 1)
    {
    string $new_name = `substring $name 1 (size($name)-1)`;
    $name = $new_name;
    }


    if(`objExists $list[2]`)
    {
    print "select only two nodes";
    }
    else
    {   
   
//=== build locators

    select $list[0] $list[1];   
    string $locs[] = `aim_locs $name`;
    select $locs;
    float $num = `get_distance`;
    float $rat = $ratio * ($num /4);
    $ratio = $rat;
    
//=== create cube mesh and clusters

    polyCube -name ($name + "_PUL");
    select -r ($name + "_PUL.vtx[2:5]") ;
    $top = `CreateCluster`;
   
    rename $top ($name + "_cage_" + $name + "_top_CLS");
    setAttr ($name + "_cage_" + $name + "_top_CLS.s") $ratio $ratio $ratio;
    select -r ($name + "_PUL.vtx[0:1]") ($name + "_PUL.vtx[6:7]") ;
    $bottom = `CreateCluster`;
    rename $bottom ($name + "_cage_bottom_CLS");
    setAttr ($name + "_cage_bottom_CLS.s") $ratio $ratio $ratio;

    //=== top cluster
   
    select $locs[0] ($name + "_cage_" + $name + "_top_CLS");
    pointConstraint -name ($name + "_cage_" + $name + "_top_cls_POC");
    orientConstraint -name ($name + "_cage_" + $name + "_top_cls_ROC");
   
    //=== bottom cluster

    select $locs[1] ($name + "_cage_bottom_CLS");
    pointConstraint -name ($name + "_cage_bottom_cls_POC");
    orientConstraint -name ($name + "_cage_bottom_cls_ROC");
   
    //=== cleanup

    select -r ($name + "_PUL") ($name + "_cage_" + $name + "_top_CLS") ($name + "_cage_bottom_CLS");
    group -name ($name + "_cage_GRP");
    setAttr ($name + "_cage_GRP.template") 1;
    select ($name + "_cage_" + $name + "_top_CLS") ($name +  "_cage_bottom_CLS");
    string $lista[] = `ls -sl`;
    string $item;
    for($item in $lista)
    {
    setAttr ($item + ".v") 0;
    }

    select ($name + "_PUL");
    DeleteHistory;
   
    //=== new
   
    parent $locs[0] $list[0];
    select $locs[0];
    makeIdentity -a 1 -t 1;
   
    parent -w $locs[0];
    select $list[0] $locs[0];
   
    parent $locs[0] $list[0];
    //dnDoConstraint ("PAC");
   
    parent ($name + "_PUL") $locs[0];
    select ($name + "_PUL");
    makeIdentity -a 1 -t 1 -r 1;
    ResetTransformations;
    delete ($name + "_cage_GRP");
    setAttr ($name + "_PUL.overrideEnabled") 1;
    setAttr ($name + "_PUL.overrideShading") 0;
    setAttr ($name + "_PUL.overrideColor") 21;
    delete $locs[1];

   
    setAttr ($name + "_PUL.sy") $length;
   
    select ($name + "_PUL");
    makeIdentity -a 1 -s 1;
    CenterPivot;
    //duplicate -name ($name + "_inner_PUL") ($name + "_PUL");

    select ($name + "_PUL");
    setAttr ($name + "_PUL.sy") 1.25;
    makeIdentity -a 1 -t 1 -r 1 -s 1;
   
    //select ($name + "_inner_PUL");
    //setAttr ($name + "_inner_PUL.sz") 0.75;
    //makeIdentity -a 1 -t 1 -r 1 -s 1;

    //parent ($name + "_inner_PUL") ($name + "_PUL");
    select -cl;
   
    return ($name + "_ENV");
    }
}

//=======================================================================================
//=======================================================================================
//=======================================================================================
//=======================================================================================
//=======================================================================================


global proc zeroJointOrient (){

float $rot = 1;
string $NA[] = `ls -sl -l`;
        $children = `listRelatives -type joint`;
        if(size($children) == 1) {

$jntOrX = `getAttr ($NA[0] + ".rotateX")`;
$jntOrY = `getAttr ($NA[0] + ".rotateY")`;
$jntOrZ = `getAttr ($NA[0] + ".rotateZ")`;
float $rot = $jntOrZ + $jntOrY + $jntOrX;
    if($rot == 0){
    print "\n";
    }
    else
    {

setAttr ($NA[0] + ".jointOrientX") $jntOrX;
setAttr ($NA[0] + ".jointOrientY") $jntOrY;       
setAttr ($NA[0] + ".jointOrientZ") $jntOrZ;
setAttr ($NA[0] + ".rotateX") 0;
setAttr ($NA[0] + ".rotateY") 0;
setAttr ($NA[0] + ".rotateZ") 0;
    }
                    }
                    else
                    {
                    print "\n";
                    }

$children = `listRelatives -ad -type joint`;
$howMany = `size $children`;
$i = 0;
if ($howMany > 0) {
    for( $i=0; $i < $howMany; $i++ ) {

        $children = `listRelatives -type joint`;
        if(size($children) == 1) {
       
        pickWalk -d down;       
        string $na[] = `ls -sl -l`;
        $jntOrX = `getAttr ($na[0] + ".rotateX")`;
        $jntOrY = `getAttr ($na[0] + ".rotateY")`;
        $jntOrZ = `getAttr ($na[0] + ".rotateZ")`;
        float $rot = $jntOrZ + $jntOrY + $jntOrX;
        if($rot == 0){
        print "\n";
        }
        else
        {
        setAttr ($na[0] + ".jointOrientX") $jntOrX;
        setAttr ($na[0] + ".jointOrientY") $jntOrY;       
        setAttr ($na[0] + ".jointOrientZ") $jntOrZ;
        setAttr ($na[0] + ".rotateX") 0;
        setAttr ($na[0] + ".rotateY") 0;
        setAttr ($na[0] + ".rotateZ") 0;
//        print "   ciao  ";
        }
                }
                else
                {
                print "\n";
                }
                    }
        }

}
global proc placePoleVectorObject(string $ikHandle, string $object, float $distance){



    float $ikPos[] = `xform -q -ws -t
(listConnections($ikHandle+".startJoint"))`;

    //create a vectorProduct for vector matrix mult
   
    if(!`objExists "VP_temp"`)       
            createNode vectorProduct -name VP_temp;

        setAttr VP_temp.operation 3;

        connectAttr -f ($ikHandle +  ".parentMatrix" )  VP_temp.matrix;
        connectAttr -f ($ikHandle +  ".poleVector" )  VP_temp.input1;



    float $poleVector[] = `getAttr VP_temp.output`;
    $poleVector[0]*= $distance;
    $poleVector[1]*= $distance;
    $poleVector[2]*= $distance;
   
    //position the object so that the vector obj-ikHandle is equipolent to the poleVector
   
    vector $pos =  <<  $poleVector[0] + $ikPos[0] ,  $poleVector[1] + $ikPos[1], $poleVector[2] + $ikPos[2]>>;
       
    xform -ws -t ($pos.x) ($pos.y) ($pos.z)  $object;

    delete VP_temp;

}

global proc string[] build_joints(string $baseName, int $ikh)
{
   
    int $num;
    string $joints[];
    string $pref;
    string $suff;
    string $list[] = `ls -sl`;
    string $item;
    select -cl;

    if(size($list) == 0)
    {
    print "\nselect objects to match in order\n";
    }
    else
    {
   
        for($i=0;$i<size($list);$i++)
        {
        string $name = ($baseName+"_"+($i+1));
        string $jnt;

            if(size($joints) == 0)
            {
            float $pos[] = `xform -q -ws -t $list[$i]`;
            float $rot[] = `xform -q -ws -ro $list[$i]`;
            $jnt = `joint -p $pos[0] $pos[1] $pos[2] -sc false -name ($name +  "_JNT")`;
            setAttr ($jnt + ".jointOrient") 0 0 0;
            $joints[`size $joints`] = $jnt;
            select $jnt;
            }
            else
            {
            float $pos[] = `xform -q -ws -t $list[$i]`;
            float $rot[] = `xform -q -ws -ro $list[$i]`;
            $jnt = `joint -p $pos[0] $pos[1] $pos[2] -sc off -name ($name +  "_JNT")`;
            joint -e -zso -oj zyx $joints[(size($joints)-1)];
            $joints[`size $joints`] = $jnt;
            select $jnt;
            }
        }
    }
   

    if($ikh>0)
    {
    select $joints[0] $joints[size($joints)-1];
    string $nodes[] = `ikHandle -s sticky`;
    rename $nodes[0] ($baseName+"_IKH");
    $joints[`size $joints`] = ($baseName+"_IKH");
    }

    select $joints;
    joint -e -spa;

    select -cl;

    return $joints;
}

//=====================================
//=====================================
//=====================================
//=====================================
//=====================================

global proc string[] build_new_joints(int $StripPrefix, string $suffix)
{
   
    int $num;
    string $joints[];
    string $pref;
    string $suff;
    string $name;
    string $list[] = `ls -sl`;
    string $item;
    select -cl;

    if(size($list) == 0)
    {
    print "\nselect objects to match in order\n";
    }
    else
    {
   
        for($item in $list)
        {
            if(`gmatch $item "*_???"` == 1)
            {
            $suff = `match "_...$" $item`;
            }
            else
            {
            $suff = "";
            }
       
            if(`gmatch $item "??_?_*"` == 1)
            {
            $num = 6;
            }
            else
            {
                if(`gmatch $item "??_*"` == 1)
                {
                $num = 4;
                }
                else
                {
                $num = 1;
                }
            }
   
       
        if($StripPrefix == 1)
        {   
        $name = substring($item,$num,(size($item) - size($suff)));
        }
        else
        {
        $name = substring($item,1,(size($item) - size($suff)));
        }

        string $jnt;

            if(size($joints) == 0)
            {
            float $pos[] = `xform -q -ws -t $item`;
            float $rot[] = `xform -q -ws -ro $item`;
            $jnt = `joint -p $pos[0] $pos[1] $pos[2] -sc false -name ($name + "_"+$suffix)`;
            joint -e -zso -oj yxz -sao xup ($name + "_"+$suffix);
            setAttr ($jnt + ".jointOrient") 0 0 0;
            makeIdentity -apply true -t 0 -r 1 -s 0 -n 0 ($name + "_"+$suffix);
           
            select $jnt;
            $joints[`size $joints`] = $jnt;
            }
            else
            {
            float $pos[] = `xform -q -ws -t $item`;
            float $rot[] = `xform -q -ws -ro $item`;
            $jnt = `joint -p $pos[0] $pos[1] $pos[2] -sc off -name ($name +  "_"+$suffix)`;
            joint -e -zso -oj yxz -sao xup $joints[(size($joints)-1)];
            setAttr ($jnt + ".jointOrient") 0 0 0;
            makeIdentity -apply true -t 0 -r 1 -s 0 -n 0 $jnt;
            select $jnt;
            $joints[`size $joints`] = $jnt;
            }
   
        }
    }


//select $joints[0];
//zeroJointOrient;

select $joints;
joint -e -spa;

setAttr ($joints[(size($joints)-1)]+".r") 0 0 0;
select -cl;

return $joints;
}

//=====================================
//=====================================
//=====================================
//=====================================
//=====================================




global proc string addLoc(string $one, string $two)
{

string $grp = ($one + "_msl_locs_GRP");

select -cl;
spaceLocator -name ($one + "_xtra_LOC");
select $one  $two ($one + "_xtra_LOC");
pointConstraint -name ($one + "_xtra_loc_POC");
select $one  $two ($one + "_xtra_LOC");
orientConstraint -name ($one + "_xtra_loc_ORC");;
parent ($one + "_xtra_LOC") `listRelatives -type joint $one`;
setAttr ($one + "_xtra_LOC.s") 15 15 15;
group -name ($one + "_msl_locs_GRP");
select $one ($one + "_xtra_LOC") $two;

return $grp;

}

global proc string[] build_joints_msl(int $StripPrefix, int $doMsls)
{
   
    int $num;
    string $joints[];
    string $mslLocs[];
    string $pref;
    string $suff;
    string $name;
    string $list[] = `ls -sl`;
    string $item;
    select -cl;


    if(size($list) == 0)
    {
    print "\nselect objects to match in order\n";
    }
    else
    {
   
        for($item in $list)
        {
            if(`gmatch $item "*_???"` == 1)
            {
            $suff = `match "_...$" $item`;
            }
            else
            {
            $suff = "";
            }
       
            if(`gmatch $item "??_?_*"` == 1)
            {
            $num = 6;
            }
            else
            {
                if(`gmatch $item "??_*"` == 1)
                {
                $num = 4;
                }
                else
                {
                $num = 1;
                }
            }
   
       
            if($StripPrefix == 1)
            {   
            $name = substring($item,$num,(size($item) - size($suff)));
            }
            else
            {
            $name = substring($item,1,(size($item) - size($suff)));
            }

        string $jnt;

            if(size($joints) == 0)
            {
            float $pos[] = `xform -q -ws -t $item`;
            float $rot[] = `xform -q -ws -ro $item`;
            $jnt = `joint -p $pos[0] $pos[1] $pos[2] -sc false -name ($name +  "_JNT")`;
            joint -e -zso -oj yxz -sao xup ($name + "_JNT");
            setAttr ($jnt + ".jointOrient") 0 0 0;
            $joints[`size $joints`] = $jnt;
            }
            else
            {
            float $pos[] = `xform -q -ws -t $item`;
            float $rot[] = `xform -q -ws -ro $item`;
            $jnt = `joint -p $pos[0] $pos[1] $pos[2] -sc off -name ($name +  "_JNT")`;
            joint -e -zso -oj zyx $joints[(size($joints)-1)];
            setAttr ($jnt + ".jointOrient") 0 0 0;
            makeIdentity -apply true -t 0 -r 1 -s 0 -n 0 $jnt;
            $joints[`size $joints`] = $jnt;
            }
           
            if($doMsls > 0)
            {
            spaceLocator -name ($name + "_msl_LOC");
            parent ($name + "_msl_LOC") ($name + "_JNT");
            setAttr ($name + "_msl_LOC.r") 0 0 0;
            setAttr ($name + "_msl_LOC.t") 0 0 0;
            setAttr ($name + "_msl_LOC.s") 1 1 1;
            $mslLocs[size($mslLocs)] = ($name + "_msl_LOC");
            }
             
           
   
        }
       
       
        if($doMsls > 0)
        {
            if(`size($mslLocs)` == 1)
            {
            select $mslLocs[0];
            fcMusclePrimitive ($name + "_MSL") 1 10 2 10 5 1 "";
            }
           
            if(`size($mslLocs)` == 2)
            {
            string $grp = `addLoc $mslLocs[0]  $mslLocs[1]`;
            fcMusclePrimitive ($name + "_MSL") 1 10 2 10 5 1 "";
            parent $grp $joints[0];
            }
           
            if(`size($mslLocs)` == 3)
            {
            string $grp = `addLoc $mslLocs[0]  $mslLocs[1]`;
            fcMusclePrimitive ($name + "_MSL") 1 10 2 10 5 1 "";
            parent $grp $joints[0];
           
            select $mslLocs[1];
            fcMusclePrimitive ($name + "_mid_MSL") 1 10 2 10 5 1 "";
           
            string $grp = `addLoc $mslLocs[1]  $mslLocs[2]`;
            fcMusclePrimitive ($name + "_MSL") 1 10 2 10 5 1 "";
            parent $grp $joints[0];
            }
           
            if(`size($mslLocs)` == 4)
            {
            string $grp = `addLoc $mslLocs[0]  $mslLocs[1]`;
            fcMusclePrimitive ($name + "_MSL") 1 10 2 10 5 1 "";
            parent $grp $joints[0];
           
            string $grp = `addLoc $mslLocs[1]  $mslLocs[2]`;
            fcMusclePrimitive ($name + "_MSL") 1 10 2 10 5 1 "";
            parent $grp $joints[0];
           
            string $grp = `addLoc $mslLocs[2]  $mslLocs[3]`;
            fcMusclePrimitive ($name + "_MSL") 1 10 2 10 5 1 "";
            parent $grp $joints[0];
            }
        }
           
    }


//select $joints[0];
//zeroJointOrient;

select $joints;
joint -e -spa;

select -cl;

return $joints;
}

//=====================================
//=====================================
//=====================================
//=====================================
//=====================================


global proc string[] build_3_chain_joints(string $name)
{
   
    int $num;
    string $joints[];
    string $pref;
    string $suff;
    string $NAME;
    string $list[] = `ls -sl`;
    select -cl;

    if(size($list) == 0)
    {
    print "\nselect objects to match in order\n";
    }
    else
    {
   
        for($i = 0;$i<size($list);$i++)
        {
        string $jnt;
       
            if($i == 0)
            {
            $NAME = ($name + "_root_JNT");
            }
            if($i == 1)
            {
            $NAME = ($name + "_mid_JNT");
            }
            if($i == 2)
            {
            $NAME = ($name + "_end_JNT");
            }

            if(size($joints) == 0)
            {
            float $pos[] = `xform -q -ws -t $list[$i]`;
            float $rot[] = `xform -q -ws -ro $list[$i]`;
            $jnt = `joint -p $pos[0] $pos[1] $pos[2] -sc false -name $NAME`;
            setAttr ($jnt + ".jointOrient") 0 0 0;
            $joints[`size $joints`] = $NAME;
            }
            else
            {
            float $pos[] = `xform -q -ws -t $list[$i]`;
            float $rot[] = `xform -q -ws -ro $list[$i]`;
            $jnt = `joint -p $pos[0] $pos[1] $pos[2] -sc off -name $NAME`;
            joint -e -zso -oj zyx $joints[(size($joints)-1)];
            setAttr ($jnt + ".jointOrient") 0 0 0;
            $joints[`size $joints`] = $NAME;
            }
   
        }
    }


select $joints;
joint -e -spa;

select -cl;

return $joints;
}

global proc string[] build_4_chain_joints(string $name)
{
   
    int $num;
    string $joints[];
    string $pref;
    string $suff;
    string $NAME;
    string $list[] = `ls -sl`;
    select -cl;

    if(size($list) == 0)
    {
    print "\nselect objects to match in order\n";
    }
    else
    {
   
        for($i = 0;$i<size($list);$i++)
        {
        string $jnt;
       
            if($i == 0)
            {
            $NAME = ($name + "_root_JNT");
            }
            if($i == 1)
            {
            $NAME = ($name + "_mid_JNT");
            }
            if($i == 2)
            {
            $NAME = ($name + "_wrist_JNT");
            }
            if($i == 3)
            {
            $NAME = ($name + "_end_JNT");
            }

            if(size($joints) == 0)
            {
            float $pos[] = `xform -q -ws -t $list[$i]`;
            float $rot[] = `xform -q -ws -ro $list[$i]`;
            $jnt = `joint -p $pos[0] $pos[1] $pos[2] -sc false -name $NAME`;
            setAttr ($jnt + ".jointOrient") 0 0 0;
            $joints[`size $joints`] = $NAME;
            }
            else
            {
            float $pos[] = `xform -q -ws -t $list[$i]`;
            float $rot[] = `xform -q -ws -ro $list[$i]`;
            $jnt = `joint -p $pos[0] $pos[1] $pos[2] -sc off -name $NAME`;
            joint -e -zso -oj zyx $joints[(size($joints)-1)];
            setAttr ($jnt + ".jointOrient") 0 0 0;
            $joints[`size $joints`] = $NAME;
            }
   
        }
    }


select $joints;
joint -e -spa;

select -cl;

return $joints;
}

global proc string[] strip_suffix(int $doit)
{

string $name;
string $suff;
string $newSuffix;
string $nodes[];
string $list[] = `ls -sl`;
string $item;

if($doit == 1)
{

    for($item in $list)
    {
   
        if(`gmatch $item "*_???"` == 1)
        {
        $suff = `match "_...$" $item`;
        $name = substring($item,1,(size($item) - size($suff)));
        rename $item ($name + $newSuffix);
        $nodes[`size($nodes)`] = ($name + $newSuffix);
        }
        else
        {
        $nodes[`size($nodes)`] = ($item + $newSuffix);
        }

   
    }
}

if($doit == 0)
{
    for($item in $list)
    {
   
        if(`gmatch $item "*_???"` == 1)
        {
        $suff = `match "_...$" $item`;
        $name = substring($item,1,(size($item) - size($suff)));
        $nodes[`size($nodes)`] = $name;
        }
        else
        {
        $nodes[`size($nodes)`] = ($item + $newSuffix);
        }

   
    }

}

return $nodes;
}

//=== strip_prefix

global proc string[] strip_prefix(int $doit)
{

string $name;
string $suff;
string $newPrefix;
string $nodes[];
string $list[] = `ls -sl`;
string $item;

if($doit == 1)
{

    for($item in $list)
    {
   
        if(`gmatch $item "????_*"` == 1)
        {
        $suff = `match "...._$" $item`;
        $name = substring($item,6,(size($item)));
        rename $item ($newPrefix + $name);
        $nodes[`size($nodes)`] = ($newPrefix + $name);
        }
        else
        {
        $nodes[`size($nodes)`] = ($item + $newPrefix);
        }

   
    }
}

if($doit == 0)
{
    for($item in $list)
    {
   
        if(`gmatch $item "????_*"` == 1)
        {
        $suff = `match "...._$" $item`;
        $name = substring($item,6,(size($item)));
        $nodes[`size($nodes)`] = $name;
        }
        else
        {
        $nodes[`size($nodes)`] = ($newPrefix + $name);
        }

   
    }

}

return $nodes;
}

//=== end strip_prefix

global proc string get_prefix()
{

string $pref;
string $nodes[];
string $list[] = `ls -sl`;

    if(`gmatch $list[0] "????_*"` == 1)
    {
    $pref = substring($list[0],1,4);
    }
    else
    {
        if(`gmatch $list[0] "????"` == 1)
        $pref = $list[0];
    }

return $pref;
}

global proc fcSearchReplace( string $oldSub, string $newSub)
{

    string $alllocs[] = `ls -l ("*" + $oldSub + "*")`;
    string $locs[];
    string $readOnly[] = `ls -l -ro ("*" + $oldSub + "*")`;
    string $shapes[] = `ls -l -type shape ("*" + $oldSub + "*")`;
    string $cvs[] = `ls "*.cv[*]"`;
    string $sets[] = `ls -type objectSet ("*" + $oldSub + "*")`;
   
    string $list[] = `ls -sl`;
    
    if(size($list))
    {
    $alllocs = `ls -l -sl ("*" + $oldSub + "*")`;
    $readOnly = `ls -l -ro -sl ("*" + $oldSub + "*")`;
    $shapes = `ls -l -type shape -sl ("*" + $oldSub + "*")`;
    $cvs = `ls -sl "*.cv[*]"`;
    $sets = `ls -sl -type objectSet ("*" + $oldSub + "*")`;
    }

        select -ne $sets $shapes $alllocs;
        select -d $readOnly $cvs;
        $locs = `ls -sl`;
        select -cl;
       
    for($i=0; $i<size($locs); $i++)
    {
        if (`objExists $locs[$i]`) 
        {
        string $newname = $locs[$i];
        
            while(`gmatch $newname ("*" + $oldSub + "*")`) 
            {
            $newname = `substitute $oldSub $newname $newSub`;
            }
            
        string $toks[];
        tokenize $newname "|" $toks;
        string $command = ("rename " + $locs[$i] + " " +  $toks[`size($toks)`-1]);
        catchQuiet(`eval $command`);
        }
    }
}

global proc string[] joints_on_path_upv2(string $jntName, int $num)
{

cycleCheck -e off;

    string $names[];
    string $locNames[];
    string $upvNames[];

    if(size($jntName) == 0)
    {
    print "select two curves, then type the joints name and their number\n";
    }


string $curves[] = `ls -sl`;

    if(size($curves) < 2)
    {
    print "\nselect first the main curve, then the upv curve\n";
    }
    else
    {
   
   
       
    string $prefix;
    string $baseName = $jntName;
    string $upvBaseName = ($jntName + "_upv");
    int $prefixSize;
   

//===================== loop

string $EXT = "_JNT";
string $ext = "_jnt";
string $loc = ($ext + "_LOC");
string $pext = ("_loc_MPA");
string $upext = "_upv_MPA";
string $UPV = "_UPV";
string $upv_LOC = "_upv_LOC";

//float $pathMaxU = `getAttr ($curves[0] + ".maxValue")`;

setAttr ($curves[0] + ".maxValue") 1;
setAttr ($curves[1] + ".maxValue") 1;

float $pathMaxU = 1;
float $path_value = ($pathMaxU/($num - 1));
if($num < 3)
{
float $path_value = $pathMaxU;
}

    for( $i=1; $i < ($num +1); $i++ )
        {
        string $name = ($baseName + $i);
        select -cl;

        //joint -n ($name + $EXT);
        spaceLocator -n ($name + $UPV);
        $upvNames[`size $upvNames`] = ($name + $UPV);       
   
        //select ($name + $UPV) $curves[1];
        $mpath = `createNode motionPath`;
       
        setAttr ($mpath + ".fractionMode") (!false);
        connectAttr ($curves[1] + ".worldSpace[0]") ($mpath + ".geometryPath");
        $mPATH = `rename $mpath ($name + $upext)`;
       
        connectAttr -f ($mPATH + ".allCoordinates") ($name + $UPV + ".translate");
       
       
       
        setAttr ($mPATH + ".u") ($path_value * ($i -1));
            if($i == ($num + 1))
            {
            setAttr ($mPATH + ".u") $pathMaxU;
            }
        }


    for( $i=1; $i < ($num +1); $i++ )
        {
        string $name = ($baseName + $i);
        select -cl;

        joint -n ($name + $EXT);
        spaceLocator -n ($name + $loc);
        $names[`size $names`] = ($name);
        $locNames[`size $locNames`] = ($name + $loc);
        parent ($name + $EXT) ($name + $loc);
       
   
        //select ($name + $loc) $curves[0];
        //$mpath = `pathAnimation -fractionMode true -follow true -followAxis x -upAxis y -worldUpType "object" -worldUpObject ($name + $UPV) -inverseUp false -inverseFront false -bank false -startTimeU 0`;
        $mpath = `createNode motionPath`;
        setAttr ($mpath + ".fractionMode") (!false);
        connectAttr ($curves[0] + ".worldSpace[0]") ($mpath +  ".geometryPath");
        $mPATH = `rename $mpath ($name + $pext)`;
        connectAttr -f ($mPATH + ".allCoordinates") ($name + $loc +  ".translate");
       
       
        if($i > 1)
        {
            if($i == ($num))
            {
            //print ("\nok, now " + $i + " is equal to " + $num + "\n");
            //print ("\n" + $baseName + ($i-1) + $loc + " is aiming at " + $name + $loc + "\n");
            select ($name + $loc) ($baseName + ($i-1) + $loc);
            aimConstraint -name ($baseName + ($i-1) + $loc + "_AIC") -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject ($baseName + ($i-1) + $UPV);

            select  ($baseName + ($i -1) + $loc) ($name + $loc);
            aimConstraint -name ($name + $loc + "_AIC") -offset 0 0 0 -weight 1 -aimVector -1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject ($name + $UPV);
           
            }
            else
            {
           
            select ($name + $loc) ($baseName + ($i-1) + $loc);
            aimConstraint -name ($baseName + ($i-1) + $loc + "_AIC") -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject ($baseName + ($i-1) + $UPV);

            }
        }
       
        setAttr ($mPATH + ".u") ($path_value * ($i -1));
            if($i == ($num + 1))
            {
            setAttr ($mPATH + ".u") $pathMaxU;
            }
        }
   
   
    }


//=== cleanup

cycleCheck -e on;

select $locNames[0];
group -n ($jntName + "jnts_GRP");
parent -w $locNames[0];
parent $locNames ($jntName + "jnts_GRP");


select $upvNames[0];
group -n ($jntName + "upvs_GRP");
parent -w $upvNames[0];
parent $upvNames ($jntName + "upvs_GRP");


select -cl;
return $names;
}


global proc string[] joints_on_path_upv(string $jntName, int $num)
{

cycleCheck -e off;

    string $names[];
    string $locNames[];
    string $upvNames[];

    if(size($jntName) == 0)
    {
    print "select two curves, then type the joints name and their number\n";
    }


string $curves[] = `ls -sl`;

    if(size($curves) < 2)
    {
    print "\nselect first the main curve, then the upv curve\n";
    }
    else
    {
   
   
       
    string $prefix;
    string $baseName = $jntName;
    string $upvBaseName = ($jntName + "_upv");
    int $prefixSize;
   

//===================== loop

string $EXT = "_JNT";
string $ext = "_jnt";
string $loc = ($ext + "_LOC");
string $pext = ("_loc_MPA");
string $upext = "_upv_MPA";
string $UPV = "_UPV";
string $upv_LOC = "_upv_LOC";

setAttr ($curves[0] + ".maxValue") 1;
setAttr ($curves[1] + ".maxValue") 1;

float $pathMaxU = 1;
float $path_value = ($pathMaxU/($num - 1));
if($num < 3)
{
float $path_value = $pathMaxU;
}

    for( $i=1; $i < ($num +1); $i++ )
        {
        string $name = ($baseName + $i);
        select -cl;

        spaceLocator -n ($name + $UPV);
        select -cl;
       
        $upvNames[`size $upvNames`] = ($name + $UPV);       
   
        $mpath = `createNode motionPath`;
       
        setAttr ($mpath + ".fractionMode") (!false);
        connectAttr ($curves[1] + ".worldSpace[0]") ($mpath +  ".geometryPath");
        $mPATH = `rename $mpath ($name + $upext)`;
        connectAttr -f ($mPATH + ".allCoordinates") ($name + $UPV +  ".translate");
       
        setAttr ($mPATH + ".u") ($path_value * ($i -1));
            if($i == ($num + 1))
            {
            setAttr ($mPATH + ".u") $pathMaxU;
            }
        }


    for( $i=1; $i < ($num +1); $i++ )
        {
        string $name = ($baseName + $i);
        select -cl;

        joint -n ($name + $EXT);
        select -cl;
        joint -n ($name + "chain" + $EXT);
        spaceLocator -n ($name + $loc);
        $names[`size $names`] = ($name);
        $locNames[`size $locNames`] = ($name + $loc);
        parent ($name + $EXT) ($name + $loc);
       
            $mpath = `createNode motionPath`;

        setAttr ($mpath + ".fractionMode") (!false);
        connectAttr ($curves[0] + ".worldSpace[0]") ($mpath +  ".geometryPath");
        $mPATH = `rename $mpath ($name + $pext)`;
        connectAttr -f ($mPATH + ".allCoordinates") ($name + "chain" + $EXT +  ".translate");
        select ($name + "chain" + $EXT) ($name + $loc);
        pointConstraint -name ($name + "_loc_POC");
       
        if($i > 1)
        {
            if($i == ($num))
            {
            //print ("\nok, now " + $i + " is equal to " + $num + "\n");
            //print ("\n" + $baseName + ($i-1) + $loc + " is aiming at " + $name + $loc + "\n");
            select ($name + $loc) ($baseName + ($i-1) + $loc);
            aimConstraint -name ($baseName + ($i-1) + $loc + "_AIC") -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject ($baseName + ($i-1) + $UPV);

            select  ($baseName + ($i -1) + $loc) ($name + $loc);
            aimConstraint -name ($name + $loc + "_AIC") -offset 0 0 0 -weight 1 -aimVector -1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject ($name + $UPV);
           
            }
            else
            {
           
            select ($name + $loc) ($baseName + ($i-1) + $loc);
            aimConstraint -name ($baseName + ($i-1) + $loc + "_AIC") -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject ($baseName + ($i-1) + $UPV);

            }
        }
       
        setAttr ($mPATH + ".u") ($path_value * ($i -1));
            if($i == ($num + 1))
            {
            setAttr ($mPATH + ".u") $pathMaxU;
            }
        }
   
   
    }


//=== chain

for($i = 0;$i<size($names);$i++)
{

    if($i>0)
    {
    CBdeleteConnection ($names[$i] + "chain_JNT.tx");
    CBdeleteConnection ($names[$i] + "chain_JNT.ty");
    CBdeleteConnection ($names[$i] + "chain_JNT.tz");
    parent ($names[$i] + "chain_JNT") ($names[$i-1] + "chain_JNT");
    connectAttr ($names[0] + "chain_JNT.s") ($names[$i] + "chain_JNT.s");
    }

}

select ($names[0] + "chain_JNT") ($names[size($names)-1] + "chain_JNT") $curves[0];
ikHandle -name ($jntName + "main_IKH") -sol ikSplineSolver -ccv false -pcv false;

/*
addAttr -ln stretch -at double  -min 0 -max 1 -dv 0 $curves[0];
setAttr -e -keyable true ($curves[0] + ".stretch");


float $cvs[] = `getAttr ($curves[0] + ".cv[*]")`;
$num = `getAttr ($curves[0] + ".spans")`;
$arcL = `arcLengthDimension ($curves[0] + ".u[" + $num + "]")`;
float $length = `getAttr ($arcL + ".arcLength")`;
shadingNode -name ($jntName + "_MUL") -asUtility multiplyDivide;
setAttr ($jntName + "_MUL.operation") 2;
connectAttr -f ($arcL + ".arcLength") ($jntName + "_MUL.input1X");
setAttr ($jntName + "_MUL.input2X") $length;

shadingNode -name ($jntName + "_ADD") -asUtility plusMinusAverage;
connectAttr -f ($jntName + "_MUL.outputX") ($jntName +  "_ADD.input1D[0]");
setAttr ($jntName + "_ADD.input1D[1]") 1;
setAttr ($jntName + "_ADD.operation") 2;

shadingNode -name ($jntName + "_xtra_MUL") -asUtility multiplyDivide;
connectAttr -f ($curves[0] + ".stretch") ($jntName +  "_xtra_MUL.input1X");
connectAttr -f ($jntName + "_ADD.output1D") ($jntName +  "_xtra_MUL.input2X");

shadingNode -name ($jntName + "_xtra_ADD") -asUtility plusMinusAverage;
connectAttr -f ($jntName + "_xtra_MUL.outputX") ($jntName +  "_xtra_ADD.input1D[0]");
setAttr ($jntName + "_xtra_ADD.input1D[1]") 1;
connectAttr -f ($jntName + "_xtra_ADD.output1D") ($names[0] +  "chain_JNT.sx");
connectAttr -f ($jntName + "_xtra_ADD.output1D") ($names[0] +  "chain_JNT.sy");
connectAttr -f ($jntName + "_xtra_ADD.output1D") ($names[0] +  "chain_JNT.sz");
*/


stretchy_chain $curves[0] ($names[0] + "chain_JNT");


//=== cleanup

cycleCheck -e on;


select $locNames[0];
group -n ($jntName + "jnts_GRP");
parent -w $locNames[0];
parent $locNames ($names[0] + "chain_JNT") ($jntName + "main_IKH")
($jntName + "jnts_GRP");


select $upvNames[0];
group -n ($jntName + "upvs_GRP");
parent -w $upvNames[0];
parent $upvNames ($jntName + "upvs_GRP");


select -cl;
return $names;
}

global proc string[] averagePointConstraint()
{

string $list[] = `ls -sl`;
$quantity = `size($list)`;
$end = $quantity - 1;
$half = $quantity / 2;
int $i;
string $item;

string $cons[];

if($quantity < 4)
{
    for( $i = 1; $i < $end; $i++ )
        {
            $item = $list[$i];
            select $list[0] $list[$end] $item;
            parentConstraint -mo -name ($item + "_PAC");
            $cons[size($cons)] = ($item + "_PAC");
        }

}
else
{

    for( $i = 1; $i < $end; $i++ )
        {
            $item = $list[$i];
            select $list[0] $list[$end] $item;
            string $poc[] = `pointConstraint`;
            $cons[size($cons)] = $poc[0];
            float $first = ((1.00 / $end) * $i);
            setAttr ($poc[0]+"." + $list[0] + "W0") (1 - $first);
            setAttr ($poc[0]+"." + $list[$end] + "W1") $first;

        }

}


select -cl;
return $cons;

}

global proc averageCopyOrient()
{

string $list[] = `ls -sl`;
$quantity = `size($list)`;
$end = $quantity - 1;
$half = $quantity / 2;
int $i;
string $item;

for( $i = 1; $i < $end; $i++ )
    {
        $item = $list[$i];
        select $list[0] $list[$end] $item;
        $n = `orientConstraint -name ($item + "_ORC")`;
        float $first = ((1.00 / $end) * $i);
        setAttr ($item + "_ORC." + $list[0] + "W0") (1 - $first);
        setAttr ($item + "_ORC." + $list[$end] + "W1") $first;
        delete $n;
       
    }

select -cl;

}

global proc string[] averageOrient()
{

string $list[] = `ls -sl`;
$quantity = `size($list)`;
$end = $quantity - 1;
$half = $quantity / 2;
int $i;
string $item;
string $orients[];

for( $i = 1; $i < $end; $i++ )
    {
        $item = $list[$i];
        select $list[0] $list[$end] $item;
        string $or[] = `orientConstraint`;
        $orients[size($orients)] = $or[0];
        float $first = ((1.00 / $end) * $i);
        setAttr ($or[0]+"." + $list[0] + "W0") (1 - $first);
        setAttr ($or[0]+"." + $list[$end] + "W1") $first;

    }

select $list;
return $orients;
}
global proc averageScale()
{

string $list[] = `ls -sl`;
$quantity = `size($list)`;
$end = $quantity - 1;
$half = $quantity / 2;
int $i;
string $item;

for( $i = 1; $i < $end; $i++ )
    {
        $item = $list[$i];
        select $list[0] $list[$end] $item;
        scaleConstraint -mo -name ($item + "_SAC");
        float $first = ((1.00 / $end) * $i);
        setAttr ($item + "_SAC." + $list[0] + "W0") (1 - $first);
        setAttr ($item + "_SAC." + $list[$end] + "W1") $first;

    }

select -cl;

}


global proc string[] splitNames()
{

string $list[] = `ls -sl`;
string $item;

string $prefix = "";;
string $nameAndSuff = "";
string $nameAndPref = "";
string $baseName = "";
string $suffix = "";

int $start = 8;

    for($item in $list)
    {

if(`gmatch $item "????_?_*"` == 1)
{
$nameAndSuff = substring($item, $start, size($item));
$prefix = substring($item, 1, 7);
}
else
{
$nameAndSuff = $item;
}


if(`gmatch $item "*_???"` == 1)
{
$suffix = substring($nameAndSuff, (size($nameAndSuff) - 3),
size($nameAndSuff));
$baseName = substring($nameAndSuff, 1, (size($nameAndSuff) - 4));
}

    }

return {$prefix, $baseName, $suffix};
}

//=================================

/*

global  proc string[] makeCurveDyn()
{

string $prefix;
string $baseName;

string $names[] = `ls -sl`;
string $item;
string $name;
string $pippo[];

for($item in $names)
{

//string $name = $names[0];
$name = $item;
string $grp[] = `listRelatives -p $name`;

select $name;
string $splitNames[] = `splitNames`;

string $prefix = $splitNames[0];
string $baseName = $splitNames[1];

makeCurvesDynamicHairs;
string $hsysSh[] = `getSelectedHairSystems`;
string $foll[] = `listConnections ($hsysSh[0] + ".outputHair")`;
string $hsys[] = `listRelatives -p $hsysSh[0]`;

string $outCrv[] = `listRelatives -ad -typ transform ($hsys[0] +  "OutputCurves")`;

select $foll[0];
string $pip[] = `listRelatives -ad -typ shape`;
string $follShape;

    for($i = 0; $i < size($pip); $i++)
    {
        if(`gmatch $pip[$i] "follicle*"` ==1)
        {
        $follShape = $pip[$i];
        }
    }

setAttr ($follShape + ".pointLock") 1;


if(`size($prefix)` > 0)
{
rename $hsys[0] ($prefix + $baseName + "_HAS");
$hsys[0] = ($prefix + $baseName + "_HAS");
rename $foll[0] ($prefix + $baseName + "_FOL");
$foll[0] = ($prefix + $baseName + "_FOL");
rename $outCrv[0] ($prefix + $baseName + "_dyn_CRV");
$outCrv[0] = ($prefix + $baseName + "_dyn_CRV");
}
else
{
rename $hsys[0] ($baseName + "_HAS");
$hsys[0] = ($baseName + "_HAS");
rename $foll[0] ($baseName + "_FOL");
$foll[0] = ($baseName + "_FOL");
rename $outCrv[0] ($baseName + "_dyn_CRV");
$outCrv[0] = ($baseName + "_dyn_CRV");
}

string $outCrvGrp[] = `listRelatives -p $outCrv[0]`;

    if(`size($grp[0])` > 0)
    {
    parent $hsys[0] $outCrv[0] $grp[0];
   
        if(`size($outCrvGrp[0])` > 0)
        {
        delete $outCrvGrp[0];
        }
    }
    else
    {
     catchQuiet(`parent -w $outCrv[0]`);
   
        if(`size($outCrvGrp[0])` > 0)
        {
         catchQuiet(`parent -w $outCrv[0]`);
        delete $outCrvGrp[0];
        }
    }

//=== shape blend

duplicate -name ($splitNames[0] + $splitNames[1] + "_fin_CRV")  $name;
select $name $outCrv[0] ($splitNames[0] + $splitNames[1] + "_fin_CRV");
blendShape -name ($splitNames[0] + $splitNames[1] + "_SHP");

addAttr -ln blend -at double -min 0 -max 1 -dv 1 ($splitNames[0] +  $splitNames[1] + "_fin_CRV");
setAttr -e -keyable true ($splitNames[0] + $splitNames[1] +  "_fin_CRV.blend");
connectAttr -f ($splitNames[0] + $splitNames[1] + "_fin_CRV.blend")
($splitNames[0] + $splitNames[1] + "_SHP." + $outCrv[0]);
shadingNode -asUtility reverse -name ($splitNames[0] + $splitNames[1] +  "_REV");
connectAttr -f ($splitNames[0] + $splitNames[1] + "_SHP." + $outCrv[0]) ($splitNames[0] + $splitNames[1] + "_REV.inputX");
connectAttr -f ($splitNames[0] + $splitNames[1] + "_REV.outputX")($splitNames[0] + $splitNames[1] + "_SHP." + $name);

$outCrv[0] = ($splitNames[0] + $splitNames[1] + "_fin_CRV");

//=== end shape blend

$pippo = {$hsys[0], $foll[0], $outCrv[0]};
}

return $pippo;

//return {$hsys[0], $foll[0], $outCrv[0]};

}

global proc string[] aim_locus(string $name)
{
string $sel[] = `ls -sl`;

    if(size($sel) > 2)
    {
    print "\nselect only two nodes\n";
    }
    else
    {
    string $name1[] = `spaceLocator -name ($name + "_LOC")`;
    string $name2[] = `spaceLocator -name ($name + "_end_LOC")`;
    select $sel[0] ($name + "_LOC");
    copyT;
    select $sel[1] ($name + "_end_LOC");
    copyT;
    select ($name + "_end_LOC") ($name + "_LOC");
   
    if(`objExists axes_ref_LOC`)
    {
    aimConstraint -name ($name + "member_AIC") -aimVector 0 -1 0 -upVector
1 0 0 -worldUpType "objectrotation" -worldUpVector 1 0 0
-worldUpObject axes_ref_LOC;
    }
    else
    {
    aimConstraint -name ($name + "member_AIC") -aimVector 0 -1 0 -upVector
1 0 0 -worldUpType "scene";
    }
   
    select ($name + "_LOC") ($name + "_end_LOC");

    if(`objExists axes_ref_LOC`)
    {
    aimConstraint -name ($name + "_endmember_AIC") -aimVector 0 1 0
-upVector 1 0 0 -worldUpType "objectrotation" -worldUpVector 1 0 0
-worldUpObject axes_ref_LOC;
    }
    else
    {
    aimConstraint -name ($name + "_endmember_AIC") -aimVector 0 1 0
-upVector 1 0 0 -worldUpType "scene";
    }
   
    delete ($name + "_endmember_AIC") ($name + "member_AIC");
    return {$name1[0], $name2[0]};
    }


}

*/

//=============================================
//=============================================
//=============================================
//=============================================


global proc string memberCage(string $name, float $ratio, float
$length)
{

string $list[] = `ls -sl`;
string $tmp = $name + "member";
$name = $tmp;


    if(`objExists $list[2]`)
    {
    print "select only two nodes";
    }
    else
    {   
   
//=== build locators

select $list[0] $list[1];   
string $locs[] = `aim_locus $name`;
select $locs;
float $num = `get_distance`;
float $rat = $ratio * ($num /4);
$ratio = $rat;
//=== create cube mesh and clusters

    polyCube -name ($name + "_MMC");
    select -r ($name + "_MMC.vtx[2:5]") ;
    $top = `CreateCluster`;
   
    rename $top ($name + "_cage_" + $name + "_top_CLS");
    setAttr ($name + "_cage_" + $name + "_top_CLS.s") $ratio $ratio
$ratio;
    select -r ($name + "_MMC.vtx[0:1]") ($name + "_MMC.vtx[6:7]") ;
    $bottom = `CreateCluster`;
    rename $bottom ($name + "_cage_bottom_CLS");
    setAttr ($name + "_cage_bottom_CLS.s") $ratio $ratio $ratio;

    //=== top cluster
   
    select $locs[0] ($name + "_cage_" + $name + "_top_CLS");
    pointConstraint -name ($name + "_cage_" + $name + "_top_cls_POC");
    orientConstraint -name ($name + "_cage_" + $name + "_top_cls_ROC");
   
    //=== bottom cluster

    select $locs[1] ($name + "_cage_bottom_CLS");
    pointConstraint -name ($name + "_cage_bottom_cls_POC");
    orientConstraint -name ($name + "_cage_bottom_cls_ROC");
   
    //=== cleanup

    select -r ($name + "_MMC") ($name + "_cage_" + $name + "_top_CLS")
($name + "_cage_bottom_CLS");
    group -name ($name + "_cage_GRP");
    setAttr ($name + "_cage_GRP.template") 1;
    select ($name + "_cage_" + $name + "_top_CLS") ($name +  "_cage_bottom_CLS");
    string $lista[] = `ls -sl`;
    string $item;
    for($item in $lista)
    {
    setAttr ($item + ".v") 0;
    }

    select ($name + "_MMC");
    DeleteHistory;
   
    //=== new

   
    parent $locs[0] $list[0];
    select $locs[0];
    makeIdentity -a 1 -t 1;
   
    parent -w $locs[0];

    parent ($name + "_MMC") $locs[0];
    select ($name + "_MMC");
    makeIdentity -a 1 -t 1 -r 1;
    ResetTransformations;
    delete ($name + "_cage_GRP");
    setAttr ($name + "_MMC.overrideEnabled") 1;
    setAttr ($name + "_MMC.overrideColor") 21;
    delete $locs[1];

   
    setAttr ($name + "_MMC.sy") $length;
   
    select ($name + "_MMC");
    makeIdentity -a 1 -s 1;
    CenterPivot;

    select ($name + "_MMC");
    setAttr ($name + "_MMC.sy") 1.25;
    makeIdentity -a 1 -t 1 -r 1 -s 1;
   
    select -cl;
   
    return ($name + "_MMC");
    }

}

global proc string[] get_dist(string $first, string $second)
{

float $dist;

string $locs[] = {$first, $second};

float $sp[] = `xform -query -worldSpace -translation $locs[0]`;
float $ep[] = `xform -query -worldSpace -translation $locs[1]`;
               
string $id;
string $shapes[] = `listRelatives -c -s $locs`;

    if(size($shapes) == 0)
    {
    spaceLocator -p $sp[0] $sp[1] $sp[2] -name ($first + "_start_loc");
    $shapes[`size($shapes)`] = "start_locShape";
    spaceLocator -p $ep[0] $ep[1] $ep[2] -name ($second + "_end_loc");
    $shapes[`size($shapes)`] = "end_locShape";
    }


    for($i = 0; $i < 2; $i++)
    {
    string $id1 = `nodeType $shapes[0]`;
    string $id2 = `nodeType $shapes[1]`;
    string $loc1 = `match "locator" $id1`;
    string $loc2 = `match "locator" $id2`;

    if(!size($loc1) == 0)
    {
    spaceLocator -name pippo;
    select $locs[0] pippo;
    pointConstraint;
    $locP1 = `xform -query -worldSpace -translation pippo`;
    delete pippo;
    $sp = $locP1;
    }
   
    if(!size($loc2) == 0)
    {
    spaceLocator -name pippo;
    select $locs[1] pippo;
    pointConstraint;
    $locP2 = `xform -query -worldSpace -translation pippo`;
    delete pippo;
    $ep = $locP2;
    }

}
               
distanceDimension -sp $sp[0] $sp[1] $sp[2] -ep $ep[0] $ep[1] $ep[2];

string $d[] = `pickWalk -d up`;
rename $d[1] ($locs[0] + "_DST");
select ($locs[0] + "_DST");
string $distName[] = `ls -sl`;
select -cl;
$dist = `getAttr ($distName[0] + "Shape.distance")`;
//delete $distName;
if(`objExists start_loc`)
{
delete start_loc end_loc;
}
return {$distName[0], $dist};
}



global proc string find_closest()
{

string $list[] = `ls -sl`;
float $alldist[];
float $min;
string $obj = $list[(size($list) -1)];
string $closest[];
string $distName;

    for($i = 0; $i < (size($list) -1); $i++)
    {
        if($i > 0)
        {
        string $distNames[] = `get_dist $list[$i] $obj`;
        string $distName = $distNames[0];
        float $distance = (float)$distNames[1];
       
        $alldist[size($alldist)] = $distance;
        $min = `min $alldist[$i -1] $alldist[$i]`;
        //print ("\nthis is " + $alldist[$i] + "\n");
       
            if(($distance - $min) == 0)
            {
            $closest = `listConnections ($distName + "Shape.startPoint")`;
            //print ("\nthe min is " + $min + "\n");
            //print ("\ncurrent distance is " + $distance + "\n");
            //print ("\nclosest node is " + $closest[0] + "\n");
            }
        delete $distName;
        }
        else
        {
        string $distNames[] = `get_dist $list[$i] $obj`;
        string $distName = $distNames[0];
        float $distance = (float)$distNames[1];
        $alldist[size($alldist)] = $distance;
        $min = `min $alldist[$i] $alldist[$i]`;
        //print ("\nthis is " + $alldist[$i] + "\n");
            if(($distance - $min) == 0)
            {
            $closest = `listConnections ($distName + "Shape.startPoint")`;
            //print ("\nthe min is " + $min + "\n");
            //print ("\ncurrent distance is " + $distance + "\n");
            //print ("\nclosest node is " + $closest[0] + "\n");
            }
        delete $distName;
        }
    }

//print ("\nMIN is " + $min + "\n");
//print ("\nits distance node is " + $closest[0] + "\n");

return $closest[0];

}
global proc string[] chain_multi_ik()
{

string $iks[];
clear $iks;
string $list[] = `ls -sl`;
int $num = `size($list)`;

    if(size($list) == 0)
    {
    print "select joints in the right order\n";
    }
    else
    {

        for( $i=0; $i < ($num -1); $i++ )
        {
        select $list[($i + 1)] $list[$i];
        ikHandle -sol ikRPsolver -shf false -s sticky;
        $ikh = `ls -sl`;
        $ik = `rename $ikh ($list[$i] + "_IKH")`;
        $iks[`size $iks`] = $ik;
        }


    }

return $iks;
}
global proc string[] joints_on_path(string $jntName, int $num)
{

cycleCheck -e off;

    string $names[];
   
    if(size($jntName) == 0)
    {
    print "select a curve and type a number of joints\n";
    }


string $curve[] = `ls -sl`;

    if(size($curve) == 0)
    {
    print "no curve selected\n";
    }
    else
    {
    string $prefix;
    string $baseName = $jntName;
    int $prefixSize;
   

//===================== loop

string $EXT = "_JNT";
string $ext = "_jnt";
string $loc = ($ext + "_LOC");
string $pext = ($loc + "_mpa");

float $path_value = (1.00/($num - 1));
if($num < 3)
{
float $path_value = 1.00;
}



    for( $i=1; $i < ($num +1); $i++ )
        {
        string $name = ($baseName + $i);
        select -cl;

        joint -n ($name + $EXT);
        spaceLocator -n ($name + $loc);
        $names[`size $names`] = ($name + $loc);

        parent ($name + $EXT) ($name + $loc);
       
   
        select ($name + $loc) $curve[0];
        $mpath = `pathAnimation -fractionMode true -follow true -followAxis x
-upAxis y -worldUpType "normal" -inverseUp false -inverseFront false
-bank false -startTimeU 0`;
        $mPATH = `rename $mpath ($name + $pext)`;
   
   
        CBdeleteConnection ($name + $loc + ".rx");
        CBdeleteConnection ($name + $loc + ".ry");
        CBdeleteConnection ($name + $loc + ".rz");
        disconnectAttr ($name + $pext + ".rotateOrder") ($name + $loc +  ".rotateOrder");
        string $pip[] =  `listConnections -d 1 -c 1 -p 1 ($name + $loc +  ".transMinusRotatePivotZ")`;
        disconnectAttr $pip[0] $pip[1];
        string $pip[] =  `listConnections -d 1 -c 1 -p 1 ($name + $loc +  ".transMinusRotatePivotY")`;
        disconnectAttr $pip[0] $pip[1];
        string $pip[] =  `listConnections -d 1 -c 1 -p 1 ($name + $loc +  ".transMinusRotatePivotX")`;
        disconnectAttr $pip[0] $pip[1];


   
        setAttr ($name + $loc + ".rotateX") 0;
        setAttr ($name + $loc + ".rotateY") 0;
        setAttr ($name + $loc + ".rotateZ") 0;
   
        CBdeleteConnection ($mPATH + ".u");
        setAttr ($mPATH + ".u") ($path_value * ($i -1));
            if($i == ($num + 1))
            {
            setAttr ($mPATH + ".u") 1;
            }
        }
   
   
    }

cycleCheck -e on;
   
select -cl;
return $names;
}

    global proc string[] chain_multi_ik()
    {

    string $iks[];
    clear $iks;
    string $list[] = `ls -sl`;
    int $num = `size($list)`;

        if(size($list) == 0)
        {
        print "select joints in the right order\n";
        }
        else
        {

            for( $i=0; $i < ($num -1); $i++ )
            {
            select $list[($i + 1)] $list[$i];
            ikHandle -sol ikRPsolver -shf false -s sticky;
            $ikh = `ls -sl`;
            $ik = `rename $ikh ($list[$i] + "_IKH")`;
            $iks[`size $iks`] = $ik;
            }


        }

    return $iks;
    }


global proc string[] updown_chain(int $do_IKs)
{

string $jointsUP[];
string $jointsDOWN[];
clear $jointsUP;
clear $jointsDOWN;
string $list[] = `ls -sl`;
string $item;

    if(!size($list))
    {
    print "select nodes to match with joints, in the right order\n";
    }
    else
    {




        for($item in $list)
        {
        select -cl;
        $jointUP = `joint -name ($item + "_up_JNT")`;
        select -cl;
        $jointDOWN = `joint -name ($item + "_down_JNT")`;
        select -cl;
        $jointsUP[`size $jointsUP`] = $jointUP;
        $jointsDOWN[`size $jointsDOWN`] = $jointDOWN;
        select $item $jointUP;
        copyT;
        select $item $jointDOWN;
        copyT;
        select -cl;
        }

        int $num = `size($list)`;
        for( $i=0; $i < ($num -1); $i++ )
        {
        parent $jointsUP[($i + 1)] $jointsUP[$i];
        }

select -cl;

        for( $i=0; $i < ($num -1); $i++ )
        {
        parent $jointsDOWN[$i] $jointsDOWN[($i + 1)];
        }

select -cl;


    }

string $iksUP[];
string $iksDOWN[];

if($do_IKs == 1)
{
select $jointsUP;
string $iksUP[] = `chain_multi_ik`;
select $jointsDOWN;
string $iksDOWN[] = `chain_multi_ik`;
}
else
{
print "no iks";
}

select -cl;
string $joints[] = `stringArrayCatenate $jointsUP $jointsDOWN`;
string $chainUP[] = `stringArrayCatenate $jointsUP $iksUP`;
string $chainDOWN[] = `stringArrayCatenate $jointsDOWN $iksDOWN`;

return $joints;

}

//=================================================================
//=================================================================
//=================================================================

global proc change_suffix(string $newSuffix)
{

string $name;
string $suff;

string $list[] = `ls -sl`;
string $item;

    for($item in $list)
    {
   
        if(`gmatch $item "*_???"` == 1)
        {
        $suff = `match "_...$" $item`;
        $name = substring($item,1,(size($item) - size($suff)));
        rename $item ($name + "_" + $newSuffix);
        }
        else
        {
        print "\nNo valid existing suffix found\n";
        }

   
    }

}
global proc string[] rename_control(string $name)
{

string $ls[] = `sets -q -no SEL`;
string $list[] = sort($ls);
string $new_list[];


    for($i = 0; $i < size($list); $i++)
    {
    rename $list[$i] ($name + "_" + $list[$i]);
    $new_list[size($new_list)] = ($name + "_" + $list[$i]);
    }
   


sets -rm SEL $new_list;
delete SEL;

select -cl;
return $new_list;
}
   
global proc string[] sceneRigPref()
{

select -all;
string $topNodes[] = `ls -sl -et transform`;
select $topNodes;
string $prefs[];
//string $names[];

for($i = 0; $i < size($topNodes); $i++)
{
    if(`gmatch $topNodes[$i] "????_*"` == 1)
    {
        if(`objExists ($topNodes[$i] + ".version")`)
        {
        $prefs[size($prefs)] = substring($topNodes[$i], 1, 4);
        //$names[size($names)] = substring($topNodes[$i], 6, size($topNodes[$i]));
        }
    }
}

return $prefs;
}

//============================================================================
//============================================================================
//============================================================================

global proc string[] sceneRigName()
{

select -all;
string $topNodes[] = `ls -sl -et transform`;
select $topNodes;
string $names[];

for($i = 0; $i < size($topNodes); $i++)
{
    if(`gmatch $topNodes[$i] "????_*"` == 1)
    {
        if(`objExists ($topNodes[$i] + ".version")`)
        {
        $names[size($names)] = substring($topNodes[$i], 6,
size($topNodes[$i]));
        }
    }
}

return $names;
}

//============================================================================
//============================================================================
//============================================================================
//============================================================================

global proc string[] joints_on_path_upv_fin(string $jntName, int $num)
{

cycleCheck -e off;

    string $names[];
    string $locNames[];
    string $upvNames[];

    if(size($jntName) == 0)
    {
    print "select two curves, then type the joints name and their number\n";
    }


string $curves[] = `ls -sl`;

    if(size($curves) < 2)
    {
    print "\nselect first the main curve, then the upv curve\n";
    }
    else
    {
   
   
       
    string $prefix;
    string $baseName = $jntName;
    string $upvBaseName = ($jntName + "_upv");
    int $prefixSize;
   

//===================== loop

string $EXT = "_JNT";
string $ext = "_jnt";
string $loc = ($ext + "_LOC");
string $pext = ("_loc_MPA");
string $upext = "_upv_MPA";
string $UPV = "_UPV";
string $upv_LOC = "_upv_LOC";

//float $pathMaxU = `getAttr ($curves[0] + ".maxValue")`;

setAttr ($curves[0] + ".maxValue") 1;
setAttr ($curves[1] + ".maxValue") 1;

float $pathMaxU = 1;
float $path_value = ($pathMaxU/($num - 1));
if($num < 3)
{
float $path_value = $pathMaxU;
}

    for( $i=1; $i < ($num +1); $i++ )
        {
        string $name = ($baseName + $i);
        select -cl;

        //joint -n ($name + $EXT);
        spaceLocator -n ($name + $UPV);
        $upvNames[`size $upvNames`] = ($name + $UPV);       
   
        //select ($name + $UPV) $curves[1];
        $mpath = `createNode motionPath`;
       
        setAttr ($mpath + ".fractionMode") (!false);
        connectAttr ($curves[1] + ".worldSpace[0]") ($mpath +  ".geometryPath");
        $mPATH = `rename $mpath ($name + $upext)`;
       
        connectAttr -f ($mPATH + ".allCoordinates") ($name + $UPV +  ".translate");
       
       
       
        setAttr ($mPATH + ".u") ($path_value * ($i -1));
            if($i == ($num + 1))
            {
            setAttr ($mPATH + ".u") $pathMaxU;
            }
        }


    for( $i=1; $i < ($num +1); $i++ )
        {
        string $name = ($baseName + $i);
        select -cl;

        joint -n ($name + $EXT);
        spaceLocator -n ($name + $loc);
        $names[`size $names`] = ($name);
        $locNames[`size $locNames`] = ($name + $loc);
        parent ($name + $EXT) ($name + $loc);
       
   
        //select ($name + $loc) $curves[0];
        //$mpath = `pathAnimation -fractionMode true -follow true -followAxis x -upAxis y -worldUpType "object" -worldUpObject ($name + $UPV) -inverseUp false -inverseFront false -bank false -startTimeU 0`;
        $mpath = `createNode motionPath`;
        setAttr ($mpath + ".fractionMode") (!false);
        connectAttr ($curves[0] + ".worldSpace[0]") ($mpath +  ".geometryPath");
        $mPATH = `rename $mpath ($name + $pext)`;
        connectAttr -f ($mPATH + ".allCoordinates") ($name + $loc +  ".translate");
       
       
        if($i > 1)
        {
            if($i == ($num + 1))
            {
            select ($name + $loc) ($baseName + ($i-1) + $loc);
            aimConstraint -name ($baseName + ($i-1) + $loc + "_AIC") -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject ($baseName + ($i-1) + $loc + $UPV);

            select  ($baseName + ($i -1) + $loc) ($name + $loc);
            aimConstraint -name ($name + $loc + "_AIC") -offset 0 0 0 -weight 1 -aimVector -1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject ($name + $UPV);           
            }
            else
            {
           
            select ($name + $loc) ($baseName + ($i-1) + $loc);
            aimConstraint -name ($baseName + ($i-1) + $loc + "_AIC") -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject ($baseName + ($i-1) + $UPV);

            }
        }
       
        setAttr ($mPATH + ".u") ($path_value * ($i -1));
            if($i == ($num + 1))
            {
            setAttr ($mPATH + ".u") $pathMaxU;
            }
        }
   
   
    }


//=== cleanup

cycleCheck -e on;

select $locNames;
group -n ($jntName + "jnts_GRP");
select $upvNames;
group -n ($jntName + "upvs_GRP");

select -cl;
return $names;
}

/*
    Connect output of hair curves to what the curves were connected to
*/

global proc hdMakeCurvesDynamicHairs()
{
    string $hsystems[] = `getSelectedHairSystems`;   
    string $hsys = "" ;
    if( size( $hsystems ) > 0 ){
        $hsys = $hsystems[0];
    }
    int $i, $j, $k, $l;
    string $curves[] = `ls -sl -dag -type nurbsCurve`;

    if( size( $curves ) < 1 ){
        warning( "No curves selected\n" );
        return;
    }
    string $parent = "";
    int   $lastIndex[] = {0};
    int $madeHairCurve = false;
    string $hsysGroup = "";
    string $hsysOutputHairGroup = "";
    for( $i = 0; $i < size( $curves ); $i++ ){
        string $curve = $curves[$i];
        string $con[] = `listConnections -sh 1 ($curve + ".worldSpace[0]")`;
        int $j;
        int $attachedToHairCurve = false;
        for( $j = 0; $j < size( $con ); $j++ ){
            string $type = nodeType( $con[ $j ] );
            if( $type == "follicle" ){
                $attachedToHairCurve = true;
                continue;
            }
        }
        if( $attachedToHairCurve ){
            continue;
        }
        int $intermediateObject = `getAttr ($curve + ".io")`;
        if( 0 != $intermediateObject ){
            continue;
        }
       


        $madeHairCurve = true;
        if( $hsys == "" ){
            // create the first time we hit a valid curve
            $hsys     = `createNode hairSystem`;
            // we want uniform stiffness because the curves
            // are initially point locked to both ends
            removeMultiInstance -break true ($hsys + ".stiffnessScale[1]");
            setAttr ($hsys + ".clumpWidth") 0.0;
            connectAttr time1.outTime ($hsys + ".currentTime");
        }
        string $hsysParent[] = `listTransforms $hsys`;
        if( size($hsysParent) > 0  ){
            if( $hsysGroup == "" ){
                $hsysGroup = ($hsysParent[0] + "Follicles");
                if( !objExists($hsysGroup ) ){
                    $hsysGroup = `group -em -name $hsysGroup`;
                }
            }
            if( $hsysOutputHairGroup == "" ){
                $hsysOutputHairGroup = ($hsysParent[0] + "OutputCurves");
                if( !objExists($hsysOutputHairGroup ) ){
                    $hsysOutputHairGroup = `group -em -name $hsysOutputHairGroup`;
                }
            }
        }

        // Determine if the curve is a COS or just a regular curve.
        // This is cloned from "convertCurvesToStrokes.mel"
        int $COS = 0;
        string $relatives[] = `listRelatives -ap -p $curve`;
        for ($j = 0; $j < size( $relatives ); $j++) {
            string $testMe = $relatives[$j];
            if (`nodeType $testMe` == "transform") {
                string $testList[] = `listRelatives -ap -p $testMe`;
                for ($k = 0; $k < size( $testList ); $k++) {
                    string $subTest = $testList[$k];
                    if (`nodeType $subTest` == "curveVarGroup") {
                        string $testList2[] = `listRelatives -ap -p $subTest`;
                        for ($l = 0; $l < size( $testList2 ); $l++) {
                            if (`nodeType $testList2[$l]` == "nurbsSurface") {
                                $COS = 1;
                                $parent = $testList2[$l];
                                $j = size( $relatives );
                                $k = size( $testList  );
                                $l = size( $testList2 );
                            }
                        }
                    }
                    else {
                        if (`nodeType $testList[$k]` == "nurbsSurface") {
                            $COS = 1;
                            $parent = $testList[$k];
                            $j = size( $relatives);
                            $k = size( $testList );
                        }
                    }
                }
            }
            else if (`nodeType $testMe` == "nurbsSurface") {
                $parent = $testMe;
                $COS = 1;
                $j = size( $relatives);
            }
        }
        if ( $COS == 1 ) {
            // the name in $curves is something like nurbsPlane->curve1: this
            // has illegal characters for a name so we use the default naming
            // string $cFS = `createNode "curveFromSurfaceCoS" -name ($curves[$i] + "cFS")`;
            string $cFS = `createNode "curveFromSurfaceCoS"`;
            // Do we need to check the index of the WS connections?
            connectAttr ($curve + ".ws[0]") ($cFS + ".curveOnSurface");
            connectAttr ($parent + ".ws[0]") ($cFS + ".inputSurface");
            $curve = $cFS;
        }


        string $surf = ""; // no surface to attach to
        int $doRest = false;
        // Check if the original curve was connected to something and replace connections if any
        string $cons[] = `listConnections -p 1 -sh 1 -s 0 -d 1 ($curve +  ".worldSpace[0]")`;
//=== maya6.5
/*
        string $hname = createHairCurveNode($hsys, $surf,
                            0.0, 0.0, 0, true, true,
                            $doRest, false, $curve, 1.0, $lastIndex,
                            $hsysGroup, $hsysOutputHairGroup);

*/
//=== end maya6.5
//=== maya7.0

        string $hname = createHairCurveNode($hsys, $surf,
                            0.0, 0.0, 0, true, true,
                            $doRest, false, $curve, 1.0, $lastIndex,
                            $hsysGroup, $hsysOutputHairGroup, 3);


//=== end maya7.0

        if( size( $hname ) > 0 ){
            setAttr ( $hname + ".pointLock" ) 1;
            setAttr ( $hname + ".restPose" ) 1;
            // Retrieve the curve connected to the follicle
            string $out[] = `listConnections -sh 1 -s 0 -d 1 ( $hname +  ".outCurve")`;
            if( size( $out ) > 0 )
            {
                int $c;
                for( $c = 0; $c < size( $cons ); $c++ )
                {
                    connectAttr -f ( $out[0] + ".worldSpace[0]" ) $cons[$c];
                }
            }
            else
            {
                print ( "Couldn't retrieve output curve for " + $hname + "\n");
            }
        }
    }
    // delete the follicle groups if we did not add any hairs to them
    if( objExists($hsysGroup ) ){
        string $shapes[] = `ls -s -dag $hsysGroup`;
        if( 0 == size($shapes) ){
            delete $hsysGroup;
        }
    }
    if( objExists($hsysOutputHairGroup ) ){
        string $shapes[] = `ls -s -dag $hsysOutputHairGroup`;
        if( 0 == size($shapes) ){
            delete $hsysOutputHairGroup;
        }
    }
    if( $madeHairCurve ){
        select $hsys;
    } else {
        warning( "Selected curves already are dynamic hair curves\n" );
    }
}

global proc simmetry(string $name)
{

$RX = ".rx";
$RY = ".ry";
$RZ = ".rz";

$TX = ".tx";
$TZ = ".tz";

if(`objExists axes_ref_LOC`)
{

int $rotY = `getAttr axes_ref_LOC.ry`;

    if($rotY > 85)
    {
        if($rotY < 95)
        {
        $TX = ".tz";
        $TZ = ".tx";
        $RX = ".rz";
        $RZ = ".rx";
        }
    }
    if($rotY < -85)
    {
        if($rotY > -95)
        {
        $TX = ".tz";
        $TZ = ".tx";
        $RX = ".rz";
        $RZ = ".rx";
        }
    }
}

//==== global variables

//=== names

global string $rig_pref;
global string $rig_name;
global string $rig_prefix;
global string $prefixL;
global string $prefixR;
global string $rig_dir;

//=== modules

global int $hires;
global int $normal_spines;
global int $long_spines;
global int $long_necks;
global int $short_necks;
global int $heads;
global int $human_arms;
global int $human_legs;
global int $quadr_legs;
global int $human_feet;;
global int $one_finger_hands;
global int $two_finger_hands;
global int $three_finger_hands;
global int $four_finger_hands;
global int $five_finger_hands;
global int $bird_wings;
global int $bat_wings;
global int $tentacles;
global int $tails;
global int $fins;
global int $flippers;
global int $doStretch;
global int $doToes;
global int $hiresSpine;
global int $hiresReptSpine;
global int $hiresHead;
global int $hiresQuadrLeg;
global int $hiresShortNeck;
global int $hiresLongNeck;
global int $hiresArm;
global int $hiresTentacle;
global int $hiresLeg;
global int $hiresFlipper;
global int $hiresFin;
global int $hires1FingHand;
global int $hiresBirdWing;
global int $hires2FingHand;
global int $hiresBatWing;
global int $hires3FingHand;
global int $hiresTail;
global int $hires4FingHand;
global int $hires5FingHand;

//==== end global variables

getGlobVar ;

    string $lista[] = `ls ($prefixL + $name + "_GRP") ($prefixL + $name + "*_PIV") ($prefixL + $name + "*_NRB")`;   
    string $listb[] = `ls ($prefixR + $name + "_GRP") ($prefixR + $name + "*_PIV") ($prefixR + $name + "*_NRB")`;   

    for($i = 0; $i < size($lista); $i++)
    {
    
        if(`gmatch $lista[$i] "*NRB"`)
        {
        shadingNode -asUtility multiplyDivide -name ($lista[$i] + "_scale_MUL");
        catchQuiet(`connectAttr -f ($lista[$i] + ".sx") ($lista[$i] +  "_scale_MUL.input1X")`);
        setAttr ($lista[$i] + "_scale_MUL.input2X") -1;
        catchQuiet(`connectAttr -f ($lista[$i] + "_scale_MUL.outputX") ($listb[$i] +  ".sx")`);
        catchQuiet(`connectAttr -f ($lista[$i] + ".sy") ($listb[$i] + ".sy")`);
        catchQuiet(`connectAttr -f ($lista[$i] + ".sz") ($listb[$i] + ".sz")`);
        }
        else
        {
        catchQuiet(`connectAttr -f ($lista[$i] + ".s") ($listb[$i] + ".s")`);
        }
       
    catchQuiet(`connectAttr -f ($lista[$i] + ".ty") ($listb[$i] + ".ty")`);
    catchQuiet(`connectAttr -f ($lista[$i] + $TZ) ($listb[$i] + $TZ)`);
    catchQuiet(`connectAttr -f ($lista[$i] + $RX) ($listb[$i] + $RX)`);
       
    shadingNode -asUtility multiplyDivide -name ($lista[$i] + "_MUL");
    setAttr ($lista[$i] + "_MUL.input2X") -1;
    setAttr ($lista[$i] + "_MUL.input2Y") -1;
    setAttr ($lista[$i] + "_MUL.input2Z") -1;

    catchQuiet(`connectAttr -f ($lista[$i] + $TX) ($lista[$i] +  "_MUL.input1X")`);
    catchQuiet(`connectAttr -f ($lista[$i] + "_MUL.outputX") ($listb[$i] +  $TX)`);
   
    catchQuiet(`connectAttr -f ($lista[$i] + $RY) ($lista[$i] +  "_MUL.input1Y")`);
    catchQuiet(`connectAttr -f ($lista[$i] + $RZ) ($lista[$i] +  "_MUL.input1Z")`);
    catchQuiet(`connectAttr -f ($lista[$i] + "_MUL.outputY") ($listb[$i] +  $RY)`);
    catchQuiet(`connectAttr -f ($lista[$i] + "_MUL.outputZ") ($listb[$i] +  $RZ)`);
    }

//=== second bit
       
       
       
    if(`objExists ($prefixR + $name + "*AIC")`)
    {
    select ($prefixR + $name + "*AIC");
   
        if(`objExists ($prefixR + $name + "*_finger2*_AIC")`)
        {
        select -d ($prefixR + $name + "*_finger2*_AIC");
        }
        if(`objExists ($prefixR + $name + "*_finger3*_AIC")`)
        {
        select -d ($prefixR + $name + "*_finger3*_AIC");   
        }
        if(`objExists ($prefixR + $name + "*_finger4*_AIC")`)
        {
        select -d ($prefixR + $name + "*_finger4*_AIC");   
        }
        if(`objExists ($prefixR + $name + "*_finger5*_AIC")`)
        {
        select -d ($prefixR + $name + "*_finger5*_AIC");
        }
       
    string $list[] = `ls -sl`;
    string $item;

        for($item in $list)
        {
        float $x = `getAttr ($item + ".upVectorX")`;
        float $y = `getAttr ($item + ".upVectorY")`;
        float $z = `getAttr ($item + ".upVectorZ")`;
       
            if(($x * $x) == 1)
            {
            setAttr ($item + ".upVectorX") ($x * -1);
            }
            if(($y * $y) == 1)
            {
            setAttr ($item + ".upVectorY") ($y * -1);
            }
            if(($z * $z) == 1)
            {
            setAttr ($item + ".upVectorZ") ($z * -1);
            }
        }
    }



}

global proc string[] sceneRigPref()
{

select -all;
string $topNodes[] = `ls -sl -et transform`;
select $topNodes;
string $prefs[];

for($i = 0; $i < size($topNodes); $i++)
{
    if(`gmatch $topNodes[$i] "????_*"` == 1)
    {
        if(`objExists ($topNodes[$i] + ".version")`)
        {
        $prefs[size($prefs)] = substring($topNodes[$i], 1, 4);
        }
    }
}

return $prefs;
}

global proc string[] sceneRigName()
{

select -all;
string $topNodes[] = `ls -sl -et transform`;
select $topNodes;
string $names[];

for($i = 0; $i < size($topNodes); $i++)
{
    if(`gmatch $topNodes[$i] "????_*"` == 1)
    {
        if(`objExists ($topNodes[$i] + ".version")`)
        {
        $names[size($names)] = substring($topNodes[$i], 6,
size($topNodes[$i]));
        }
    }
}

return $names;
}

//====

global proc mpa()

{
string $nodes[] = `ls -sl`;
string $pat = `pathAnimation -fractionMode true -follow false`;
rename $pat ($nodes[1] + "_MPA");
CBdeleteConnection ($nodes[1] + "_MPA.u");

string $del[] = `listConnections ($nodes[1] +  ".transMinusRotatePivotX")`;
delete $del[0];
string $del[] = `listConnections ($nodes[1] +  ".transMinusRotatePivotY")`;
delete $del[0];
string $del[] = `listConnections ($nodes[1] +  ".transMinusRotatePivotZ")`;
delete $del[0];
disconnectAttr ($nodes[1] + "_MPA.message")  ($nodes[1] +  ".specifiedManipLocation");

connectAttr -f ($nodes[1] + "_MPA.allCoordinates") ($nodes[1] +  ".translate");

setKeyframe ($nodes[1] + "_MPA.u");
}

//====

global proc mpa_vel()

{

string $nodes[] = `ls -sl`;
string $pat = `pathAnimation -fractionMode true -follow false`;
rename $pat ($nodes[1] + "_MPA");
CBdeleteConnection ($nodes[1] + "_MPA.u");

addAttr -ln uValue -at double  -min 0 -max 1 -dv 0 $nodes[1];
setAttr -e -keyable true ($nodes[1] + ".uValue");
addAttr -ln velocity -at double  -min -10 -max 10 -dv 0.00 $nodes[1];
setAttr -e -keyable true ($nodes[1] + ".velocity");

string $del[] = `listConnections ($nodes[1] +  ".transMinusRotatePivotX")`;
delete $del[0];
string $del[] = `listConnections ($nodes[1] +  ".transMinusRotatePivotY")`;
delete $del[0];
string $del[] = `listConnections ($nodes[1] +  ".transMinusRotatePivotZ")`;
delete $del[0];
disconnectAttr ($nodes[1] + "_MPA.message")  ($nodes[1] +  ".specifiedManipLocation");

connectAttr ($nodes[1] + "_MPA.allCoordinates") ($nodes[1] +  ".translate");

/*
shadingNode -asUtility multiplyDivide -name ($nodes[1] + "_MUL");
setAttr($nodes[1] + "_MUL.operation") 2;
connectAttr ($nodes[1] + ".uValue") ($nodes[1] + "_MUL.input1X");
connectAttr ($nodes[1] + ".velocity") ($nodes[1] + "_MUL.input2X");
connectAttr($nodes[1] + "_MUL.outputX") ($nodes[1] + "_MPA.uValue");
*/

//expression -s "if(pSphere1.velocity == 0)\n{\npSphere1_MPA.uValue = pSphere1.uValue;\n}\nelse\n{\n\tif(pSphere1.velocity > 0)\n\t{\n\tpSphere1_MPA.uValue = pSphere1.uValue + ((1 - pSphere1.uValue) * ((pSphere1.velocity)/10));\n\t}\n\n\tif(pSphere1.velocity < 0)\n\t{\n\tpSphere1_MPA.uValue = pSphere1.uValue + (pSphere1.uValue * ((pSphere1.velocity)/10));\n\t}\n}"  -o "" -n "pSphere1_EXP" -ae 1 -uc all ;
//expression -s ( "if(" + ($nodes[1] + ".velocity == 0)\n{\n") +  ($nodes[1] + "_MPA.uValue = ") + ($nodes[1] + ".uValue;\n}\nelse\n{\n\tif(") + ($nodes[1] + ".velocity > 0)\n\t{\n\t") + ($nodes[1] + "_MPA.uValue = ") + ($nodes[1] + ".uValue + ((1 - ") + ($nodes[1] + ".uValue) * ((") + ($nodes[1] + ".velocity)/10));\n\t}\n\n\tif(") + ($nodes[1] +  ".velocity < 0)\n\t{\n\t") + ($nodes[1] + "_MPA.uValue = ") + ($nodes[1] +  ".uValue + (") + ($nodes[1] + ".uValue * ((") + ($nodes[1] +  ".velocity)/10));\n\t}\n}")  -o "" -n ($nodes[1] + "_EXP") ) -ae 1 -uc all ;
//expression -s ( "if((" + $nodes[1] + ".velocity)*(" + $nodes[1] +  ".uValue) == 0)\n\{\n" + $nodes[1] + "_MPA.uValue = " + $nodes[1] +  ".uValue;\n}\nelse\n\{\n\tif(" + $nodes[1] + ".velocity > 0)\n\t\{\n\t" +  $nodes[1] + "_MPA.uValue = " + $nodes[1] + ".uValue + ((1 - " + $nodes[1] + ".uValue) * ((" + $nodes[1] + ".velocity)/10));\n\t}\n\n\tif(" +  $nodes[1] + ".velocity < 0)\n\t\{\n\t" + $nodes[1] + "_MPA.uValue = " +  $nodes[1] + ".uValue + (" + $nodes[1] + ".uValue * ((" + $nodes[1] +  ".velocity)/10));\n\t}\n}")  -o "" -n ($nodes[1] + "_EXP") -ae 1 -uc all ;
//expression -s  ($nodes[1] + "_MPA.uValue = " + $nodes[1] + ".uValue +  ((" + $nodes[1] + ".velocity)/10);") -o "" -n ($nodes[1] + "_EXP") -ae 1 -uc all ;
expression -s  ("if((" + $nodes[1] + ".velocity)*(" + $nodes[1] +  ".uValue) == 0)\n\{\n" + $nodes[1] + "_MPA.uValue = " + $nodes[1] +  ".uValue;\n}\nelse\n\{\n" + $nodes[1] + "_MPA.uValue = " + $nodes[1] + ".uValue + ((" + $nodes[1] + ".velocity)/10);\n\}") -o "" -n ($nodes[1] +  "_EXP") -ae 1 -uc all ;
}

//===


global proc loadWeightMap(string $attr,  string $weightMap)
{
    string $ctx = currentCtx();
    setToolTo selectSuperContext;
    ArtPaintAttrTool;
    artAttrPaintOperation artAttrCtx Replace;
    artSetToolAndSelectAttr  artAttrCtx  ($attr);
    artAttrCtx  -e -importfileload $weightMap   `currentCtx`;
    setToolTo $ctx;
}

//===

global proc saveWeightMap(string $attr,  string $weightMap)
{
    string $ctx = currentCtx();
    setToolTo selectSuperContext;
    ArtPaintAttrTool;
    artSetToolAndSelectAttr  artAttrCtx  ($attr);
    artAttrCtx  -e -exportfilesave $weightMap `currentCtx`;
    setToolTo $ctx;
}


global proc storeDefaults()
{
    //==== global variables

    //=== names

    global string $rig_pref;
    global string $rig_name;
    global string $rig_prefix;
    global string $prefixL;
    global string $prefixR;
global string $rig_dir;

    //=== modules

    global int $hires;
    global int $normal_spines;
    global int $long_spines;
    global int $long_necks;
    global int $short_necks;
    global int $heads;
    global int $human_arms;
    global int $human_legs;
    global int $quadr_legs;
    global int $human_feet;;
    global int $one_finger_hands;
    global int $two_finger_hands;
    global int $three_finger_hands;
    global int $four_finger_hands;
    global int $five_finger_hands;
    global int $bird_wings;
    global int $bat_wings;
    global int $tentacles;
    global int $tails;
    global int $fins;
    global int $flippers;
    global int $doStretch;
global int $doToes;
global int $hiresSpine;
global int $hiresReptSpine;
global int $hiresHead;
global int $hiresQuadrLeg;
global int $hiresShortNeck;
global int $hiresLongNeck;
global int $hiresArm;
global int $hiresTentacle;
global int $hiresLeg;
global int $hiresFlipper;
global int $hiresFin;
global int $hires1FingHand;
global int $hiresBirdWing;
global int $hires2FingHand;
global int $hiresBatWing;
global int $hires3FingHand;
global int $hiresTail;
global int $hires4FingHand;
global int $hires5FingHand;

    //==== end global variables

    getGlobVar ;

    string $pose[];
    string $stringAttr;
    string $fileName = ("/tmp/" + $rig_prefix + $rig_name +  "_defaults.mel");
    $fileId = `fopen $fileName "w"`;
   
    if(`objExists ($rig_prefix + $rig_name + ".defaults")`)
    {
    }
    else
    {
    addAttr -dt "string" -ln defaults ($rig_prefix + $rig_name);
    }
   
    string $controls[] = `ls ($rig_prefix + "*ctrl") ($rig_prefix +  "*PIV")`;
    select $controls;
    $pose = `getPose`;
   
    for($i = 0; $i < size($controls);$i++)
    {
    fprint $fileId ($pose[$i] + "\n");
    $stringAttr += $pose[$i];
    }
    fclose $fileId;
   
    if(size($stringAttr) > 0)
    {
    setAttr -typ "string" ($rig_prefix + $rig_name + ".defaults")
$stringAttr;
    }

    select -cl;

}

global proc setDefaults()
{
    //==== global variables

    //=== names

    global string $rig_pref;
    global string $rig_name;
    global string $rig_prefix;
    global string $prefixL;
    global string $prefixR;
global string $rig_dir;

    //=== modules

    global int $hires;
    global int $normal_spines;
    global int $long_spines;
    global int $long_necks;
    global int $short_necks;
    global int $heads;
    global int $human_arms;
    global int $human_legs;
    global int $quadr_legs;
    global int $human_feet;;
    global int $one_finger_hands;
    global int $two_finger_hands;
    global int $three_finger_hands;
    global int $four_finger_hands;
    global int $five_finger_hands;
    global int $bird_wings;
    global int $bat_wings;
    global int $tentacles;
    global int $tails;
    global int $fins;
    global int $flippers;
    global int $doStretch;
global int $doToes;
global int $hiresSpine;
global int $hiresReptSpine;
global int $hiresHead;
global int $hiresQuadrLeg;
global int $hiresShortNeck;
global int $hiresLongNeck;
global int $hiresArm;
global int $hiresTentacle;
global int $hiresLeg;
global int $hiresFlipper;
global int $hiresFin;
global int $hires1FingHand;
global int $hiresBirdWing;
global int $hires2FingHand;
global int $hiresBatWing;
global int $hires3FingHand;
global int $hiresTail;
global int $hires4FingHand;
global int $hires5FingHand;

    //==== end global variables

    getGlobVar ;

    string $pose;
    string $buff[];
   
    if(`objExists ($rig_prefix + $rig_name + ".defaults")`)
    {
        $pose = `getAttr ($rig_prefix + $rig_name + ".defaults")`;
        $numTokens = `tokenize $pose ";" $buff`;
       
        for($i = 0; $i<size($buff);$i++)
        {
        eval $buff[$i];
        print ($buff[$i] + "\n");
        }

    }

}

global proc float[] rigGetClosestPoint(string $nurbs, string $obj){

    float $pt[]  = `xform -q -ws -t $obj`;
    string $cps = `createNode closestPointOnSurface`;
    connectAttr ($nurbs + ".worldSpace") ($cps + ".inputSurface");
    setAttr ($cps + ".inPosition") $pt[0] $pt[1] $pt[2];
    float $p[]  =  `getAttr ($cps  + ".position")`;
    delete $cps;
   
    return $p;
}

global proc die_LL_die()
{
    global string $gMainProgressBar;
    string $fuckers[] = `ls -type lightLinker`;

    evalDeferred("progressBar -edit -endProgress " + $gMainProgressBar);

    for ( $bastard in $fuckers ) {
       
        int $size = `getAttr -size ($bastard+".link")`;
       
        if ( $size > 0 ) {
       
            //string $go = `confirmDialog -title "DIE LightLinker DIE !!" -message ("There are "+$size+" connections on "+$bastard+" !") -button "Die !" -button "Cancel" -defaultButton "Die !" -cancelButton "No" -dismissString "No"`;

            //if ( $go == "Die !" ) {
                progressBar -edit
                        -beginProgress
                        -isInterruptable false
                        -status "removing link ..."
                        -maxValue $size
                        $gMainProgressBar;
                int $i;
                for ($i = 0; $i<=$size; $i++) {
                    progressBar -edit -step 1 -status ("removing link "+$i+"...") $gMainProgressBar;
                    removeMultiInstance -break 1 ($bastard+".link["+$i+"]");
                //}
                progressBar -edit -endProgress $gMainProgressBar;
            }
        }
    }
    refresh;
}


global proc store_pose(string $node, string $pose)
{

string $sel[] = `ls -sl`;

string $prefix;
string $roots[];
string $root;
string $ctrlS[];


if(size($sel)>0)
{
$prefix = `substring $sel[0] 1 4`;
$roots = `ls ($prefix+"*ROOT*")`;
$root = $roots[0];
$ctrlS = `ls -sl`;
}
else
{
$ctrlS = `ls "*ctrl" "*PIV" $root`;
}
   
    select $ctrlS;
   
string $poseAttr[] = `fxGetPose 0`;
string $stringAttr;

    for($i = 0;$i<size($poseAttr);$i++)
    {
    $stringAttr += $poseAttr[$i];
    }

    if(`objExists ($node + "." + $pose)`)
    {
    setAttr -type "string" ($node + "." + $pose) $stringAttr;
    }
    else
    {
    addAttr -ln $pose -dt "string" $node;
    setAttr -type "string" ($node + "." + $pose) $stringAttr;
    }
   
select $sel;

}


global proc store_simple_pose(string $node)
{

string $sel[] = `ls -sl`;
string $pose = "pose";

    //select -cl;
   
string $poseAttr[] = `getPose`;
string $stringAttr;

    for($i = 0;$i<size($poseAttr);$i++)
    {
    $stringAttr += $poseAttr[$i];
    }

    if(`objExists ($node + "." + $pose)`)
    {
    setAttr -type "string" ($node + "." + $pose) $stringAttr;
    }
    else
    {
    addAttr -ln $pose -dt "string" $node;
    setAttr -type "string" ($node + "." + $pose) $stringAttr;
    }
   
select $sel;

}



global proc pose(string $node, string $pose)
{
string $source = `getAttr ($node + "." + $pose)`;
eval $source;
}


global proc bind_pose()
{

string $sel[] = `ls -sl`;
    if(`size($sel)` > 0)
    {
    string $root = `get_creature_root`;
        if(`objExists ($root + ".bind_pose")`)
        {
        pose $root bind_pose;
        }
    }
    else
    {
    print "SELECT A NODE";
    }
}

global proc cleanAttr()
{
string $list[] = `ls "*PIV" "*ctrl" "*ROOT" "*JNT"`;
string $attr[];
string $conn[];
string $trans[] = {"rotate", "translate", "scale"};

for($i = 0;$i<size($list);$i++)
{
$attr = `listAttr -keyable $list[$i]`;
$attr = stringArrayCatenate($attr, $trans);

    for($a = 0;$a<size($attr);$a++)
    {
    $conn = `listConnections -d 0 ($list[$i] + "." + $attr[$a])`;

        if(size($conn) > 0)
        {
            if($attr[$a] == "rotate"||$attr[$a] == "translate"||$attr[$a] == "scale")
            {
             catchQuiet(`setAttr -keyable false ($list[$i] + "." + $attr[$a] + "X")`);
             catchQuiet(`setAttr -keyable false ($list[$i] + "." + $attr[$a] + "Y")`);
             catchQuiet(`setAttr -keyable false ($list[$i] + "." + $attr[$a] + "Z")`);
            }
        setAttr -keyable false ($list[$i] + "." + $attr[$a]);
        }
   
    }
}

}


//=== fsGetSel

global proc string[] fsGetSel( )
{

string $topNode = `get_creature_root`;
string $prefix = `getAttr ($topNode + ".prefix")`;

string $list[] = `ls -sl`;
string $item;
string $newItem[];
string $print[];
int $nb = 1;
string $firstLine = "string $topNode = `get_creature_root`; string $prefix = `getAttr ($topNode + \".prefix\")`; select ";

    for($item in $list)
    {       

    $print[0] = $firstLine;

    select $item;
    $newItem = `strip_prefix 0`;
    string $obj =     $newItem[0];
                   
    string $line = ("($prefix + \"_\" + \"" + $obj + "\"\) ");
    $print[$nb++] = $line;
    }

return $print;
}

//=== store_sel

global proc store_sel(string $node, string $pose)
{

string $sel[] = `ls -sl`;
string $poseAttr[] = `fsGetSel`;
string $stringAttr;

    for($i = 0;$i<size($poseAttr);$i++)
    {
    $stringAttr += $poseAttr[$i];
    }

    if(`objExists ($node + "." + $pose)`)
    {
    setAttr -type "string" ($node + "." + $pose) $stringAttr;
    }
    else
    {
    addAttr -ln $pose -dt "string" $node;
    setAttr -type "string" ($node + "." + $pose) $stringAttr;
    }
   
select $sel;

}

global proc removeMultipleLightLinkers()
{

    $list=`ls -type lightLinker`;
    for($l in $list)
    {
        if(!`connectionInfo -isSource ($l+".message")`){
            connectAttr -na ($l+".message") lightList1.linkNodes;
            print ("\nprocessing "+$l);
            }

    }

}


global proc rename_chain(string $name)
{

string $topNode[] = `ls -sl`;

    if(size($topNode) == 1)
    {
   
    string $allchildren[] = `listRelatives -ad $topNode[0]`;
    string $children[];
    $HowMany = size($allchildren);
    select $topNode[0];
   
        for($i = 0; $i<$HowMany;$i++)
        {
        string $ch[] = `pickWalk -d down`;
        $children[size($children)] = $ch[0];
        }
   
    //=== renaming
   
    rename $topNode[0] ($name + "_root_JNT");
   
        for($i = 0; $i<size($children);$i++)
        {
   
            if($i == (size($children)-1))
            {
            rename $children[$i] ($name + "_end_JNT");
            }
            else
            {
            rename $children[$i] ($name + "_" + ($i + 1) + "_JNT");
            }
        }
    select ($name + "_root_JNT");
    }
    else
    {
    print "select the root of the chain, then type rename_chain NAME";
    }

}

global proc string[] ikSplineChain(string $name)
{
string $topNode[] = `ls -sl`;
string $allchildren[] = `listRelatives -ad $topNode[0]`;
string $children[];
float $pos[] = `xform -q -a -ws -t $topNode[0]`;
string $command = ("curve -d 2 -name " + $name + "_CRV -p " + $pos[0] +  " " + $pos[1] + " " + $pos[2]);
$HowMany = size($allchildren);
select $topNode[0];

    for($i = 0; $i<$HowMany;$i++)
    {
    string $ch[] = `pickWalk -d down`;
    float $p[] = `xform -q -a -ws -t $ch[0]`;
    string $point = (" -p " + $p[0] + " " + $p[1] + " " + $p[2]);
    $command += $point;
    $children[size($children)] = $ch[0];
    }

//=== renaming

rename $topNode[0] ($name + "_root_JNT");

    for($i = 0; $i<size($children);$i++)
    {

        if($i == (size($children)-1))
        {
        rename $children[$i] ($name + "_end_JNT");
        }
        else
        {
        rename $children[$i] ($name + "_" + ($i + 1) + "_JNT");
        }
    }

//=== create curve

eval $command;

select ($name + "_root_JNT") ($name + "_end_JNT") ($name + "_CRV");
string $eff[] = `ikHandle -sol ikSplineSolver -ccv false -pcv false`;
rename $eff[0] ($name + "_IKH");
rename $eff[1] ($name + "_EFF");

select ($name + "_CRV") ($name + "_root_JNT");
pathAnimation -fractionMode true -follow false -startTimeU
`playbackOptions -query -minTime` -endTimeU  `playbackOptions -query -maxTime`;
select ($name + "_root_JNT");
string $mpa[] = `listConnections -type motionPath`;
rename $mpa[0] ($name + "_MPA");
CBdeleteConnection ($name + "_MPA.u");

//=== stretchy

addAttr -ln stretch -at double  -min 0 -max 1 -dv 0 ($name + "_CRV");
setAttr -e -keyable true ($name + "_CRV.stretch");

$num = `getAttr ($name + "_CRV.spans")`;
$arcL = `arcLengthDimension ($name + "_CRV.u[" + $num + "]")`;
float $length = `getAttr ($arcL + ".arcLength")`;
shadingNode -name ($name + "_MUL") -asUtility multiplyDivide;
setAttr ($name + "_MUL.operation") 2;
connectAttr -f ($arcL + ".arcLength") ($name + "_MUL.input1X");
setAttr ($name + "_MUL.input2X") $length;

shadingNode -name ($name + "_ADD") -asUtility plusMinusAverage;
connectAttr -f ($name + "_MUL.outputX") ($name + "_ADD.input1D[0]");
setAttr ($name + "_ADD.input1D[1]") 1;
setAttr ($name + "_ADD.operation") 2;

shadingNode -name ($name + "_xtra_MUL") -asUtility multiplyDivide;
connectAttr -f ($name + "_CRV.stretch") ($name + "_xtra_MUL.input1X");
connectAttr -f ($name + "_ADD.output1D") ($name + "_xtra_MUL.input2X");

shadingNode -name ($name + "_xtra_ADD") -asUtility plusMinusAverage;
connectAttr -f ($name + "_xtra_MUL.outputX") ($name +  "_xtra_ADD.input1D[0]");
setAttr ($name + "_xtra_ADD.input1D[1]") 1;
connectAttr -f ($name + "_xtra_ADD.output1D") ($name + "_root_JNT.sx");
connectAttr -f ($name + "_xtra_ADD.output1D") ($name + "_root_JNT.sy");
connectAttr -f ($name + "_xtra_ADD.output1D") ($name + "_root_JNT.sz");

//=== end stretchy

//=== final stuff

string $nodes[] = {($name + "_root_JNT"), ($name + "_CRV")};
select ($name + "_root_JNT");
return $nodes;
}

//=====================================================================================
//=====================================================================================
//=====================================================================================

global proc string[] bridge(string $first, string $last, string $name, int $num)
{

spaceLocator -name ($name+"_first_LOC");
spaceLocator -name ($name+"_last_LOC");
spaceLocator -name ($name+"_parent_last_LOC");
parent ($name+"_last_LOC") ($name+"_parent_last_LOC");

select $first ($name+"_first_LOC"); delete `pointConstraint`;
parent ($name+"_first_LOC") $last;
setAttr ($name+"_first_LOC.r") 0 0 0;
parent ($name+"_first_LOC") $first;

select $last ($name+"_parent_last_LOC"); delete `pointConstraint`;
parent ($name+"_parent_last_LOC") $last;
setAttr ($name+"_parent_last_LOC.r") 0 0 0;
parent ($name+"_parent_last_LOC") $first;

select $last ($name+"_last_LOC"); orientConstraint -mo;

//=== joints

string $joints[];

    for($i = 1;$i<($num+1);$i++)
    {
    select $first;
    joint -name ($name + "_" + $i + "_ENV");
    parent ($name + "_" + $i + "_ENV") $last;
    setAttr ($name + "_" + $i + "_ENV.r") 0 0 0;
    setAttr ($name + "_" + $i + "_ENV.t") 0 0 0;
    setAttr ($name + "_" + $i + "_ENV.rotateOrder") 3;
    parent ($name + "_" + $i + "_ENV") $first;
    $joints[size($joints)] = ($name + "_" + $i + "_ENV");
    }


setAttr ($name+"_first_LOC.rotateOrder") 3;
setAttr ($name+"_parent_last_LOC.rotateOrder") 3;
setAttr ($name+"_last_LOC.rotateOrder") 3;

select ($name+"_first_LOC") $joints ($name+"_last_LOC");
averagePointConstraint;
select ($name+"_first_LOC") $joints ($name+"_last_LOC");
averageOrient;

    
    for($item in $joints)

return $joints;
}

//==================================================================================================
//==================================================================================================
//==================================================================================================

global proc clean_scene()
{
string $allNodes[] = `ls`;
string $allTrans[] = `ls -type transform`;
string $noTrans[] = stringArrayRemove($allTrans, $allNodes);

string $shapes[] = `ls "*Shape*"`;
string $dags[] = stringArrayRemove($shapes, $noTrans);

for($item in $dags)
		if(size(`listConnections $item`)==0)
		{
		print ("\ndeleting "+$item);
		catch(`delete $item`);
		}
}

global proc splineIk(string $name, int $num)
{

string $curve[] = `ls -sl`;

    if(size($curve) < 1)
    {
    print "select a curve, you idiot";
    return;
    }
    else
    {
    rename `arcLengthDimension ($curve[0] + ".u[1000000]")` ($name +  "_DST");
    float $length = `getAttr ($name + "_DST.arcLength")`;
    delete ($name + "_DST");
    float $trans = $length/$num;

        for($i=0;$i<$num;$i++)
        {
        joint -name ($name + "_" + $i + "_JNT") -p ($trans*$i) 0 0;
        }
   
    select ($name + "_0_JNT") ($name + "_" + ($num - 1) + "_JNT") $curve[0] ;
    string $ikh[] = `ikHandle -sol ikSplineSolver -ccv false -roc false -pcv false`;
    rename $ikh[0] ($name + "_IKH");
    }

}


global proc switchNodeState()
{
string $list[] = `ls -sl`;
string $item;
int $state;

    for($item in $list)
    {
    $state = `getAttr ($item + ".nodeState")`;
        if($state == 0)
        {
        setAttr ($item + ".nodeState") 1;
        }
       
        if($state == 1)
        {
        setAttr ($item + ".nodeState") 0;
        }

    }
}


global proc string[] autoPullCage(string $joint, float $ratio, float $length)
{

string $list[] = `ls -sl`;
string $children[] = `listRelatives -type joint -ad $joint`;
string $return[];


if(size($children)>0)
{
    for($i=0;$i<size($children);$i++)
    {
        if($i==0)
        {
        string $furtherChildren[] = `listRelatives -type joint -c $joint`;
        select $joint $furtherChildren[0];
        pullCage $joint $ratio $length;
        parent -w ($joint+"_PUL"); delete ($joint+"_ENV");
        $return[size($return)] = ($joint+"_PUL");
        }
        else
        {
        string $furtherChildren[] = `listRelatives -type joint -c $children[$i]`;
        select $children[$i] $furtherChildren[0];
        pullCage $children[$i] $ratio $length;
        parent -w ($children[$i]+"_PUL"); delete ($children[$i]+"_ENV");
        $return[size($return)] = ($children[$i]+"_PUL");
        }
   
    }
}

select $list;
return $return;

}

global proc cleanRig(string $pr)
{


string $list[] = `ls "motionPath*" "addDouble*" "transformGeo*" "tweak*" "skinCluster*" "r_ankle*" "l_ankle*" "loft*" "file*" "fth*" "place*" "poly*" "wrap*" "pipp*"`;
string $item;
print "\n";

    for($item in $list)
    {
    print ("renaming " + $item + " into " + $pr + "_" + $item + "\n");
     catchQuiet(`rename $item ($pr + "_" + $item)`);
    }

string $list[] = `ls "*rigidSolver" "*sceneConfigurationScriptNode" "CDN*" "*ugget*"`;
string $item;

    for($item in $list)
    {
        if(`objExists $item`)
        {
        print ("deleting " + $item + "\n");
         catchQuiet(`delete $item`);
        }
    }

string $unk[] = `ls -type unknown`;

if(`size($unk)` > 0)
{
 catchQuiet(`delete $unk`);
}

}



//=== select curve, then: dynCurve name
//=== it returns: baseCurve dynCurve Follicle HairSystem;

/*

global proc string[] dynCurve(string $name)
{

string $nodes[];
string $crv[] = `ls -sl`;
makeCurvesDynamicHairs;
string $hsysSh[] = `getSelectedHairSystems`;
string $hsys[] = `listRelatives -p $hsysSh[0]`;
rename $hsys[0] ($name + "_HAS");
string $foll[] = `listConnections ($name + "_HASShape.outputHair")`;
rename $foll[0] ($name + "_FOL");

string $outCrv[] = `listRelatives -ad -typ transform ($hsys[0] +  "OutputCurves")`;
rename $outCrv[0] ($name + "_dyn_CRV");
rename $crv[0] ($name + "_CRV");
select ($name + "_FOL");
string $pip[] = `listRelatives -ad -typ shape`;

string $grp1[] = `listRelatives -p ($name + "_FOL")`;
string $grp2[] = `listRelatives -p ($name + "_dyn_CRV")`;

//=== reordering

$nodes = {($name + "_CRV"), ($name + "_dyn_CRV"), ($name + "_FOL"), ($name + "_HAS")};
select $nodes;
group -name ($name + "_crvs_GRP");


delete $grp1 $grp2;
setAttr ($name + "_CRV.v") 0;
select -cl;

return $nodes;

}


*/


//=== merge hair systems
//=== usage: select hair systems, then: mergeHS NAME (of the new hair system) 1 (based on selection)/ or 0 (just all the hair systems in the scene)


global proc string mergeHS(string $namehs, int $selection)
{
string $name = ($namehs + "_HAS");
string $hs[];

if($selection == 0)
{
$hs =  `ls -type hairSystem`;
}
else
{
$hs =  `ls -sl`;
}

string $follicles[];

cycleCheck -e off;

for($i = 0;$i<size($hs);$i++)
{
string $tmp[] = `listConnections ($hs[$i] + ".outputHair")`;
$follicles[size($follicles)] = $tmp[0];
}

rename $hs[0] $name;

for($i = 1;$i<size($follicles);$i++)
{
connectAttr -f ($name + ".outputHair[" + $i + "]") ($follicles[$i] +  ".currentPosition");
connectAttr -f ($follicles[$i] + ".outHair") ($name + ".inputHair[" +  $i + "]");
}

for($i = 1;$i<size($hs);$i++)
{
delete $hs[$i];
}

cycleCheck -e on;

return $name;

}


global proc bindPose()
{

string $sel[] = `ls -sl`;

    if(`size($sel)` > 0)
    {
    string $root = `get_creature_root`;
        if(`objExists ($root + ".bind_pose")`)
        {
        string $source = `getAttr ($root + ".bind_pose")`;
        eval $source;
        }
    }
    else
    {
    print "SELECT A NODE";
    }


}

global proc doPose(string $name)
{

string $sel[] = `ls -sl`;

    if(`size($sel)` > 0)
    {
    string $root = `get_creature_root`;
        if(`objExists ($root + "."+$name)`)
        {
        string $source = `getAttr ($root + "."+$name)`;
        eval $source;
        }
    }
    else
    {
    print "SELECT A NODE";
    }


}

global proc doPosePrefix(string $prefix, string $name)
{
string $all[] = `ls ($prefix + "*ROOT")`;
string $root = $all[0];

    if(`objExists ($root + "."+$name)`)
    {
    string $source = `getAttr ($root + "."+$name)`;
    eval $source;
    }

}

// Daxx Parent LOC


global proc parent_loc()

{
string $sel[] = `ls -sl`;
int $selsize = size($sel);
string $SUFF;
string $oldParent[];

if ($selsize == 0) {
           error "No Objects selected";
            }



for ($i=0;$i<$selsize;$i++)
    {
    string $obj= $sel[$i];
   
        $oldParent = `listRelatives -p $obj`;
   
        if(`gmatch $obj "*_LOC"` == 1)
        {
        $SUFF = "0_LOC";
        }
        else
        {
        $SUFF = "LOC";
        }
   
    
    string $baseobj;
    int $num;
    
    if(`gmatch $obj "*_*"`)
    {
    string $container[];
    tokenize($obj, "_", $container);
    $num = `size($container[size($container)-1])`;
    }
    
    $baseobj = `substring $obj 1 (size($obj)-$num)`;
    
    string $locname = ($baseobj+$SUFF);
    spaceLocator -n ("TMP_"+$locname) ;
    select $obj ("TMP_"+$locname);
    delete `parentConstraint`;
    //select ("TMP_"+$locname);
    //makeIdentity -apply true -t 1 -r 1 -s 1 -n 0;
    parent $obj ("TMP_"+$locname) ;
    rename ("TMP_"+$locname) $locname;
    if(`objExists $oldParent[0]`)
    parent $locname $oldParent[0];
    }
}

// end Daxx Parent LOC


global proc cleanit()
{
die_LL_die;
select -cl; fcSearchReplace "__" "_";
   
    if(`objExists "*fcMayaEnvNode*"`)
    {
    delete "*fcMayaEnvNode*";
    }
}


//=== blend shapes
//=== select target shapes

global proc blend_shapes(string $obj, string $control, string $list[])
{
    for($item in $list)
    {
    select $item $obj;
    string $command = ("blendShapeDeleteTarget \"blendShape -name "+$item + "_SHP -foc  -tc 1\"");
    eval($command);
    addAttr -ln $item -at double  -min 0 -max 1 -dv 0 -k 1 $control;
    connectAttr ($control + "." + $item) ($item + "_SHP." + $item);
    }
}

//===================================
//===================================
//===================================

global proc int getPlugIndex(string $attribute){

    string $buf[];
    if(`tokenize $attribute "[" $buf` > 0) {
        tokenize $buf[1] "]" $buf;
        return (int) $buf[0];
    }
    return -1;
}


//===================================
//===================================
//===================================

global proc string[] get_ctl(string $name, int $rot, float $scale)
{
string $ls[] = `ls -sl`;
select -cl;
string $ctls[];

file -import -type "mayaAscii"  -pr "/hosts/guildford/user_data/ARCHIVE/FELIX/RIG/CNTRLS/cntrl.ma";
select -r ctrlShape.cv[0:16] ;
scale -r -p 0cm 0cm 0cm $scale $scale $scale ;

if($rot < 1)
{
delete rot_ctrl_LOC;
}

select $ls[0] ctrl_LOC;
delete `pointConstraint`;
delete `orientConstraint`;
select ctrl $ls[0];
pointConstraint -name ($name + "_POC");
select ctrl $ls[0];
orientConstraint -name ($name + "_ORC");


string $list[] = `sets -q -no SEL`;
string $item;
for($item in $list)
{
rename $item ($name + "_" + $item);
}

delete SEL;

select $ls;
$ctls = {($name + "_ctrl_LOC"), ($name + "_ctrl"), ($name + "_UPV")};
return $ctls;
}

//===================================
//===================================
//===================================


global proc switch_skin()
{
string $list[] = `ls -type fcEnvDeform`;
string $item;

for($item in $list)
{


    if(`getAttr ($item + ".nodeState")` == 1)
    {
    setAttr ($item + ".nodeState") 0;
    }
    else
    {
    setAttr ($item + ".nodeState") 1;
    }
}

}
   
//==========================
//==========================
//==========================


global proc mirror_nodes()
{
string $nodes[] = `ls -sl`;
string $originalSide;
string $copySide;
string $originalName;
string $copyName;
string $restOfTheName;
string $prefix;


for($i = 0;$i<size($nodes);$i++)
{

string $pippo[];
$numTokens = `tokenize $nodes[$i] "_" $pippo`;

    if(`gmatch $pippo[0] "R"` == 1)
    {
    $originalSide = "R";
    $copySide = "L";
    $restOfTheName = substring($nodes[$i],3,size($nodes[$i]));
    $copyName = ($copySide + "_" + $restOfTheName);
print "\n\nthis node is an R name with no prefix\n\n";
    }

    if(`gmatch $pippo[1] "R"` == 1)
    {
    $originalSide = "R";
    $copySide = "L";
    $restOfTheName = substring($nodes[$i],8,size($nodes[$i]));
    $prefix = substring($nodes[$i],1,5);
    $copyName = ($prefix + $copySide + "_" + $restOfTheName);
print "\n\nthis node is an R name WITH prefix\n\n";
    }

    if(`gmatch $pippo[0] "L"` == 1)
    {
    $originalSide = "L";
    $copySide = "R";
    $restOfTheName = substring($nodes[$i],3,size($nodes[$i]));
    $copyName = ($copySide + "_" + $restOfTheName);
print "\n\nthis node is an L name with no prefix\n\n";
    }

    if(`gmatch $pippo[1] "L"` == 1)
    {
    $originalSide = "L";
    $copySide = "R";
    $restOfTheName = substring($nodes[$i],8,size($nodes[$i]));
    $prefix = substring($nodes[$i],1,5);
    $copyName = ($prefix + $copySide + "_" + $restOfTheName);
print "\n\nthis node is an L name WITH prefix\n\n";
    }
   

string $parent[] = `listRelatives -p $nodes[$i]`;
string $parentCopy[];

    if(size($parent) > 0)
    {
    parent -w $nodes[$i];
    }

float $trans[] = `getAttr ($nodes[$i] + ".t")`;
float $rot[] = `getAttr ($nodes[$i] + ".r")`;
float $scale[] = `getAttr ($nodes[$i] + ".s")`;

    if(size($parent) > 0)
    {
    parent $nodes[$i] $parent[0];
    }

    if(`objExists $copyName`)
    {

        $parentCopy = `listRelatives -p $copyName`;
       
        if(size($parentCopy) > 0)
        {
        parent -w $copyName;
        }
       
     catchQuiet(`setAttr ($copyName + ".t") $trans[0] $trans[1] ($trans[2]*-1)`)
;
     catchQuiet(`setAttr ($copyName + ".r") ($rot[0]*-1) ($rot[1]*-1) $rot[2]`)
;
     catchQuiet(`setAttr ($copyName + ".s") $scale[0] $scale[1] $scale[2]`) ;
   
        if(size($parentCopy) > 0)
        {
        parent $copyName $parentCopy[0];
        }
   
    }


}
select $nodes;

}


//==================================
//==================================
//==================================
//==================================

   
global proc reset_muscles()
{

string $list[] = `ls "*MSC" "*MSC?" `;

    for($i = 0; $i < size($list);$i++)
    {
        if(`getAttr ($list[$i] + ".bulge")` == 1)
        {
        setAttr  ($list[$i] + ".restLength") `getAttr ($list[$i] +  ".arclength")`;
        setAttr ($list[$i] + ".arcLengthMax") `getAttr ($list[$i] +  ".arclength")`;
        }
    }


}

//==================================
//==================================
//==================================
//==================================

global proc copy_msl_locs(string $path)
{

string $pose[];
string $tmp[];

select "*msl_LOC";
$pose = `getPose`;
$fileName = $path;
string $stringAttr;
int $fileId;
string $result;

    if(`filetest -f  $fileName`)
    {

    $result = `confirmDialog -title ($fileName + " exists") -message "do you want to overwrite it?" -button "Yes" -button "No" -defaultButton "Yes" -cancelButton "No" -dismissString "No"`;

        if(`gmatch $result "Yes"` == 1)
        {
        $fileId = `fopen $fileName "w"`;
       
            for($i = 0; $i < size($pose);$i++)
            {
            fprint $fileId ($pose[$i] + "\n");
            $stringAttr += $pose[$i];
            }
           
        fclose $fileId;
        }
   
    }
    else
    {
        $fileId = `fopen $fileName "w"`;
       
            for($i = 0; $i < size($pose);$i++)
            {
            fprint $fileId ($pose[$i] + "\n");
            $stringAttr += $pose[$i];
            }
        fclose $fileId;
    }

select -cl;

print "muscles locs copied OK";

}


//==================================
//==================================
//==================================
//==================================

global proc string[] base_muscle(string $name, int $sections, string
$start, string $end, string $parent, int $doMuscle, int $keepConstraints)
{

string $locators[];
select -cl;

spaceLocator -name ($name + "_start_0_msl_LOC");
spaceLocator -name ($name + "_end_0_msl_LOC");

spaceLocator -name ($name + "_start_msl_LOC");
spaceLocator -name ($name + "_end_msl_LOC");

select ($name + "_start_0_msl_LOC") ($name + "_start_msl_LOC");
pointConstraint -name ($name + "_start_msl_loc_POC");
scaleConstraint -name ($name + "_start_msl_loc_SCC");
select ($name + "_end_0_msl_LOC") ($name + "_end_msl_LOC");
pointConstraint -name ($name + "_end_msl_loc_POC");
scaleConstraint -name ($name + "_end_msl_loc_SCC");

parent ($name + "_start_0_msl_LOC") $start;
parent ($name + "_end_0_msl_LOC") $end;
zeroT ($name + "_start_0_msl_LOC");
zeroT ($name + "_end_0_msl_LOC");

//========================

$locators[0] = ($name + "_start_msl_LOC");

for($i = 0;$i<$sections;$i++)
{
spaceLocator -name ($name + "_" + $i + "_msl_LOC");
$locators[size($locators)] = ($name + "_" + $i + "_msl_LOC");
}

$locators[size($locators)] = ($name + "_end_msl_LOC");

if($keepConstraints < 1)
{
select $locators;
delete `averagePointConstraint`;
}
else
{
select $locators;
averagePointConstraint;
}

parent $locators $parent;

if($doMuscle > 0)
{
select $locators;
fcMusclePrimitive ($name + "_MSL") 1 5 2 1 1 1 "";
string $muscle[] = `listConnections ($name + "_MSL.message")`;
       
        if(`getAttr ($muscle[0] + ".bulge")` == 1)
        {
        setAttr  ($muscle[0] + ".restLength") `getAttr ($muscle[0] +  ".arclength")`;
        setAttr ($muscle[0] + ".arcLengthMax") `getAttr ($muscle[0] +  ".arclength")`;
        }

}

select -cl;
return $locators;

}

//==================================
//==================================
//==================================
//================================== base_muscle2 with streight parenting of locators: simpler to edit

global proc string[] base_muscle2(string $name, int $sections, string
$start, string $end, string $parent, int $doMuscle, int
$keepConstraints)
{

string $locators[];
select -cl;

spaceLocator -name ($name + "_start_0_msl_LOC");
spaceLocator -name ($name + "_end_0_msl_LOC");

spaceLocator -name ($name + "_start_msl_LOC");
spaceLocator -name ($name + "_end_msl_LOC");

select ($name + "_start_0_msl_LOC") ($name + "_start_msl_LOC");
pointConstraint -name ($name + "_start_msl_loc_POC");
scaleConstraint -name ($name + "_start_msl_loc_SCC");
select ($name + "_end_0_msl_LOC") ($name + "_end_msl_LOC");
pointConstraint -name ($name + "_end_msl_loc_POC");
scaleConstraint -name ($name + "_end_msl_loc_SCC");

delete ($name + "_start_msl_loc_POC") ($name + "_start_msl_loc_SCC")
($name + "_end_msl_loc_POC") ($name + "_end_msl_loc_SCC");

parent ($name + "_start_msl_LOC") ($name + "_start_0_msl_LOC");
parent ($name + "_end_msl_LOC") ($name + "_end_0_msl_LOC");


parent ($name + "_start_0_msl_LOC") $start;
parent ($name + "_end_0_msl_LOC") $end;
zeroT ($name + "_start_0_msl_LOC");
zeroT ($name + "_end_0_msl_LOC");

//========================

$locators[0] = ($name + "_start_msl_LOC");

for($i = 0;$i<$sections;$i++)
{
spaceLocator -name ($name + "_" + ($i+1) + "_msl_LOC");
$locators[size($locators)] = ($name + "_" + ($i+1) + "_msl_LOC");
parent ($name + "_" + ($i+1) + "_msl_LOC") $parent;
}

$locators[size($locators)] = ($name + "_end_msl_LOC");

if($keepConstraints < 1)
{
    if($sections == 1)
    {
    select ($name + "_start_msl_LOC") ($name + "_end_msl_LOC") ($name +  "_1_msl_LOC");
    delete `pointConstraint`;
    }
    else
    {
    select $locators;
    delete `averagePointConstraint`;
    }
}
else
{
select $locators;
averagePointConstraint;
}


if($doMuscle > 0)
{
select $locators;
fcMusclePrimitive ($name + "_MSL") 1 5 2 1 1 1 "";
string $muscle[] = `listConnections ($name + "_MSL.message")`;
       
        if(`getAttr ($muscle[0] + ".bulge")` == 1)
        {
        setAttr  ($muscle[0] + ".restLength") `getAttr ($muscle[0] +  ".arclength")`;
        setAttr ($muscle[0] + ".arcLengthMax") `getAttr ($muscle[0] +  ".arclength")`;
        }

}

select -cl;
return $locators;

}

//=======================================
//=======================================



//=======================================
//=======================================

// fcDrainShape
// Davide La Sala Framestore CFC
// select the shape collector then objects to drain all the shapes of all the objects secondary selected
// run "fcDrainShape"

global proc fcDrainShape ( )
{
string $list[] = `ls -sl`;
makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $list[0];
for ($i=1; $i<(size($list)); $i++)
    {
    makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $list[$i];
    string $sourceshp[] =`listRelatives -s $list[$i]`;
    for ( $item in $sourceshp)
        {
        parent -r -s $item $list[0];
        }
        delete $list[$i];
    }
}
// END fcDrainShape

//========================================
//========================================

global proc copy_ctls( string $file )
{

string $SEL[] = `ls -sl`;

   int $fileId=`fopen $file  "w"`;
   string $ctls[] = `ls "*ctrlShape"`;
   
   /*
   string $list[] = `sets -q -no allAnimControls`;

   for($item in $list)
   {
   
   int $pippo = `getAttr ($item+".overrideEnabled")`;
   string $conn[] = `listConnections ($item+".drawOverride")`;
       if(!`size($conn)`)
       {
       int $colour = `getAttr  ($item+".overrideColor")`;
        fprint $fileId ("if(` objExists "+$item+"`)\n{\n");
        fprint $fileId (" catchQuiet(`setAttr "+$item+".overrideEnabled 1`);\n");
        fprint $fileId (" catchQuiet(`setAttr "+$item+".overrideColor "+$colour+"`);\n");
        fprint $fileId ("}\n");
        }   
   }
   */
   
   for ( $o in $ctls)
   {   
    string $co[] = `listConnections -p 1 ($o+".v")`;
    string $cv[] = `ls -fl ( $o+ ".cv[*]"  )`;
    if(size($cv)>0)
    {
    fprint $fileId ("if(` objExists "+$o+"`)\n{\n");
      
   
        select $o;
           string $parent[] = `pickWalk -d up`;
        int $DIG = `getAttr ($o+".degree")`;
        int $FORM = `getAttr ($o+".form")`;
        fprint $fileId ("curve -name TMP_transform -d "+$DIG+" ");
       
               for(  $q in $cv )
               {
            float $pos[] =  `xform -q -t $q`;
            fprint $fileId ("-p "+$pos[0]+" "+ $pos[1]+" "+ $pos[2]+" ") ;
            }
   
        fprint $fileId (";\n");
        fprint $fileId ("string $shapes[] = `listRelatives -c -s TMP_transform`;\n");
        if($FORM>0)
        {
        fprint $fileId ("closeCurve -rpo 1 $shapes[0];\n");
        }
        fprint $fileId ("parent -r -s $shapes[0] "+$parent[0]+";\n");
        fprint $fileId ("delete TMP_transform;\n");
        fprint $fileId ("delete "+$o+";\n");
        fprint $fileId ("rename $shapes[0] "+$o+";\nselect -cl;\n");
        fprint $fileId ("}\n");
    }
   
   
    if(size($co)>0)
    fprint $fileId (" catchQuiet(`connectAttr "+$co[0]+" "+$o+".v`);\n");
       
   }

    fprint  $fileId "print \"CONTROLS DONE\";";
    fclose $fileId;

    select $SEL;

}

//===========================================
//===========================================



global proc setPose(string $pose)
{

string $sel[] = `ls -sl`;

    if(`size($sel)` > 0)
    {
    string $root = `get_creature_root`;
        if(`objExists ($root + "."+$pose)`)
        {
        string $source = `getAttr ($root + "."+$pose)`;
        eval $source;
        }
    }
    else
    {
    print "SELECT A NODE";
    }


}


//==============================================
//==============================================

global proc saveFcWrinkle(string $fcWrinkle, string $path)
{

string $attr[] =
{
"envelope",
"wrinkleAmplitude",
"offset",
"wrinkleFrequency",
"wrinklePhase",
"wrinklePhase",
"maxDistance",
"wrinkleProfile",
"wrinkleScale"
};

float $values[];
string $homePath = `internalVar -userPresetsDir`;

$fileName = ($path + "/" + $fcWrinkle + ".mel");

nodePreset -atr "envelope wrinkleAmplitude offset wrinkleFrequency wrinklePhase wrinklePhase maxDistance wrinkleProfile wrinkleScale" -save $fcWrinkle $fcWrinkle;

system("cp " + $homePath + "fcWrinklePreset_"+ $fcWrinkle + ".mel " +  $fileName);

}

//============================================
//============================================

global proc wrinkle_ctl(string $ctl, string $wrinkle)
{

select $wrinkle;
string $noPref[] = `strip_prefix 0`;
string $nakedName;

if(`gmatch $noPref[0] "*wrinkle"`)
{
$nakedName = substring($noPref[0], 1, (size($noPref[0])-7));
}

   
string $attr[] = {"wrinkleAmplitude", "offset", "wrinkleFrequency", "wrinklePhase", "subdivisions"};
string $animAttr[] = {($wrinkle+"Ampl"), ($wrinkle+"Offset"), ($wrinkle+"Freq"), ($wrinkle+"Phase"), ($wrinkle+"Sub")};


for($i = 0; $i<size($attr);$i++)
{
addAttr -k 1 -ln $animAttr[$i] -at double $ctl;
setAttr ($ctl+"."+$animAttr[$i]) `getAttr ($wrinkle+"."+$attr[$i])`;
connectAttr -f ($ctl+"."+$animAttr[$i]) ($wrinkle+"."+$attr[$i]);
}

setAttr ($ctl+"."+$wrinkle+"Sub") 2;

}

//============================================
//============================================

global proc string[] getAllConDef(string $node,int $returnPlug)
{
return `listConnections -p $returnPlug -type fcEnvDeform $node`;
}

//============================================
//============================================



global proc int fxImportSkinWeightMap(string $fileName, string
$cluster, string $geo)
{
string $fileType;
    if (`about -evalVersion`){
        // Because fopen and fprint are disabled in PLE,
        // importSkinWeightMap is not supported.
        warning ("importSkinWeightMap is not supported in Maya PLE.");
        return 0;
    }

    string $ftype[] = `file -q -type $fileName`;
    if ($ftype[0] != "") {
        error("File must be an exported weight map text file, i.e. \"fileName.weightMap\"");
        return 0;
    }
   
    source "artAttrSkinCallback.mel";
    source "artAttrSkinJointMenu.mel";

    // Make sure we are in Skin Paint Weight Tool.
    string $currCtx = `currentCtx`;
    artAttrSkinToolScript 4;

string $clusterNames[];
$clusterNames[0] = $cluster;

    string $artCmd = "artAttrSkinPaintCtx -query -exportfiletype `currentCtx`";
    $fileType = eval( $artCmd );

    // Get the selected skins.
   
    $fileId = fopen( $fileName, "r" );
    if ($fileId == 0) {
        error("Unable to open the file: " + $fileName);
        return 0;
    }

    int $passed = 1;

    // Find the file and directory name.
    string $buff[];
    tokenize($fileName,"/",$buff);
    string $fn = $buff[size($buff)-1];
    tokenize($fn,"\\",$buff);
    print "\"";
   
    $fn = $buff[size($buff)-1];   
    $dir = substring($fileName,1,size($fileName)-size($fn));
    tokenize($fn,".",$buff);
    $fn = $buff[0];
    $dir += $fn;

    // Read in the master file that links the joint
    // names to the map names.
    string $skinNames[];
    string $jointNames[];
    string $fileNames[];

    string $skinNamesForC[];
    $skinNamesForC[0] = $cluster;   
    int $lineCount = 0;
   
    string $nextLine = `fgetline $fileId`;
    while ( size( $nextLine ) > 0 ) {
        int $numTokens = tokenize($nextLine,$buff);
        if ($numTokens == 3) {
            $skinNames[$lineCount] = $buff[0];
            $jointNames[$lineCount] = $buff[1];
            $fileNames[$lineCount] = $buff[2];
            if (`objExists $buff[0]`) {
                string $relCluster = findRelatedSkinCluster($buff[0]);
                if ($relCluster != "") {
                    int $found = 0;
                    for ($clusterN in $clusterNames) {
                        if ($clusterN == $relCluster) {
                            $found = 1;
                            break;
                        }
                    }
                   
                    if (! $found) {
                        int $which = size($clusterNames);
                        $clusterNames[$which] = $relCluster;
                        $skinNamesForC[$which] = $buff[0];
                    }
                }
            }
            $lineCount++;
        }
        $nextLine = `fgetline $fileId`;
    }
    if ( catchQuiet(`fclose $fileId`)) {
        error("Unable to close the file: " + $fileName);
        $passed = 0;
    }

    // Import the maps for each joint.
    if ($passed) {

        int $counter;
        int $oldNormWeights[];
        //$counter = 0;
            $oldNormWeights[0] = `getAttr ($cluster+".normalizeWeights")`;
            setAttr ($cluster+".normalizeWeights") 0;
            // set all weights to zero
            //
            select $geo;
            skinPercent -prw 1.1 $cluster;
           
        // Set the paint operation to 'replace'.
        artAttrSkinPaintCtx -e -selectedattroper "absolute" `currentCtx`;

        $skinCount = 0;

        for ($counter = 0; $counter < $lineCount; $counter++) {
            string $mapFn = ($dir+"/"+$fileNames[$counter]);
            string $jt = $jointNames[$counter];
            string $skin = $skinNames[$counter];
            if (`file -q -ex $mapFn`) {
                if (`objExists $jt` && `objExists $skin`) {

                    // Make the joint a selected node.
                    string $shortName = artAttrSkinShortName($jt);
                    select -r $skin;
                    artSkinSelectInfluence( "artAttrSkinPaintCtx", $jt, $shortName );

                    // Get the cluster name.
                    $artCmd = "artAttrSkinPaintCtx -q -objattrArray  `currentCtx`";
                    string $selectedAttr = eval( $artCmd );

                    string $tmpName[];
                    tokenize( $selectedAttr, ".", $tmpName );   
                    if ( size($tmpName) < 2 )
                        continue;

                    //string $cluster = $tmpName[1];

                    print("// Importing "+$fileNames[$counter]+" to ");
                    print($skin+" for joint "+$jt+"\n");

                    // Import the attribute map now.
                    artAttrSkinPaintCtx -e -importfileload $mapFn `currentCtx`;
                    getAttr -silent ($cluster+".og[0]");
                } else {
                    if (! `objExists $jt`) {
                        print("// Skipping "+$jt+": joint does not exist.\n");
                    } else {
                        print("// Skipping "+$skin+": skin does not exist.\n");                           
                    }
                }
            } else {
                print("// Skipping "+$mapFn+": File not found.\n");
            }
        }

        $counter = 0;
           
            setAttr ($cluster+".normalizeWeights") $oldNormWeights[0];
            select $geo;
            print "\nskinPercent -normalize true ";
            print $cluster;
            print "\n";
            skinPercent -normalize true $cluster;
    }

    // Go back to the original context.
    setToolTo $currCtx;
    select -r $geo;
   
    return $passed;
}


//=================================
//=================================
//=================================

global proc changeShape(string $node, string $shape, float $scale)
{

//=== change a node's shape into another
//=== usage: changeShape NameOfTheNode TypeOfShape
//=== types:
//=== "bone"
//=== "handle"
//=== "cube"
//=== "triangle"
//=== "square"

string $sel[] = `ls -sl`;
string $type[] = `ls -st $node`;
string $baseName[];
string $shapeName[];
string $newShape;

if(`gmatch $type[1] "joint"` == 0)
{
$shapeName = `listRelatives -c -s $node`;
if(size($shapeName)>0)
delete $shapeName;
}

if(size($shapeName)>0)
{
$newShape = $shapeName[0];
}
else
{
$newShape = ($node+"Shape");
}


if(`gmatch $shape "bone"` == 1)
{
curve -name TMP_transform -d 2 -p 0 0.201452 0 -p -20.894721 0.201452 0
-p -30.457695 0.201452 0 -p -30.457695 0.201452 0 -p -30.272247
4.63056 0 -p -28.335027 5.980686 0 -p -28.44504 8.163456 0 -p -30.066954
8.700585 0 -p -31.004949 7.912242 0 -p -31.995051 7.912242 0 -p -32.933046
8.700585 0 -p -34.55496 8.163456 0 -p -34.664973 5.980686 0 -p
-32.725167 4.63056 0 -p -32.537856 -0.0028748 0 -p -32.725167 -4.649874 0 -p
-34.664973 -6 0 -p -34.55496 -8.182767 0 -p -32.933046 -8.719899 0 -p
-31.995051 -7.931553 0 -p -31.004949 -7.931553 0 -p -30.066954 -8.719899 0
-p -28.44504 -8.182767 0 -p -28.335027 -6 0 -p -30.272247 -4.649874 0
-p -30.447297 -0.195692 0 -p -30.447297 -0.195692 0 -p -20.720505
-0.195692 0 -p 0 -0.195692 0 -k 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k
8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k
20 -k 21 -k 22 -k 23 -k 24 -k 25 -k 26 -k 27 -k 27 ;
}

if(`gmatch $shape "handle"` == 1)
{
curve -name TMP_transform -d 1 -p 0 0 0 -p -28 0 0 -p -27.947246
9.51639e-06 0 -p -28.10502 0.940865 0 -p -28.532742 1.792134 0 -p -29.207899
2.467194 0 -p -30.059117 2.895108 0 -p -31 3.052446 0 -p -31.940883
2.895108 0 -p -32.792101 2.467194 0 -p -33.467258 1.792134 0 -p -33.89498
0.940865 0 -p -34.052754 9.51639e-06 0 -p -33.89498 -0.940888 0 -p
-33.467258 -1.792098 0 -p -32.792101 -2.467259 0 -p -31.940883 -2.894979 0
-p -31 -3.052754 0 -p -30.059117 -2.894979 0 -p -29.207899 -2.467259 0
-p -28.532742 -1.792098 0 -p -28.10502 -0.940888 0 -p -27.947246
9.51639e-06 0;
select -r TMP_transform.cv[0:22] ;
rotate 0 -90 0;



string $parent[] = `listRelatives -p $node`;

    if(`gmatch $type[1] "joint"` == 1)
    {
    //delete square;
    }
    else
    {
        delete `listRelatives -c -s $parent[0]`;
    }

}


if(`gmatch $shape "handle_triangle"` == 1)
{
curve -name TMP_transform -d 1 -p 0 0 0 -p -28 0 0 -p -34 3 0 -p -34 -3 0 -p -28 0 0 -k 0 -k 1 -k 2 -k 3 -k 4 ;
select -r TMP_transform.cv[0:4] ;
rotate 0 -90 0;
}

if(`gmatch $shape "triangle"` == 1)
curve -name TMP_transform -d 1 -p 3.938734 0 0 -p -2.403973 3.171354 0 -p -2.403973 -3.171354 0 -p 3.938734 0 0 -k 0 -k 1 -k 2 -k 3 ;

if(`gmatch $shape "circle"` == 1)
circle -name TMP_transform -c 0 0 0 -nr 0 0 1 -sw 360 -r 4 -d 3 -ut 0 -tol 1e-08 -s 8 -ch 1;

if(`gmatch $shape "cube"` == 1)
curve -name TMP_transform -d 1 -p -1.121712 1.121712 1.121712 -p 1.121712 1.121712 1.121712 -p 1.121712 1.121712 -1.121712 -p -1.121712 1.121712 -1.121712 -p -1.121712 -1.121712 -1.121712 -p -1.121712 -1.121712 1.121712 -p -1.121712 1.121712 1.121712 -p -1.121712 1.121712 -1.121712 -p 1.121712 1.121712 -1.121712 -p 1.121712 -1.121712 -1.121712 -p 1.121712 -1.121712 1.121712 -p 1.121712 1.121712 1.121712 -p 1.121712 -1.121712 1.121712 -p -1.121712 -1.121712 1.121712 -p -1.121712 -1.121712 -1.121712 -p 1.121712 -1.121712 -1.121712 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 ;

if(`gmatch $shape "square"` == 1)
{
curve -name TMP_transform -d 1 -p -1 0 -1 -p -1 0 1 -p 1 0 1 -p 1 0 -1 -k 0 -k 1 -k 2 -k 3 ;
closeCurve -ch 1 -ps 1 -rpo 1 -bb 0.5 -bki 0 -p 0.1 "TMP_transform";
}

if(`gmatch $shape "arrow"` == 1)
curve -name TMP_transform -d 1 -p 0 3 0 -p 0 -3 0 -p 0 -3 -14 -p 0 -7 -14 -p 0 0 -19 -p 0 7 -14 -p 0 3 -14 -p 0 3 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 ;

select -r ("TMP_transform.cv[*]");
scale -r -p 0cm 0cm 0cm $scale $scale $scale;

select $node TMP_transform;
delete `pointConstraint`; delete `orientConstraint`;

string $shapes[] = `listRelatives -c -s TMP_transform`;

parent -r -s $shapes[0] $node;
delete TMP_transform;
rename $shapes[0] $newShape;

select -cl;

}


//===============================================================
//===============================================================
//===============================================================
//===============================================================

global proc uvXfer () {

/*This is from S D Serbos code so I kept it, for some reason if you are
in a
trasformation tool during some of the procedures that follow Maya would
crash. */

    buildSelectMaskMM;
    changeToolIcon;
    if( `popupMenu -exists tempMM` ) { deleteUI tempMM; };
   

string $SOURCESelection[] = `ls -sl  -typ transform`;
string $SOURCE = $SOURCESelection[0];



    string $selected[] = `filterExpand -sm 31`;
    int $siz = `size $selected`;
    if ($siz) {
    vector $v[];
        for ($i = 0;$i<$siz;$i++) {
                float $v[] = `xform -q -ws -t $selected[$i]`;
                     $positionXtarget = $v[0];
                          $positionYtarget = $v[1];
                          $positionZtarget = $v[2];

//print("vertex "+ $i +" at position: (" + $positionXtarget + ", " +$positionYtarget + ", " + $positionZtarget + ")\n");

    float $result[] = `closestPointOnMesh -ip $positionXtarget $positionYtarget $positionZtarget -q -p -nr -u -v -f $SOURCE`;
    float $positionX, $positionY, $positionZ, $normalX, $normalY, $normalZ, $uParameter, $vParameter;
    $positionX = $result[0];
          $positionY = $result[1];
          $positionZ = $result[2];
          $normalX = $result[3];
          $normalY = $result[4];
          $normalZ = $result[5];
          $uParameter = $result[6];
          $vParameter = $result[7];

//     print("Here's the resultant position: (" + $positionX + ", " +$positionY + ", " + $positionZ + ")\n");
//     print("Here's the resultant UV: (" + $uParameter + ", " +  $vParameter + ")\n");


    string $vtx2map[];                   
     $vtx2map =`polyListComponentConversion -tuv $selected[$i]`;
     select -r $vtx2map;                   
     string $therealUVs[]=`filterExpand -ex true -sm 35 $vtx2map`;
     constructionHistory -toggle false;
     for ($oneUV in $therealUVs)
        {
         polyEditUV  -r false -u $uParameter -v $vParameter $oneUV;   
     
            flushUndo;
            }

        }
       
    }
}


//===============================================================
//===============================================================
//===============================================================
//===============================================================


/*

global proc fxFlesh(string $skin, float $magnitude, int $geoCon)
{

//=== vars

string $innerSurf = ($skin+"_INNER");
string $outerSurf = ($skin+"_OUTER");

string $joints[];
string $curves[];

//=== create new surface

string $oldSkin = ($skin+"_OLD");
rename $skin ($skin+"_OLD");
duplicate -name $skin ($skin+"_OLD");

//=====================
//=== create inner geo
//=====================

select $skin;
duplicate -name $innerSurf;
select ($innerSurf+".vtx[*]");
string $pointsONE[] = `ls -sl -fl`;

//=== connect inner surf to original shape

connectAttr -f ($oldSkin+".outMesh") ($innerSurf+".inMesh");

//=== offset geometry

    for($i=0;$i<size($pointsONE);$i++)
    {
    //==== separate surfaces - for now just translations along normals
    select $pointsONE[$i];
    moveVertexAlongDirection -n ($magnitude*-1);
    }
   
//=======================
//====== create outer geo
//=======================

select $skin;
duplicate -name $outerSurf;
select ($outerSurf+".vtx[*]");
string $pointsTWO[] = `ls -sl -fl`;

//=== connect inner surf to original shape

connectAttr -f ($oldSkin+".outMesh") ($outerSurf+".inMesh");

//=== offset geometry
   
    for($i=0;$i<size($pointsTWO);$i++)
    {
    select $pointsTWO[$i];
    moveVertexAlongDirection -n $magnitude;
    }

//======= create curves


    for($i=0;$i<size($pointsONE);$i++)
    {
   
    float $coordONE[] = `pointPosition $pointsONE[$i]`;
    float $coordTWO[] = `pointPosition $pointsTWO[$i]`;
    $curves[size($curves)] = `curve -d 2 -p $coordONE[0] $coordONE[1]
$coordONE[2] -p (($coordONE[0]+$coordTWO[0])/2)
(($coordONE[1]+$coordTWO[1])/2) (($coordONE[2]+$coordTWO[2])/2) -p $coordTWO[0] $coordTWO[1]
$coordTWO[2]`;
   
    select $pointsONE[$i];
    string $vtxPos = `polyVertexPos`;
    string $loc[] = `listConnections ($vtxPos+".position")`;
    connectAttr -f ($vtxPos+".position") ($curves[$i]+".cv[0]");
    delete $loc[0];

    select $pointsTWO[$i];
    string $vtxPos2 = `polyVertexPos`;
    string $loc[] = `listConnections ($vtxPos2+".position")`;
    connectAttr -f ($vtxPos2+".position") ($curves[$i]+".cv[2]");
    delete $loc[0];
   
    shadingNode -name ($innerSurf+"_"+$i+"_ADD") -asUtility
plusMinusAverage;
    connectAttr -f
($vtxPos+".position")($innerSurf+"_"+$i+"_ADD.input3D[0]");
    connectAttr -f ($vtxPos2+".position")
($innerSurf+"_"+$i+"_ADD.input3D[1]");
    setAttr ($innerSurf+"_"+$i+"_ADD.operation") 3;
    connectAttr -f ($innerSurf+"_"+$i+"_ADD.output3D")
($curves[$i]+".cv[1]");

    }

//=== making curves dynamic

select $curves;
makeCurvesDynamicHairs;

//=== connect new joints to dynamic curves

string $dynCurves[] = `listRelatives hairSystem1OutputCurves`;
dgdirty -a;
    for($i=0;$i<size($dynCurves);$i++)
    {
    select -cl;
    joint -name ($innerSurf+"_"+$i+"_JNT");
    $mpath = `createNode motionPath`;
    setAttr ($mpath + ".fractionMode") (!false);
    connectAttr ($dynCurves[$i] + ".worldSpace[0]") ($mpath +  ".geometryPath");
    $mPATH = `rename $mpath ($innerSurf+"_"+$i+"_MPA")`;
    connectAttr -f ($mPATH + ".allCoordinates")
($innerSurf+"_"+$i+"_JNT.translate");
    setAttr ($mPATH + ".uValue") .5;
    $joints[size($joints)] = ($innerSurf+"_"+$i+"_JNT");
       
        if($geoCon>0)
        {
        select $oldSkin ($innerSurf+"_"+$i+"_JNT");
        geometryConstraint;
        }
    }

//==== binding old skin to new dynamic joints

select $skin $joints;
SmoothBindSkin;

//=== end

select -cl;


}

*/


//===============================================================
//===============================================================
//===============================================================

global proc posit()
{

string $sel[] = `ls -sl`;

string $source = `getAttr ($sel[0] + ".pose")`;
eval $source;

}

//===============================================================
//===============================================================
//===============================================================

global proc int fxGetClosestPoint(float $points[], float $p[]) {
    int $i;
    int $size = size($points)/3;
    float $min_dist = 1e9;
    int $closestId = -1;
    for($i = 0; $i <$size; $i++) {
        int $I = 3*$i;
        float $d = mag(<<$p[0] - $points[$I],$p[1] - $points[$I+1],$p[2] -
$points[$I+2]>>);
        if($d < $min_dist ) {
            $min_dist  = $d;
            $closestId  = $i;
        }
    }
    return $closestId;
}

//===============================================================
//===============================================================
//===============================================================

global proc fx_control(string $name, string $shape, int $trans, int
$rot, int $scale)
{

string $list[] = `ls -sl`;
string $obj = $list[0];
string $command;

    if(`gmatch $shape "handle"` == 1)
    {
    $command = ("curve -name "+ $name +"_ctrl -d 1 -p 0 0 0 -p -4 0 0 -p -6 2 0 -p -6 -2 0 -p -4 0 0 -k 0 -k 1 -k 2 -k 3 -k 4");
    }

    if(`gmatch $shape "cube"` == 1)
    {
    $command = ("curve -name "+ $name +"_ctrl -d 1 -p -1 1 1 -p 1 1 1 -p 1 1 -1 -p -1 1 -1 -p -1 1 1 -p -1 -1 1 -p 1 -1 1 -p 1 -1 -1 -p -1 -1 -1 -p -1 1 -1 -p -1 -1 -1 -p -1 -1 1 -p 1 -1 1 -p 1 1 1 -p 1 1 -1 -p 1 -1 -1 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15");
    }

    if(`gmatch $shape "triangle"` == 1)
    {
    $command = ("curve -name "+ $name +"_ctrl -d 1 -p 0 0 0 -p 0 4 0 -p -9 0 0 -p 0 0 0 -k 0 -k 1 -k 2 -k 3");
    }

eval($command);
spaceLocator -name ($name+"_ctrl_LOC");
parent ($name+"_ctrl") ($name+"_ctrl_LOC");
select $obj ($name+"_ctrl_LOC");
delete `pointConstraint`; delete `orientConstraint`;

    if($trans > 0)
    {
    select ($name+"_ctrl") $obj;
    pointConstraint -name ($obj+"_POC");
    }
   
    if($rot > 0)
    {
    select ($name+"_ctrl") $obj;
    orientConstraint -name ($obj+"_ORC");
    }
       
    if($scale > 0)
    {
    select ($name+"_ctrl") $obj;
    scaleConstraint -name ($obj+"_SCC");
    }

select $list;

}

//===============================================================
//===============================================================
//===============================================================

global  proc string cluster_curve(string $name, int $degrees)
{

string $nodes[] = `ls -sl`;
float $coord[];
string $return[] = {$name};   
string $command = ("curve -name "+$name+" -d " + $degrees+" ");
string $attrs[] = {
"tx",
"ty",
"tz",
"rx",
"ry",
"rz",
"sx",
"sy",
"sz"
};




    for($i = 0;$i<size($nodes);$i++)
    {
    float $coord[] = `xform -q -ws -t $nodes[$i]`;
    string $point = (" -p " + $coord[0] + " " + $coord[1] + " " +  $coord[2] + " ");
    $command += $point;
    }

eval($command);
    for($item in $attrs)
    setAttr -lock true -keyable false ($name+"."+$item);
string $shapeName[] = `listRelatives -f -c -s $name`;
rename $shapeName[0] ($name+"Shape");


    for($i = 0;$i<size($nodes);$i++)
    {
    string $POCO = `createNode  pointConstraint`;
   
    if(!`objExists ($nodes[$i]+"_WSN")`)
    {
    rename $POCO ($nodes[$i]+"_WSN");
    $POCO = ($nodes[$i]+"_WSN");
    }
   
    connectAttr ($nodes[$i]+".rotatePivotTranslate") ($POCO+".target[0].targetRotateTranslate");
    connectAttr ($nodes[$i]+".rotatePivot") ($POCO+".target[0].targetRotatePivot");
    connectAttr ($nodes[$i]+".t") ($POCO+".target[0].targetTranslate");
    connectAttr ($nodes[$i]+".parentMatrix[0]") ($POCO+".target[0].targetParentMatrix");
   
    connectAttr ($POCO+".constraintTranslateX") ($name+".controlPoints["+$i+"].xValue");
    connectAttr ($POCO+".constraintTranslateY") ($name+".controlPoints["+$i+"].yValue");
    connectAttr ($POCO+".constraintTranslateZ") ($name+".controlPoints["+$i+"].zValue");
    $return[size($return)] = $POCO;
    }

select $return;
group -name ($name+"_GRP");
select $nodes;
return ($name+"_GRP");

}

//===============================================================
//===============================================================
//===============================================================

global proc blend_con(string $type, string $attr, string $ctl)
{

string $list[] = `ls -sl`;
string $child = $list[2];

string $command = ("dnDoConstraint(\""+$type+"\")");
eval($command);

addAttr -ln $attr -keyable true -at double  -min 0 -max 1 -dv 0.5 $ctl;
connectAttr ($ctl+"."+$attr) ($child+".fcWeight"+$type);

}

//===============================================================
//============= select a nurbs surface ==========================
//===============================================================

global proc string[] find_spine_crv(int $sub)
{

string $curves[];
float $incr;
string $list[] = `ls -sl`;
int $DIR;

for($i=0;$i<size($list);$i++)
{
string $name = ($list[$i]+"_CRV");
string $commandU = ("curve -name "+$name+"U -d 2 ");
string $commandV = ("curve -name "+$name+"V -d 2 ");
string $shape[] = `listRelatives -s $list[$i]`;
string $node = $shape[0];
int $Vsp = `getAttr ($node+".spansV")`;
int $Usp = `getAttr ($node+".spansU")`;

if($Vsp>$Usp)
{
$DIR = $Vsp;
}
else
{
$DIR = $Usp;
}
   
    for($o=0;$o<($DIR+3);$o++)
    {
        //=== curve V

    select ($node+".cv[0:"+$Vsp+"]["+$o+"]");
    rename `CreateCluster` ("pippo"+$o);
    spaceLocator -name ("loc"+$o);
    select ("pippo"+$o) ("loc"+$o);
    delete `pointConstraint`;
    float $coord[] = `xform -q -ws -t ("loc"+$o)`;
    string $point = (" -p " + $coord[0] + " " + $coord[1] + " " +  $coord[2] + " ");
    delete ("pippo"+$o) ("loc"+$o);
    $commandV += $point;
       
        //===U curve
       
    select ($node+".cv["+$o+"][0:"+$Usp+"]");
   
    rename `CreateCluster` ("pippo"+$o);
    spaceLocator -name ("loc"+$o);
    select ("pippo"+$o) ("loc"+$o);
    delete `pointConstraint`;
    float $coord[] = `xform -q -ws -t ("loc"+$o)`;
    string $point = (" -p " + $coord[0] + " " + $coord[1] + " " +  $coord[2] + " ");
    delete ("pippo"+$o) ("loc"+$o);
    $commandU += $point;
    }
   
eval($commandV);
eval($commandU);

select ($name+"V");
string $exampleV[] = `duplicateCurve`;
rename `arcLengthDimension ($exampleV[0]+".u[1]")` Vlength ;
float $V = `getAttr Vlength.arcLength`;
delete $exampleV[0];


select ($name+"U");
string $exampleU[] = `duplicateCurve`;
rename `arcLengthDimension ($exampleU[0]+".u[0]")` Ulength ;
float $U = `getAttr Ulength.arcLength`;
delete $exampleU[0];

if($V>$U)
{
delete ($name+"U");
rename ($name+"V") $name;
}
else
{
delete ($name+"V");
rename ($name+"U") $name;
}

rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s $sub -d 2 -tol 1e-08 $name;
select $name;
DeleteHistory;
$curves[size($curves)] = $name;
}


return $curves;
}

//===============================================================
//===============================================================
//===============================================================

global proc avSkinWeight()
{

string $list[] = `ls -sl -fl`;
string $refVTX;
string $buff[];
string $geo;

if(`gmatch $list[0] "*vtx*"`==1)
{
$refVTX = $list[0];
tokenize $list[0] "." $buff;
$geo = $buff[0];
}
else
{
$buff = `ls -hl`;
$geo = $buff[0];
}

//=== looking for the skin cluster

string $poo[] = `ls -type skinCluster`;
string $skinC;
for($i=0;$i<size($poo);$i++)
{

string $pippo[] = `listConnections -s 0 -scn 1 $poo[$i]`;

for($p=0;$p<size($pippo);$p++)
{
    if(`gmatch $pippo[$p] $geo`== 1)
    {
    $skinC = $poo[$i];
    }
    else
    {
    string $ciccia[] = `listConnections -s 0 -scn 1 $pippo[$p]`;
       
        for($z=0;$z<size($ciccia);$z++)
        {
            if(`gmatch $ciccia[$z] $geo`== 1)
            {
            $skinC = $poo[$i];
            }
        }
    }
}
}   

//=== end of looking for the skin cluster

string $joints[] = `skinPercent -q -t $skinC $refVTX`;
float $tot = 0.0000;
int $zeros = 0;
float $num;
float $value[];

//=== find different from 0

    for($o=0;$o<size($joints);$o++)
    {
        for($i=0;$i<size($list);$i++)
        {
            if(`gmatch $geo $list[$i]`==0)
            {
            $value = `skinPercent -q -v $skinC $list[$i]`;
            }
           
        $tot=$tot+$value[$o];
       
            if($value[$o] == 0)
            {
            $zeros=$zeros+1;
            }
       
        }
       
        if($tot != 0)
        {
            for($i=0;$i<size($list);$i++)
            {
                if($zeros>(size($list)/2))
                {
                $num = 0;
                }
                else
                {
                $num = ($tot/size($list));
                }
            skinPercent -tv $joints[$o] $num $skinC $list[$i];
            }
        }
    $tot = 0.0000;
    $zeros = 0;
    }


}

//===============================================================
//===============================================================
//===============================================================


global proc cpSkinWeight()
{

string $list[] = `ls -sl -fl`;
string $buff[];
string $geo;

if(`gmatch $list[0] "*vtx*"`==1)
{
tokenize $list[0] "." $buff;
$geo = $buff[0];
}
else
{
$buff = `ls -hl`;
$geo = $buff[0];
}

//=== looking for the skin cluster

string $poo[] = `ls -type skinCluster`;
string $skinC;
for($i=0;$i<size($poo);$i++)
{

string $pippo[] = `listConnections -s 0 -scn 1 $poo[$i]`;

for($p=0;$p<size($pippo);$p++)
{
    if(`gmatch $pippo[$p] $geo`== 1)
    {
    $skinC = $poo[$i];
    }
    else
    {
    string $ciccia[] = `listConnections -s 0 -scn 1 $pippo[$p]`;
       
        for($z=0;$z<size($ciccia);$z++)
        {
            if(`gmatch $ciccia[$z] $geo`== 1)
            {
            $skinC = $poo[$i];
            }
        }
    }
}
}   

//=== end of looking for the skin cluster

string $joints[] = `skinPercent -q -t $skinC $list[0]`;
float $value[] = `skinPercent -q -v $skinC $list[0]`;

//=== set value

    for($o=0;$o<size($joints);$o++)
    {
    skinPercent -tv $joints[$o] $value[$o] $skinC $list[1];
    }


}

//===============================================================
//===============================================================
//===============================================================


//================ fcEnv2Bind
//== $fcEnvDeformer = fcEnv deformer
//== $file = name of the file/directory where maps get saved
//== $res = map resolution ($res x $res)

global proc fcEnv2bind(string $fcEnvDeformer, string $file, int $res)
{

string $geo[] = `listConnections ($fcEnvDeformer+".outputGeometry")`;
select $geo;
string $cages[] = `listConnections ($fcEnvDeformer+".envMats")`;
string $pulls[];
string $skinClusters[];

    for($i = 0;$i<size($cages);$i++)
    {
    string $pippo[] = `listRelatives -p $cages[$i]`;
    $pulls[size($pulls)] = $pippo[0];
    }

fcEnvExportWeights $fcEnvDeformer $file $res $res;

delete $fcEnvDeformer;

    for($i = 0;$i<size($cages);$i++)
    {
    select $pulls[$i];
    joint -name newjoint;
    delete $cages[$i];
    rename newjoint $cages[$i];
    }
   
    for($i = 0;$i<size($geo);$i++)
    {
    select $cages $geo[$i];
    string $pippo[] = `newSkinCluster "-mi 5 -omi true -dr 4 -rui true"`;
    
        if(`filetest -f  ($file+".weights")`)
        { 
        select $geo[$i];
        fxImportSkinWeightMap ($file+".weights") $pippo[0] $geo[$i];
        $skinClusters[size($skinClusters)] = $pippo[0];
        }
    }

}


//===============================================================
//===============================================================
//===============================================================

global proc connectOffsetCagesVisibility(string $fcEnvs[]){
    //get the offset cages from these fcEnvs
    string $e,$c;
    for($e in $fcEnvs){
        string $oc[] = `listConnections -type mesh -sh 1 ($e +  ".offsetedCage")`;
        if(!size($oc))
            continue;
        string $def = `fcEnvGetConnectedDeformer $e  0`;
        if($def == "")
            continue;
        if(!size(`listConnections ($oc[0] + ".intermediateObject")`))
            connectAttr -f ($def + ".ignoreCore") ($oc[0] +  ".intermediateObject");
    }
}


global proc int updateOldStlyeConnections(string $envNode, int
$disableNode) {
   
    string $deformer[] = `listConnections -p 1 -type fcEnvDeform
$envNode`;
    string $deformerNode[] = `listConnections -p 0 -type fcEnvDeform
$envNode`;
    if(!size($deformer))
        return 0;
    if($disableNode)
    {    setAttr ($deformerNode[0]+".nodeState") 9;
        evalDeferred("setAttr "+$deformerNode[0]+".nodeState 0");
    }
    int $index = getPlugIndex($deformer[0]);
    print("\nreconnecting "+$envNode +" to "+$deformerNode[0] +"...");
    if(!plugConnected($envNode+".partialCage")){
       
        CONNECT_ATTR($envNode,"partialCage", $deformerNode[0] , ("partialCages[" + $index + "]"));
    }
    if(!plugConnected($envNode+".cylinderCapsOnly"))
        CONNECT_ATTR($envNode,"cylinderCapsOnly", $deformerNode[0] , ("cylinderCapsOnly[" + $index + "]"));
   
   
    return 1;
}

global proc string[] getAllConnectedDeformers(string $node,int $returnPlug)
{
return `listConnections -p $returnPlug -type fcEnvDeform $node`;
}

global proc fxEnvAddFcEnvNode(string $geom, string $fcEnvs[]) {

    //string $geom[] = getFcEnvSelection("geometry");
    //string $fcEnvs[] = getFcEnvSelection("fcEnv");
    if(!size($geom) || !size($fcEnvs))
        error "select fcEnv nodes and a shape";

    string $def[] = ls("-type","fcEnvDeform",`listHistory -f 0 $geom`);
    string $deformer = $def[0];
    if($deformer == "")
        error("couldn't find a deformer connected to " + $geom);
   
    string $p, $cmd =  "fcEnv -ap ";
    int $n_valid = 0;
    for($p in $fcEnvs) {
        string $connected[] = getAllConnectedDeformers($p,0);
       
        if(stringArrayCount($deformer,$connected)>0) {
            warning($p + " is already connected to deformer: "+ $deformer +" -discarding it");
            continue;
        }
        $cmd += " -p " + $p;
        ++$n_valid;
        updateOldStlyeConnections($p,1);
    }
    select -r $deformer;
    if(!$n_valid)
        return;
    evalEcho $cmd;

    connectOffsetCagesVisibility($fcEnvs);

}

//===============================================================
//===============================================================
//===============================================================


global  proc string[] makeCurveDynForMuscle(string $name)
{

string $prefix;
string $baseName;

string $names[] = `ls -sl`;
string $item;
string $name;
string $pippo[];

for($item in $names)
{

//string $name = $names[0];
$name = $item;
string $grp[] = `listRelatives -p $name`;

select $name;

makeCurvesDynamicHairs 0 0 0;
string $hsysSh[] = `getSelectedHairSystems`;
string $foll[] = `listConnections ($hsysSh[0] + ".outputHair")`;
string $hsys[] = `listRelatives -p $hsysSh[0]`;

string $outCrv[] = `listRelatives -ad -typ transform ($hsys[0] +  "OutputCurves")`;

select $foll[0];
string $pip[] = `listRelatives -ad -typ shape`;
string $follShape;

    for($i = 0; $i < size($pip); $i++)
    {
        if(`gmatch $pip[$i] "follicle*"` ==1)
        {
        $follShape = $pip[$i];
        }
    }

setAttr ($follShape + ".pointLock") 1;


rename $hsys[0] ($name + "_HAS");
$hsys[0] = ($name + "_HAS");
rename $foll[0] ($name + "_FOL");
$foll[0] = ($name + "_FOL");
rename $outCrv[0] ($name + "_dyn_CRV");
$outCrv[0] = ($name + "_dyn_CRV");

string $outCrvGrp[] = `listRelatives -p $outCrv[0]`;

//=== shape blend

duplicate -name ($name + "_fin_CRV")  $name;
select $outCrv[0] $name ($name + "_fin_CRV");
blendShape -name ($name + "_SHP");

addAttr -ln blend -at double -min 0 -max 1 -dv 1 ($name + "_fin_CRV");
setAttr -e -keyable true ($name + "_fin_CRV.blend");
connectAttr -f ($name + "_fin_CRV.blend") ($name + "_SHP." +  $outCrv[0]);
shadingNode -asUtility reverse -name ($name + "_REV");
connectAttr -f ($name + "_SHP." + $outCrv[0]) ($name + "_REV.inputX");
connectAttr -f ($name + "_REV.outputX") ($name + "_SHP." + $name);

$outCrv[0] = ($name + "_fin_CRV");

//=== end shape blend

//setAttr ($hsys[0]+"Shape.stiffness") 0.01;

$pippo = {$hsys[0], $foll[0], $name, $outCrv[0], ($name + "_dyn_CRV")};
}

return $pippo;

//return {$hsys[0], $foll[0], $outCrv[0]};

}



//===============================================================
//===============================================================
//===============================================================

global proc string[] joints_on_curve_for_msl(string $curve, string
$jntName, int $num)
{

cycleCheck -e off;

    string $names[];

    string $prefix;
    string $baseName = $jntName;
    int $prefixSize;
   

//===================== loop

string $EXT = "_JNT";
string $ext = "_jnt";
string $loc = ($ext + "_LOC");
string $pext = ($loc + "_mpa");

float $path_value = (1.00/($num - 1));

    if($num < 3)
    {
    float $path_value = 1.00;
    }



        for( $i=1; $i < ($num +1); $i++ )
        {
        string $name = ($baseName + $i);
        select -cl;

        joint -n ($name + $EXT);
        spaceLocator -n ($name + $loc);
        $names[`size $names`] = ($name + $EXT);

        parent ($name + $EXT) ($name + $loc);
       
        select ($name + $loc) $curve;
        $mpath = `pathAnimation -fractionMode true -follow true -followAxis x
-upAxis y -worldUpType "normal" -inverseUp false -inverseFront false
-bank false -startTimeU 0`;
        $mPATH = `rename $mpath ($name + $pext)`;
   
   
        CBdeleteConnection ($name + $loc + ".rx");
        CBdeleteConnection ($name + $loc + ".ry");
        CBdeleteConnection ($name + $loc + ".rz");
        disconnectAttr ($name + $pext + ".rotateOrder") ($name + $loc +  ".rotateOrder");
        string $pip[] =  `listConnections -d 1 -c 1 -p 1 ($name + $loc +  ".transMinusRotatePivotZ")`;
        disconnectAttr $pip[0] $pip[1];
        string $pip[] =  `listConnections -d 1 -c 1 -p 1 ($name + $loc +  ".transMinusRotatePivotY")`;
        disconnectAttr $pip[0] $pip[1];
        string $pip[] =  `listConnections -d 1 -c 1 -p 1 ($name + $loc +  ".transMinusRotatePivotX")`;
        disconnectAttr $pip[0] $pip[1];


   
        setAttr ($name + $loc + ".rotateX") 0;
        setAttr ($name + $loc + ".rotateY") 0;
        setAttr ($name + $loc + ".rotateZ") 0;
   
        CBdeleteConnection ($mPATH + ".u");
        setAttr ($mPATH + ".u") ($path_value * ($i -1));
       
            if($i == ($num + 1))
            {
            setAttr ($mPATH + ".u") 1;
            }
       
        delete $mPATH;
        }
cycleCheck -e on;
   
select -cl;
return $names;
}

//===============================================================
//===============================================================
//===============================================================


//====
//=== eMuscle stands for easy muscle, felix
//==== just select a surface to deform, a curve and run this script


global proc eMuscle(string $name, int $num, int $dyn, string $parent)
{

string $hs[] = `ls" hairSystem*"`;
string $list[] = `ls -sl`;
string $surface = $list[0];
string $cazzinculo[] =  `duplicate -name ($surface+"COPY") $surface` ;
string $surfaceCOPY = $cazzinculo[0];
string $curve = $list[1];
string $spine_locs[];
string $base_locs[];
string $dynElements[];


if($dyn != 0)
{
select $curve;
$dynElements = `makeCurveDynForMuscle $name`;

rename $dynElements[0] ($name+"_HAS");
rename $dynElements[1] ($name+"_FOL");
rename $dynElements[2] ($name+"_orig_CRV");
rename $dynElements[3] ($name+"_spine_CRV");
rename $dynElements[4] ($name+"_dyn_CRV");

setAttr ($name+"_spine_CRV.inheritsTransform") 0;
setAttr ($name+"_orig_CRV.inheritsTransform") 0;
setAttr ($name+"_FOLShape.pointLock") 3;
}
else
{
rename $curve ($name+"_spine_CRV");
}

string $elem[] = `wire -gw true -en 1.000000 -ce 0.000000 -li 0.000000 -w ($name+"_spine_CRV") -dds 0 5.000000 $surface`;

setAttr ($elem[0]+".rotation") 0;
float $dist = `getAttr ($elem[0]+".dropoffDistance[0]")`;

//if($dyn != 0)
//{
//rename $curve ($name+"_orig_CRV");
//}

rename ($name+"_spine_CRVBaseWire") ($name+"_base_CRV");
rename ($name+"_spine_CRVGroup") ($name+"_curves_GRP");

string $spine_jnts[] = `joints_on_curve_for_msl ($name+"_spine_CRV")
($name +"_spine") $num`;
string $base_jnts[] = `joints_on_curve_for_msl ($name+"_base_CRV")
($name +"_base") $num`;



    for($i=0;$i<size($spine_jnts);$i++)
    {
    string $minchiafritta[] = `listRelatives -p $spine_jnts[$i]`;
    string $cazzinculo[] = `listRelatives -p $base_jnts[$i]`;
    $spine_locs[size($spine_locs)] = $minchiafritta[0];
    $base_locs[size($base_locs)] = $cazzinculo[0];
    }

    for($i=0;$i<size($spine_jnts);$i++)
    {
    parent $spine_jnts[$i] $base_locs[$i];
    select $surfaceCOPY $base_locs[$i];

        if($i<size($spine_jnts))
        {
            if($i>0)
            {
            delete `normalConstraint -aimVector 0 1 0 -upVector -1 0 0
-worldUpType "object" -worldUpObject $base_locs[$i-1]`;
            }
        }
       
       
    }
select $surfaceCOPY $base_locs[0];
delete `normalConstraint -aimVector 0 1 0 -upVector 1 0 0 -worldUpType
"object" -worldUpObject $base_locs[1]`;


delete $surfaceCOPY;
delete $spine_locs;
select $base_locs;
group -name ($name+"_msl_ctls_GRP");
select $base_locs;
group -name ($name+"_base_GRP");
setAttr -l 1 -k 0 ($name+"_base_GRP.v") 0;


if($dyn == 1)
{
select $spine_jnts ($name+"_orig_CRV"); SmoothBindSkin;
select $base_jnts ($name+"_base_CRV"); SmoothBindSkin;
select ($name+"_HAS") ($name+"_FOL") ($name+"_spine_CRV")
($name+"_base_CRV") ($name+"_dyn_CRV");
}
else
{
select $spine_jnts ($name+"_spine_CRV"); SmoothBindSkin;
select $base_jnts ($name+"_base_CRV"); SmoothBindSkin;
select ($name+"_spine_CRV") ($name+"_base_CRV");
}


group -name ($name+"_msl_no_trans_GRP");


select ($name+"_msl_ctls_GRP") ($name+"_msl_no_trans_GRP");

group -name ($name+"_msl_GRP");
addAttr -ln msl -at bool ($name+"_msl_GRP");

if($dyn != 0)
{
setAttr ($name+"_msl_GRP.msl") 1;

addAttr -k 1 -ln scale_factor -at double -dv 1 ($name+"_msl_GRP");
addAttr -k 1 -ln slide -at double  -min 0 -max 1 -dv .5 ($name+"_msl_GRP");
addAttr -k 1 -ln stiffness -at double  -min 0.00 -max 1.00 -dv 1 ($name+"_msl_GRP");
connectAttr($name+"_msl_GRP.stiffness") ($name+"_HASShape.stiffness");
addAttr -k 1 -ln dropoff -at double -dv $dist ($name+"_msl_GRP");
addAttr -k 1 -ln damp -at double  -min 0 -dv 1 ($name+"_msl_GRP");
connectAttr ($name+"_msl_GRP.damp") ($name+"_HASShape.damp");
addAttr -k 1 -ln iterations -at double  -min 1 -dv 10 ($name+"_msl_GRP");
connectAttr ($name+"_msl_GRP.iterations") ($name+"_HASShape.iterations");
addAttr -k 1 -ln drag -at double  -min 0 -dv 0 ($name+"_msl_GRP");
connectAttr ($name+"_msl_GRP.drag") ($name+"_HASShape.drag");

connectAttr ($name+"_msl_GRP.dropoff") ($elem[0]+".dropoffDistance[0]");
addAttr -k 1 -ln envelope -at double  -min 0 -max 1 -dv 1 ($name+"_msl_GRP");
connectAttr ($name+"_msl_GRP.envelope") ($elem[0]+".envelope");
addAttr -k 1 -ln dynamic -at double  -min 0 -max 1 -dv 1 ($name+"_msl_GRP");
connectAttr ($name+"_msl_GRP.dynamic") ($name+"_spine_CRV.blend");

setAttr ($name+"_dyn_CRV.v") 0;
}
else
{
setAttr ($name+"_msl_GRP.msl") 0;
addAttr -k 1 -ln scale_factor -at double -dv 1 ($name+"_msl_GRP");
addAttr -k 1 -ln slide -at double  -min 0 -max 1 -dv 1 ($name+"_msl_GRP");
addAttr -k 1 -ln envelope -at double  -min 0 -max 1 -dv 1 ($name+"_msl_GRP");
addAttr -k 1 -ln dropoff -at double -dv $dist ($name+"_msl_GRP");
connectAttr ($name+"_msl_GRP.dropoff") ($elem[0]+".dropoffDistance[0]");
connectAttr ($name+"_msl_GRP.envelope") ($elem[0]+".envelope");
}

    for($i=0;$i<size($spine_jnts);$i++)
    {
    shadingNode -asUtility multiplyDivide -name ($spine_jnts[$i]+"_MUL");
    connectAttr ($spine_jnts[$i]+".tx") ($spine_jnts[$i]+"_MUL.input1X");
    connectAttr ($spine_jnts[$i]+".tz") ($spine_jnts[$i]+"_MUL.input1Z");
    connectAttr ($name+"_msl_GRP.slide") ($spine_jnts[$i]+"_MUL.input2X");
    connectAttr ($name+"_msl_GRP.slide") ($spine_jnts[$i]+"_MUL.input2Z");
    connectAttr ($spine_jnts[$i]+"_MUL.outputX") ($base_jnts[$i]+".tx");
    connectAttr ($spine_jnts[$i]+"_MUL.outputZ") ($base_jnts[$i]+".tz");
    transformLimits -ty 0 1 -ety 1 0 $spine_jnts[$i];
    }

hide_locs;
sets -name ($name+"_clt_SEL") `ls $spine_jnts ($name+"_msl_GRP")`;

if(`objExists ($name+"_HAS")`)
sets -add ($name+"_clt_SEL") ($name+"_HAS");

//=== parent

if(`size($parent)`>0)
parent ($name+"_base_GRP") $parent;


string $posths[] = `ls" hairSystem*"`;

for($i=(0+(size($hs)));$i<size($posths);$i++)
{
delete $posths[$i];
}


string $list[] = `ls ($name+"_msl_no_trans_GRP") ($name+"_msl_GRP") ($name+"_HAS") ($name+"_FOL") ($name+"_spine_CRV") ($name+"_base_CRV") $base_jnts`;

for($item in $list)
{
setAttr -keyable false ($item+".t");
setAttr -keyable false ($item+".r");
setAttr -keyable false ($item+".s");
//setAttr -lock true ($item+".t");
//setAttr -lock true ($item+".r");
//setAttr -lock true ($item+".s");
setAttr -channelBox false ($item+".t");
setAttr -channelBox false ($item+".r");
setAttr -channelBox false ($item+".s");
}



//=== volume change

string $curve;
if(`objExists ($name+"_orig_CRV")`)
$curve = ($name+"_orig_CRV");
else
$curve = ($name+"_spine_CRV");

rename `arcLengthDimension ($curve+".u[1000]")` ($name+"_stretch_ARL") ;
float $length = `getAttr ($name+"_stretch_ARL.arcLength")`;
shadingNode -asUtility multiplyDivide -name ($name+"_stretch_MUL");
shadingNode -asUtility multiplyDivide -name ($name+"_stretch_boost_MUL");
setAttr ($name+"_stretch_MUL.input1X") $length;
connectAttr ($name+"_stretch_ARL.arcLength") ($name+"_stretch_MUL.input2X");
connectAttr ($name+"_stretch_MUL.outputX") ($name+"_stretch_boost_MUL.input1X");
connectAttr ($name+"_msl_GRP.scale_factor") ($name+"_stretch_boost_MUL.input2X");
connectAttr ($name+"_stretch_boost_MUL.outputX") ($elem[0]+".scale[0]");
setAttr ($name+"_stretch_MUL.operation") 2;

//===

if($dyn == 0)
{
delete ($name+"_curves_GRP");
}

rename $elem[0] ($name+"_WRD");

select -cl;

}


//===============================================================
//===============================================================
//===============================================================
//===============================================================
//===============================================================
//===============================================================


global proc invConnect(string $input, string $output)
{

string $invNode = `shadingNode -asUtility reverse`;
connectAttr -f $input ($invNode+".inputX");
connectAttr -f ($invNode+".outputX") $output;

}

//===============================================================
//===============================================================
//===============================================================

global proc negConnect(string $input, string $output)
{

string $invNode = `shadingNode -asUtility multiplyDivide`;
connectAttr -f $input ($invNode+".input1X");
setAttr ($invNode+".input2X") -1;
connectAttr -f ($invNode+".outputX") $output;

}

//===============================================================
//===============================================================
//===============================================================

global proc string[] cleanWeights(string $def, int $do)
{

string $set[] = `listConnections -type objectSet $def`;
//=== find geo

string $nodes[] = `sets -q $set` ;
string $names[] ;

tokenize($nodes[0], ".", $names);
string $geo = $names[0];

string $ref[] =`ls -fl ($geo+".vtx["+"*"+"]")`;
string $token[];
string $number[];
tokenize $ref[0] "[" $token;
tokenize $token[1] "]" $number;
print $number[0];
int $num = size($ref);

string $NOp[];
string $YESp[];
float $weight;
float $double[];

string $weightAttr = "weightList[0].weights";

string $type[] = `ls -st $def`;

if(`gmatch $type[1] "blendShape"`)
$weightAttr = "inputTarget[0].inputTargetGroup[0].targetWeights";

   
for($i=0;$i<$num;$i++)
{


    if(size($double)>0)
    {   
        if($double[$i] == 0)
        $NOp[size($NOp)] = ($geo+".vtx["+$i+"]");
        else
        $YESp[size($YESp)] = ($geo+".vtx["+$i+"]");
    }
    else
    {
    $weight = `getAttr ($def+"."+$weightAttr+"["+$i+"]")`;

        if($weight == 0)
        $NOp[size($NOp)] = ($geo+".vtx["+$i+"]");
        else
        $YESp[size($YESp)] = ($geo+".vtx["+$i+"]");
}

}



if($do>0)
{
sets -rm $set[0] $NOp;
}

return $YESp;

}


//===============================================================
//===============================================================
//===============================================================


global proc string[] averagePointConstraintMO()
{

string $list[] = `ls -sl`;
$quantity = `size($list)`;
$end = $quantity - 1;
$half = $quantity / 2;
int $i;
string $item;

string $cons[];

    for( $i = 1; $i < $end; $i++ )
    {
    $item = $list[$i];
    select $list[0] $list[$end] $item;
    parentConstraint -mo -name ($item + "_PAC");

    CBdeleteConnection ($item+".rx");
    CBdeleteConnection ($item+".ry");
    CBdeleteConnection ($item+".rz");
   
    $cons[size($cons)] = ($item + "_PAC");
           
    float $first = ((1.00 / $end) * $i);
    setAttr ($item + "_PAC." + $list[0] + "W0") (1 - $first);
    setAttr ($item + "_PAC." + $list[$end] + "W1") $first;
    }


select -cl;
return $cons;

}

//==============================================
//==============================================
//==============================================

//source "/job/tiptop/common/maya/mel/mz_OrientJoint.mel";
//source "/job/tiptop/common/maya/mel/mz_ZeroOut.mel";
//source "/job/tiptop/common/maya/mel/mz_Procedures.mel";

global proc fkChainHandle(string $name)
{

//=== select the root joint of a chain


string $jnts[] = `ls -sl`;
select -cl;

select $jnts[0] $jnts[size($jnts)-1];
float $scaleFactor = `get_distance`;

float $scale = (1*($scaleFactor)/200);

//=== orient them

mz_DoOrientJoint {$jnts[0]} worldSpace 1 xyz 0 "+y" 0;


spaceLocator -name ($name+"_ctrl_LOC");
curve -name ($name+"_ctrl") -d 2 -p 0 0 0 -p 1 1 1 -p 2 2 2;
parent ($name+"_ctrl") ($name+"_ctrl_LOC");
select $jnts[0] ($name+"_ctrl_LOC");
delete `parentConstraint`;
changeShape ($name+"_ctrl") handle $scale;

addAttr -k 1 -ln curlX -at double ($name+"_ctrl");
addAttr -k 1 -ln curlY -at double ($name+"_ctrl");
addAttr -k 1 -ln curlZ -at double ($name+"_ctrl");

string $locs[];

    for($i=0;$i<size($jnts);$i++)
    {
    $locs[size($locs)] = ($name + "_" + ($i+1) + "_ctrl_rot_LOC");
    spaceLocator -name  ($name + "_" + ($i+1) + "_ctrl_LOC");
    spaceLocator -name  ($name + "_" + ($i+1) + "_ctrl_rot_LOC");
    curve -name  ($name + "_" + ($i+1) + "_ctrl") -d 2 -p 0 0 0 -p 1 1 1 -p
2 2 2;
    parent ($name + "_" + ($i+1) + "_ctrl") ($name + "_" + ($i+1) +  "_ctrl_rot_LOC");
    parent ($name + "_" + ($i+1) + "_ctrl_rot_LOC") ($name + "_" + ($i+1) +  "_ctrl_LOC");
    select $jnts[$i] ($name + "_" + ($i+1) + "_ctrl_LOC"); delete
`parentConstraint`;
   
        if(`objExists ($name + "_" + $i + "_ctrl")`)
        parent ($name + "_" + ($i+1) + "_ctrl_LOC") ($name + "_" + $i +  "_ctrl");
        else
        parent ($name + "_" + ($i+1) + "_ctrl_LOC") ($name + "_ctrl");

   
    select ($name + "_" + ($i+1) + "_ctrl") $jnts[$i];
    parentConstraint;
    changeShape ($name + "_" + ($i+1) + "_ctrl") handle $scale;
    }
   

    for($item in $locs)
    {
    connectAttr ($name+"_ctrl.curlX") ($item +".rx");
    connectAttr ($name+"_ctrl.curlY") ($item +".ry");
    connectAttr ($name+"_ctrl.curlZ") ($item +".rz");
    }

select ($name+"_ctrl") $jnts[0];
//pointConstraint;
//orientConstraint;

select -cl;

}


//================================
//================================

global proc showmeAll()
{

string $list[] = `ls -type transform -type shape`;

    for($item in $list)
    {
        if(`getAttr ($item+".v")` <1)
            {
        setAttr -l 0 ($item+".v");
        string $pippo[] = `listConnections ($item+".v")`;
            if(size($pippo)>0)
            {
            string $attr[] = `listConnections -p 1 ($item+".v")`;
            disconnectAttr $attr[0]  ($item+".v");
            }
        setAttr    ($item+".v") 1;
        }

    }

}


//================================
//================================

global proc lock_trans(int $X, int $Y, int $Z)
{

string $list[] = `ls -sl`;

    for($item in $list)
    {

        if($X == 1)
        {
        float $num[] = `getAttr ($item+".t")`;
        transformLimits -tx $num[0] $num[0] -etx 1 1 $item;
        }
        else
        {
        transformLimits -etx 0 0 $item;
        }
       
        if($Y == 1)
        {
        float $num[] = `getAttr ($item+".t")`;
        transformLimits -ty $num[1] $num[1] -ety 1 1 $item;
        }
        else
        {
        transformLimits -ety 0 0 $item;
        }
       
        if($Z == 1)
        {
        float $num[] = `getAttr ($item+".t")`;
        transformLimits -tz $num[2] $num[2] -etz 1 1 $item;
        }
        else
        {
        transformLimits -etz 0 0 $item;
        }
    }

}
//================================
//================================

global proc lock_trans_min(int $X, int $Y, int $Z)
{

string $list[] = `ls -sl`;

    for($item in $list)
    {

        if($X == 1)
        {
        float $num[] = `getAttr ($item+".t")`;
        transformLimits -tx $num[0] $num[0] -etx 1 0 $item;
        }
        else
        {
        transformLimits -etx 0 0 $item;
        }
       
        if($Y == 1)
        {
        float $num[] = `getAttr ($item+".t")`;
        transformLimits -ty $num[1] $num[1] -ety 1 0 $item;
        }
        else
        {
        transformLimits -ety 0 0 $item;
        }
       
        if($Z == 1)
        {
        float $num[] = `getAttr ($item+".t")`;
        transformLimits -tz $num[2] $num[2] -etz 1 0 $item;
        }
        else
        {
        transformLimits -etz 0 0 $item;
        }
    }

}

//================================
//================================

global proc lock_trans_max(int $X, int $Y, int $Z)
{

string $list[] = `ls -sl`;

    for($item in $list)
    {

        if($X == 1)
        {
        float $num[] = `getAttr ($item+".t")`;
        transformLimits -tx $num[0] $num[0] -etx 0 1 $item;
        }
        else
        {
        transformLimits -etx 0 0 $item;
        }
       
        if($Y == 1)
        {
        float $num[] = `getAttr ($item+".t")`;
        transformLimits -ty $num[1] $num[1] -ety 0 1 $item;
        }
        else
        {
        transformLimits -ety 0 0 $item;
        }
       
        if($Z == 1)
        {
        float $num[] = `getAttr ($item+".t")`;
        transformLimits -tz $num[2] $num[2] -etz 0 1 $item;
        }
        else
        {
        transformLimits -etz 0 0 $item;
        }
    }

}

global proc lock_rot(int $X, int $Y, int $Z)
{

string $list[] = `ls -sl`;


//================================
//================================

    for($item in $list)
    {
        if($X == 1)
        {
        float $num[] = `getAttr ($item+".r")`;
        transformLimits -rx $num[0] $num[0] -erx 1 1 $item;
        }
        else
        {
        transformLimits -erx 0 0 $item;
        }
       
        if($Y == 1)
        {
        float $num[] = `getAttr ($item+".r")`;
        transformLimits -ry $num[1] $num[1] -ery 1 1 $item;
        }
        else
        {
        transformLimits -ery 0 0 $item;
        }
       
        if($Z == 1)
        {
        float $num[] = `getAttr ($item+".r")`;
        transformLimits -rz $num[2] $num[2] -erz 1 1 $item;
        }
        else
        {
        transformLimits -erz 0 0 $item;
        }
    }

}

global proc lock_scale(int $X, int $Y, int $Z)
{

string $list[] = `ls -sl`;

    for($item in $list)
    {
        if($X == 1)
        {
        float $num[] = `getAttr ($item+".s")`;
        transformLimits -sx $num[0] $num[0] -esx 1 1 $item;
        }
        else
        {
        transformLimits -esx 0 0 $item;
        }
       
        if($Y == 1)
        {
        float $num[] = `getAttr ($item+".s")`;
        transformLimits -sy $num[1] $num[1] -esy 1 1 $item;
        }
        else
        {
        transformLimits -esy 0 0 $item;
        }
       
        if($Z == 1)
        {
        float $num[] = `getAttr ($item+".s")`;
        transformLimits -sz $num[2] $num[2] -esz 1 1 $item;
        }
        else
        {
        transformLimits -esz 0 0 $item;
        }
    }


}


//================================
//================================


global proc swap_parent_cons()
{

string $list[] = `ls -type parentConstraint`;

for($i=0;$i<size($list);$i++)
{
string $input[] = `listConnections
($list[$i]+".target[0].targetRotate")`;
string $ouput[] = `listConnections ($list[$i]+".constraintRotateZ")`;
delete $list[$i];
 catchQuiet(`parent $ouput[0] $input[0]`);
}


}

//==============================
//==============================

global proc string findRelatedSkinCluster(string $skinObj)
{
    string $skinShape;
    string $skinShapeWithPath;
    string $cpTest[] = `ls -type controlPoint $skinObj`;
    if (size($cpTest)) {
        $skinShape = $skinObj;
    } else {
        string $rels[] = `listRelatives $skinObj`;
        for ($r in $rels) {
            $cpTest = `ls -type controlPoint ($skinObj+"|"+$r)`;
            if (0 == size($cpTest)) {
                continue;
            }
            int $io = `getAttr ($skinObj+"|"+$r+".io")`;
            if ($io) {
                continue;
            }
            $skinShape = $r;
            $skinShapeWithPath = ($skinObj+"|"+$r);
            break;
        }
    }

    if (0 == size($skinShape)) {
        return "";
    }

    string $clusters[] = `ls -type skinCluster`;
    for ($c in $clusters) {
        string $geom[] = `skinCluster -q -g $c`;
        for ($g in $geom) {
            if ($g == $skinShape || $g == $skinShapeWithPath) {
                return $c;
            }
        }
    }
    return "";
}

//========================
//========================
//========================


global proc print_parent()
{
string $list[] = `ls -sl -type transform`;

    for($i=0;$i<size($list);$i++)
    {
    string $parent[] = `listRelatives -p $list[$i]`;
    print ("\nparent "+$list[$i] + " " + $parent[0]+";\n");
    }

}

//========================
//========================
//========================


global proc string[] chain_on_curve(string $curve, string $baseName,
int $num)
{
setAttr ($curve + ".maxValue") 1;

float $pathMaxU = 1;
float $path_value = ($pathMaxU/($num - 1));
if($num < 3)
{
float $path_value = $pathMaxU;
}

string $EXT = "_JNT";
string $names[];

        for( $i=1; $i < ($num +1); $i++ )
        {
        select -cl;
        string $name = ($baseName + $i);
        select -cl;
        joint -n ($name + $EXT);
        $names[`size $names`] = ($name+ $EXT);
       
        $mpath = `createNode motionPath`;
       
        setAttr ($mpath + ".fractionMode") (!false);
        connectAttr ($curve + ".worldSpace[0]") ($mpath + ".geometryPath");
        $mPATH = `rename $mpath ($name + "_MPA")`;
        connectAttr -f ($mPATH + ".allCoordinates") ($name + $EXT +  ".translate");
       
       
        setAttr ($mPATH + ".u") ($path_value * ($i -1));
       
            if($i == ($num + 1))
            {
            setAttr ($mPATH + ".u") $pathMaxU;
            }
           
        CBdeleteConnection ($name + $EXT + ".tx");
        CBdeleteConnection ($name + $EXT + ".ty");
        CBdeleteConnection ($name + $EXT + ".tz");
       
        //delete $mPATH;
       
            if($i>1)
            {
            parent ($name + $EXT)  ($baseName + ($i-1)+$EXT);
            }
           
            if($i==($num))
            {
            select $names[0] ($name + $EXT) $curve;
            ikHandle -name ($baseName+"_IKH") -sol ikSplineSolver -ccv false
-pcv false;
            }
       
        }

return $names;
       
}

//========================
//========================
//========================


global proc colour_ctls()
{
string $list[] = `ls -sl`;

string $Lctls[] = `ls "*L_*ctrl"`;
string $Rctls[] = `ls "*R_*ctrl"`;

select "**ctrl";
select -d $Lctls $Rctls;
string $Cctls[] = `ls -sl`;


    for($item in $Lctls)
    {
    string $conns[] = `listConnections -p 1 ($item+".drawOverride")`;
   
    if(size($conns)>0)
    disconnectAttr $conns[0] ($item+".drawOverride");
   
    setAttr ($item+".overrideEnabled") 1;
    setAttr ($item+".overrideColor") 6;
    }
   
    for($item in $Rctls)
    {
    string $conns[] = `listConnections -p 1 ($item+".drawOverride")`;
   
    if(size($conns)>0)
    disconnectAttr $conns[0] ($item+".drawOverride");
    setAttr ($item+".overrideEnabled") 1;
    setAttr ($item+".overrideColor") 13;
    }

    for($item in $Cctls)
    {
    string $conns[] = `listConnections -p 1 ($item+".drawOverride")`;
   
    if(size($conns)>0)
    disconnectAttr $conns[0] ($item+".drawOverride");
    setAttr ($item+".overrideEnabled") 1;
    setAttr ($item+".overrideColor") 17;
    }

if(size($list))
select $list;

}


//========================
//========================
//========================

global proc string stretchy_chains(string $curve, string $joint[])
{

//===

string $jnt;
string $stretchAttr = ($curve + ".stretch");

for($i=0;$i<size($joint);$i++)
{

    if(`gmatch $joint[$i] "*_JNT"` == 1)
    {
    $jnt = `substring $joint[$i] 1 (size($joint[$i])-4)`;
    }
    else
    {
    $jnt = $joint[$i];
    }

//===

   
    if(`objExists ($curve + ".stretch")` == 0)
    {
    addAttr -ln stretch -at double  -min 0 -max 1 -dv 0 $curve;
    setAttr -e -keyable true ($curve + ".stretch");
    }
   
    float $cvs[] = `getAttr ($curve + ".cv[*]")`;
    $num = `getAttr ($curve + ".spans")`;
   
    $arcLengthNodes = `arcLengthDimension ($curve + ".u[" + $num + "]")`;
    setAttr ($arcLengthNodes +".uParamValue") 10000000;
    float $arcLength = `getAttr ($arcLengthNodes + ".arcLength")`;
   
   
    shadingNode -asUtility multiplyDivide -name ($jnt + ($i+1)+"_MUL");
    setAttr ($jnt + ($i+1)+"_MUL.operation") 2;
    connectAttr -f ($arcLengthNodes + ".arcLength") ($jnt +  ($i+1)+"_MUL.input1X");
    setAttr ($jnt + ($i+1)+"_MUL.input2X") $arcLength;
   
    shadingNode -asUtility plusMinusAverage -name ($jnt + ($i+1)+"_ADD");
    connectAttr -f ($jnt + ($i+1)+"_MUL.outputX") ($jnt +  ($i+1)+"_ADD.input1D[0]");
    setAttr ($jnt + ($i+1)+"_ADD.input1D[1]") 1;
    setAttr ($jnt + ($i+1)+"_ADD.operation") 2;
   
    shadingNode -asUtility multiplyDivide -name ($jnt + ($i+1)+"_2_MUL");
    connectAttr $stretchAttr ($jnt + ($i+1)+"_2_MUL.input1X");
    connectAttr ($jnt + ($i+1)+"_ADD.output1D") ($jnt +  ($i+1)+"_2_MUL.input2X");
   
    shadingNode -asUtility plusMinusAverage -name ($jnt +  ($i+1)+"_2_ADD");
    setAttr ($jnt + ($i+1)+"_2_ADD.input1D[0]") 1;
    connectAttr ($jnt + ($i+1)+"_2_MUL.outputX") ($jnt +  ($i+1)+"_2_ADD.input1D[1]");
   
    connectAttr ($jnt + ($i+1)+"_2_ADD.output1D") ($joint[$i] + ".sx");
    connectAttr ($jnt + ($i+1)+"_2_ADD.output1D") ($joint[$i] + ".sy");
    connectAttr ($jnt + ($i+1)+"_2_ADD.output1D") ($joint[$i] + ".sz");
   
    //===
   
    string $joints[] = `listRelatives -ad -type joint $joint[$i]`;
   
    for($i = 0; $i<size($joints);$i++)
    {
     catchQuiet(`connectAttr -f ($joint[$i] + ".s") ($joints[$i] + ".s")`);
    }   
   
}

    select -cl;
    print "DONE";
   
return $stretchAttr;

}



//======================================
//======================================
//======================================
//======================================

global proc string[] repeats()
{
string $all[] = `ls -type transform`;
string $repeats[];

for($item in $all)
{

if(`gmatch $item "*|*"`)
{
$repeats[size($repeats)] = $item;
}

}

return $repeats;
}



global proc cleanShapes()
{
string $all[] = `ls -type transform`;
string $shapes[];

    for($item in $all)
    {
    string $shape[] = `listRelatives -s -f $item`;
   
        if(`size($shape)` == 1)
        {
        if(`gmatch $shape[0] ($item+"Shape")`==0)
         catchQuiet(`rename $shape[0] ($item+"Shape")`);
        }
   
        if(`size($shape)` > 1)
        {
            for($i=0;$i<size($shape);$i++)
            {
             catchQuiet(`rename $shape[$i] ($item+"Shape"+($i+1))`);
            }
        }
    }
print "\nshapes renamed";
}


//======================================
//======================================
//======================================
//======================================

//=== usage
// auto_ctl
// type: (bone, handle, handle_triangle, triangle, circle)
// scale: how big the control
// vertical: negX, posX, negY, posY, negZ, posZ, vertical axis

global proc auto_ctl(string $type, float $scale, string $vertical)
{
string $ls[] = `ls -sl`;
string $name;
string $parent[];
string $nameParent;

    for($i=0;$i<size($ls);$i++)
    {
    $name = `substring $ls[$i] 1 (size($ls[$i])-4)`;
   
    $parent = `listRelatives -p $ls[$i]`;
   
    if($i>0)
    {
    $nameParent = `substring $parent[0] 1 (size($parent[0])-4)`;
    }
   
   
    file -import -type "mayaAscii"  -pr
"/hosts/guildford/user_data/ARCHIVE/FELIX/RIG/CNTRLS/cntrl.ma";
   
    if(`objExists "*cntrl_uiConfigurationScriptNode*"`)
    delete "*cntrl_uiConfigurationScriptNode*";
    if(`objExists "*cntrl_sceneConfigurationScriptNode*"`)
    delete "*cntrl_sceneConfigurationScriptNode*";
   
    select -r ctrlShape.cv[0:16] ;
    scale -r -p 0cm 0cm 0cm $scale $scale $scale ;
   
    delete rot_ctrl_LOC;
    changeShape ctrl $type $scale;
   
    if(`gmatch $vertical "posY"` == 1)
    {
    select ctrl.cv[0:"*"] ;
    rotate -r -p 0 0 0 -os 0 0 -90 ;
    }
   
    select $ls[$i] ctrl_LOC;
    delete `pointConstraint`;
    delete `orientConstraint`;
    select ctrl $ls[$i];
    pointConstraint -name ($name + "_POC");
    orientConstraint -name ($name + "_ORC");
    scaleConstraint -name ($name + "_SCC");
   
    string $list[] = `sets -q -no SEL`;
       
        for($item in $list)
        {
        rename $item ($name + "_" + $item);
        }
       
    delete SEL;
   
    string $jointType[] = `ls -st $ls[$i]`;
    if(`gmatch $jointType[1] "joint"` == 1)
    {
   
        if(size($parent) > 0)
        {
            if($i>0)
            {
            $jointType = `ls -st $parent[0]`;
       
                if(`gmatch $jointType[1] "joint"` == 1)
                {
                parent ($name + "_ctrl_LOC") ($nameParent+"_ctrl");
                }
            }
       
        }   
    }
   
    select $ls;
    }

}

//======================================
//======================================
//======================================
//======================================


global proc cleanNames()
{
string $list[] = `ls`;

    for($i=1;$i<size($list);$i++)
    {
        if($i>0)
        {
            if(`gmatch $list[$i] "*|*"`==1)
            {
            string $names[];
            string $name;
            $num = `tokenize $list[$i] "|" $names`;
            $name = $names[size($names)-1];
           
            string $Pnames[];
            string $Pname;
            $num = `tokenize $list[$i-1] "|" $Pnames`;
            $Pname = $Pnames[size($Pnames)-1];
       
                if(`gmatch $name $Pname`==1)
                {
                print ("\nrenaming "+$list[$i]+" into "+ $name+"_"+$i+"\n");
                 catchQuiet(`rename $list[$i] ($list[$i]+"_"+$i)`);
                }
            }
        }
    }
}

//======================================
//======================================
//======================================
//======================================


global proc switchDeformingMesh(string $old, string $new)
{

string $sjs[] = `listConnections -type fcStraightJacket
($old+"Shape")`;
string $wraps[] = `listConnections -type wrap ($old+"Shape")`;
string $sjDriven[];
float $radius[];
float $infl[];
float $dropoff[];
string $wrapDriven[];

    for($item in $sjs)
    {
    string $target[] = `listConnections ($item+".outputGeometry")`;
    $sjDriven[size($sjDriven)] = $target[0];
    float $rd = `getAttr ($item+".radius")`;
    float $inf = `getAttr ($item+".influences")`;
    float $dp = `getAttr ($item+".dropoff")`;
    $radius[size($radius)] = $rd;
    $infl[size($infl)] = $inf;
    $dropoff[size($dropoff)] = $dp;
    delete $item;
    }

    for($item in $wraps)
    {
    string $target[] = `listConnections ($item+".outputGeometry[0]")`;
    $wrapDriven[size($wrapDriven)] = $target[0];
        if(`objExists ($item+"Base")`)
        {
        delete ($item+"Base"); delete $item;
        }
        else
        {
        delete $item;
        }
    }

    for($i=0;$i<size($sjDriven);$i++)
    {
    fcStraightJacketCreate $new $sjDriven[$i]$radius[$i] $infl[$i]
$dropoff[$i];
    }

    for($i=0;$i<size($wrapDriven);$i++)
    {
    select $wrapDriven[$i] $new;
    CreateWrap;
    }

delete $old;

}


//======================================
//======================================
//======================================
//======================================



global proc switchDeformers(string $driven)
{

string $driver;
string $sjDriver[];
string $wrapDriver[];

string $sj[] = `listConnections -type fcStraightJacket
($driven+"Shape")`;
string $wrp[] = `listConnections -type wrap ($driven+"Shape.create")`;


if(size($sj)>0)
{
$sjDriver = `listConnections ($sj[0]+".drivers")`;
}

if(size($wrp)>0)
{
$wrapDriver = `listConnections ($wrp[0]+".driverPoints")`;
}

if(size($sjDriver)>0)
{
$driver = $sjDriver[0];
}

if(size($wrapDriver)>0)
{
$driver = $wrapDriver[0];
}

string $sjs[] = `listConnections -type fcStraightJacket
($driver+"Shape")`;
string $wraps[] = `listConnections -type wrap ($driver+"Shape")`;
string $sjDriven[];
float $radius[];
float $infl[];
float $dropoff[];
string $wrapDriven[];

    for($item in $sjs)
    {
    string $target[] = `listConnections ($item+".outputGeometry")`;
    $sjDriven[size($sjDriven)] = $target[0];
    float $rd = `getAttr ($item+".radius")`;
    float $inf = `getAttr ($item+".influences")`;
    float $dp = `getAttr ($item+".dropoff")`;
    $radius[size($radius)] = $rd;
    $infl[size($infl)] = $inf;
    $dropoff[size($dropoff)] = $dp;
    delete $item;
    }

    for($item in $wraps)
    {
    string $target[] = `listConnections ($item+".outputGeometry[0]")`;
    $wrapDriven[size($wrapDriven)] = $target[0];
   
    delete $item;
    }

    for($i=0;$i<size($sjDriven);$i++)
    {
    select $sjDriven[$i] $driver;
    CreateWrap;
    }

    for($i=0;$i<size($wrapDriven);$i++)
    {
    fcStraightJacketCreate $driver $wrapDriven[$i] 5 2 2;
    }

}

//==========================================
//==========================================
//==========================================
//==========================================

global proc string[] jointPerVertex(int $frequency)
{

string $ls[] = `ls -fl -sl`;
select -cl;
string $type[] = `ls -st $ls[0]`;
string $points[];
string $shapes[];
string $joints[];

    if(`gmatch $type[1] "float3"`)
    {
    $points = $ls;
    }
    else
    {
        for($item in $ls)
        {
        string $shape[] = `listRelatives -s $item`;
        $shapes[size($shapes)] = $shape[0];
        $points = `ls ($shape[0]+".vtx[*]")`;
        }

    }

    for($i=0;$i<size($points);$i+=$frequency)
    {
    float $trans[] = `xform -q -a -ws -t $points[$i]`;
    string $pluto[];
    tokenize $points[$i] "." $pluto;
    string $name = $pluto[0];
    joint -name ($name+"_"+($i+1)+"_JNT") -p $trans[0] $trans[1]
$trans[2];
    setAttr ($name+"_"+($i+1)+"_JNT.radius") 0.02;
    select -cl;
    $joints[size($joints)] = ($name+"_"+($i+1)+"_JNT");
    }
   
    skinCluster $joints $points;

return $joints;

}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


//=== 2004 felix balbas

source "generateChannelMenu.mel" ;

global proc creature_locs()
{

cycleCheck -e off;

//==== global variables

global string $FsRigPrefix;
global string $FsRigName;

//=== names

global string $rig_pref;
global string $rig_name;
global string $rig_prefix;
global string $prefixL;
global string $prefixR;

//=== modules

global int $hires;
global int $normal_spines;
global int $long_spines;
global int $long_necks;
global int $short_necks;
global int $heads;
global int $human_arms;
global int $human_legs;
global int $quadr_legs;
global int $human_feet;;
global int $one_finger_hands;
global int $two_finger_hands;
global int $three_finger_hands;
global int $four_finger_hands;
global int $five_finger_hands;
global int $bird_wings;
global int $bat_wings;
global int $tentacles;
global int $tails;
global int $fins;
global int $flippers;
global int $rig_type;
global int $quad_rig_type;
global int $bird_rig_type;
global int $rept_rig_type;
global int $doStretch;
global int $doToes;
global int $hiresSpine;
global int $hiresReptSpine;
global int $hiresHead;
global int $hiresQuadrLeg;
global int $hiresShortNeck;
global int $hiresLongNeck;
global int $hiresArm;
global int $hiresTentacle;
global int $hiresLeg;
global int $hiresFlipper;
global int $hiresFin;
global int $hires1FingHand;
global int $hiresBirdWing;
global int $hires2FingHand;
global int $hiresBatWing;
global int $hires3FingHand;
global int $hiresTail;
global int $hires4FingHand;
global int $hires5FingHand;

getGlobVar;

//==== end global variables

string $pr = $rig_prefix;

string $spineBasename = "spine";

string $sn_basename = "neck";
string $sn_name = "neck";

string $h_basename = "head";
string $h_name = "head";

string $le_basename = "leg";
string $le_name = "leg";

string $ar_basename = "arm";
string $ar_name = "arm";

string $ha_basename = "hand";
string $ha_name = "hand";


string $spinename;
string $spineLocs[];
string $neckname;
string $shortNeckLocs[];
string $spineRoot;
string $spineEnd;
string $longNeckLocs[];
string $headname;
string $neckName;
string $armname;
string $armName;
string $legname;
string $legName;
string $handname;
string $armName;
int $hands = $five_finger_hands + $four_finger_hands +  $three_finger_hands + $two_finger_hands + $one_finger_hands;
int $fingers ;
string $fingerName;

string $foo_basename = "foot";
string $foo_name = "foot";
string $footname;
string $footName;

string $tentbasename = "tentacle";
string $tentname = "tentacle";
string $tentaclename;

string $tabasename = "tail";
string $taname = "tail";
string $tailname;

string $finbasename = "fin";
string $finname = "fin";
string $finname;

string $flipbasename = "flipper";
string $flipname = "flipper";
string $flippername;

//=== special cases arms


if($rig_type == 2)
{
$ar_basename = "leg";
$ar_name = "leg";

    if($quad_rig_type == 1)
    {
    $ha_basename = "hoof";
    $ha_name = "hoof";
    }
   
    if($quad_rig_type == 2)
    {
    $ha_basename = "paw";
    $ha_name = "paw";
    }
}

if($rig_type == 3)
{
$ar_basename = "wing";
$ar_name = "wing";
}

//===


if($rig_type == 2)
{
$fingerName = "toe";
}
else
{
$fingerName = "finger";
}

//=== end creature variables

//============================================================================================
//========================================== RIGS ============================================
//============================================================================================


//=== spines


for($i = 0; $i < $normal_spines; $i++)
{
        if($normal_spines > 1)
        {   
   
            if(!($i%2))
            {
            $pr = $prefixL;
            }
            else
            {
            $pr = $prefixR;
            }
        }
        else
        {
        $pr = ($rig_prefix + "M_");
        }

$spinename = ($pr + $spineBasename);

$spineLocs = `desp_spine $spinename`;

if($rig_type == 2)
{
setAttr ($spinename + "_hip_PIV.ty") -10;
setAttr ($spinename + "_lumbar_PIV.ty") 0;
}

if($rig_type == 3)
{
setAttr ($spinename + "_hip_PIV.ty") -10;
setAttr ($spinename + "_lumbar_PIV.ty") 0;
setAttr ($spinename + "_GRP.rz") -90;
}

}


for($i = 0; $i < $long_spines; $i++)
{
        if($long_spines > 1)
        {   
   
            if(!($i%2))
            {
            $pr = $prefixL;
            }
            else
            {
            $pr = $prefixR;
            }
        }
        else
        {
        $pr = ($rig_prefix + "M_");
        }

$spinename = ($pr + $spineBasename);
$spineLocs = `long_spine $spinename`;


}

//=== end spines

//===========================================================


//=== necks

if(size($spineLocs) == 0)
{
$spineRoot = $spineLocs[0];
$spineEnd = $spineLocs[1];
}
else
{
$spineRoot = $spineLocs[0];
$spineEnd = $spineLocs[1];
}

for($i = 0; $i < $short_necks; $i++)
{

        if($short_necks > 1)
        {   
            if(!($i%2))
            {
            $pr = $prefixL;
            }
            else
            {
            $pr = $prefixR;
            }
        }
        else
        {
        $pr = ($rig_prefix + "M_");
        }

    if($i > 1)
    {
    $sn_name = ($sn_basename + ($i/2));
    }
    else
    {
    $sn_name = $sn_basename;
    }
   
    $neckname = ($pr + $sn_name);
   
$shortNeckLocs = `short_neck $neckname`;

    if(`objExists ($spineEnd)`)
    {
    parent ($neckname + "_GRP") ($rig_prefix + "M_spine_GRP");
    select $spineEnd ($neckname + "_GRP");
    delete `pointConstraint`;
    delete `orientConstraint`;
    select $spineEnd ($neckname + "_GRP");
    parentConstraint -name ($neckname + "_grp_PAC");
   
        string $listuu[] = `ls ($rig_prefix + "*LOC")`;
        string $utem;
        for($utem in $listuu)
        {
        setAttr ($utem + ".v") 0;
        }
   
    if($rig_type == 2)
    {
    setAttr ($neckname + "_2_PIV.t") 0 6.7 -2.4;
    }
   
    }
select -cl;
}

//=== long neck


for($i = 0; $i < $long_necks; $i++)
{

        if($long_necks > 1)
        {   
            if(!($i%2))
            {
            $pr = $prefixL;
            }
            else
            {
            $pr = $prefixR;
            }
        }
        else
        {
        $pr = ($rig_prefix + "M_");
        }

    if($i > 1)
    {
    $sn_name = ($sn_basename + ($i/2));
    }
    else
    {
    $sn_name = $sn_basename;
    }
   
    $neckname = ($pr + $sn_name);
   
$longNeckLocs = `long_neck $neckname`;

    if(`objExists ($spineEnd)`)
    {
    parent ($neckname + "_GRP") ($rig_prefix + "M_spine_GRP");
    select $spineEnd ($neckname + "_GRP");
    delete `pointConstraint`;
    //delete `orientConstraint`;
    select ($rig_prefix + "M_spine_GRP") ($neckname + "_GRP");
    delete `orientConstraint`;
    select $spineEnd ($neckname + "_GRP");
    parentConstraint -mo -name ($neckname + "_grp_PAC");
        select ($rig_prefix + "*LOC");
        string $listuu[] = `ls -sl`;
        string $utem;
        for($utem in $listuu)
        {
        setAttr ($utem + ".v") 0;
        }
    }

select -cl;
}

//===========================================================

//=== heads

for($i = 0; $i < $heads; $i++)
{
   
        if($heads > 1)
        {   
   
            if(!($i%2))
            {
            $pr = $prefixL;
            }
            else
            {
            $pr = $prefixR;
            }
        }
        else
        {
        $pr = ($rig_prefix + "M_");
        }

    if($i > 1)
    {
    $h_name = ($h_basename + ($i/2));
    }
    else
    {
    $h_name = $h_basename;
    }
   
    $headname = ($pr + $h_name + "_");
   
head $headname;

$neckName = ($pr + "neck" + substring($h_name,5,(size($h_name))) +  "_");

   
    if(`objExists $spineEnd`)
    {
    parent ($headname + "GRP") ($rig_prefix + "M_spine_GRP");
    select $spineEnd ($headname + "PIV");
    copyTrans;
    select $spineEnd ($headname + "GRP");
    parentConstraint -name ($headname + "grp_PAC");
    }
   
    if(`objExists ($neckName + "GRP")`)
    {
   
        if(`objExists ($neckName + "head_PIV")`)
        {
        select ($neckName + "head_PIV")  ($headname + "PIV");
        copyTrans;
        select ($headname + "PIV") ($neckName + "head_PIV");
        pointConstraint -name ($neckName + "head_piv_POC");
        setAttr ($neckName + "head_PIV.v") 0;
        select -d;
        }
        else
        {
        select ($neckName + "end_PIV") ($headname + "PIV");
        copyTrans;
        select ($headname + "PIV") ($neckName + "end_PIV");
        pointConstraint -name ($neckName + "end_piv_POC");
        setAttr ($neckName + "end_PIV.v") 0;
        select -cl;
        }
    }
   
    if($rig_type == 2)
    {
    setAttr ($headname + "PIV.t") 0 30 -10;
    setAttr ($headname + "PIV.r") -70 0 0;
    }
   
        if(($i%2) == 1)
        {
        simmetry $h_name;
        }

select -cl;
}
   
//===========================================================

//=== arms

string $ar_basename = "arm";
string $ar_name = "arm";
string $armname;
string $pr;
string $armName;

if($rig_type == 2)
{
$ar_basename = "leg";
$ar_name = "leg";
}

if($rig_type == 3)
{
$ar_basename = "wing";
$ar_name = "wing";
}

for($i = 0; $i < $human_arms; $i++)
{

    if($rig_type == 3)
    {
        if($i>1)
        {
        $ar_basename = "leg";
        $ar_name = "leg";
        }
    }

        if($human_arms > 1)
        {   
   
            if(!($i%2))
            {
            $pr = $prefixL;
            }
            else
            {
            $pr = $prefixR;
            }
        }
        else
        {
        $pr = $rig_prefix;
        }

if($rig_type == 2)
{
    if($i > 1)
    {
    $ar_name = ($ar_basename + "_b");
    }
    else
    {
    $ar_name = ($ar_basename + "_f");
    }
}
else
{
    if($i > 1)
    {
        if($rig_type == 3)
        {
        $ar_name = $ar_basename;
        }
        else
        {   
        $ar_name = ($ar_basename + ($i/2));
        }
    }
    else
    {
    $ar_name = $ar_basename;
    }
}
   
    $armname = ($pr + $ar_name + "_");
   
arm $armname;

$spinename = ($rig_prefix + "M_spine_");

string $spineEnd;
string $spineHip;
string $spineClav;

if(`objExists ($rig_prefix + "M_spine_GRP")`)
{
parent ($armname + "GRP") ($spinename + "GRP");
}

if(`objExists ($spinename + "end_PIV")`)
{
$spineEnd = ($spinename + "end_PIV");
}
if(`objExists ($spinename + "end_LOC")`)
{
$spineEnd = ($spinename + "end_LOC");
}

if(`objExists ($spinename + "hip_PIV")`)
{
$spineHip = ($spinename + "hip_PIV");
}

if(`objExists ($spinename + "hip_LOC")`)
{
$spineHip = ($spinename + "hip_LOC");
}

if(`objExists ($spinename + "clav_PIV")`)
{
$spineClav = ($spinename + "clav_PIV");
}

if($rig_type == 1)
{
}


if($rig_type == 2)
{
        if($i<2)
        {
            if($rig_type == 2)
            {
            }
        }
       
        if($i>1)
        {
        }
       
        if(($i%2) == 1)
        {
        simmetry $ar_name;
        }
}
else
{

    if($rig_type == 3)
    {
            if($i>1)
            {
            }
            else
            {
            }
    }
    else
    {
    }
}

        if(($i%2) == 1)
        {
        simmetry $ar_name;
        }


select -cl;
}

//=== end arms


//===========================================================


//=== hands

string $ha_basename = "hand";
string $ha_name = "hand";
string $handname;
string $pr;
string $armName;
int $hands = $five_finger_hands + $four_finger_hands +  $three_finger_hands + $two_finger_hands + $one_finger_hands;
int $fingers ;
string $currentFingers[];

if($rig_type == 2)
{
$ar_basename = "leg";
$ar_name = "leg";

    if($quad_rig_type == 1)
    {
    $ha_basename = "hoof";
    $ha_name = "hoof";
    }
   
    if($quad_rig_type == 2)
    {
    $ha_basename = "paw";
    $ha_name = "paw";
    }
}


//===



if($one_finger_hands > 0)
{
    for($i = 0; $i < $one_finger_hands; $i++)
    {
    $currentFingers[size($currentFingers)] = "one";
    }
}

if($two_finger_hands > 0)
{
    for($i = 0; $i < $two_finger_hands; $i++)
    {
    $currentFingers[size($currentFingers)] = "two";
    }
}

if($three_finger_hands > 0)
{
    for($i = 0; $i < $three_finger_hands; $i++)
    {
    $currentFingers[size($currentFingers)] = "three";
    }
}

if($four_finger_hands > 0)
{
    for($i = 0; $i < $four_finger_hands; $i++)
    {
    $currentFingers[size($currentFingers)] = "four";
    }
}

if($five_finger_hands > 0)
{

    for($i = 0; $i < $five_finger_hands; $i++)
    {
    $currentFingers[size($currentFingers)] = "five";
    }
}


for($i = 0; $i < $hands; $i++)
{

if(`gmatch $currentFingers[$i] "one"`)
{
$fingers = 1;
}
if(`gmatch $currentFingers[$i] "two"`)
{
$fingers = 2;
}
if(`gmatch $currentFingers[$i] "three"`)
{
$fingers = 3;
}
if(`gmatch $currentFingers[$i] "four"`)
{
$fingers = 4;
}
if(`gmatch $currentFingers[$i] "five"`)
{
$fingers = 5;
}

        if($hands > 1)
        {   
   
            if(!($i%2))
            {
            $pr = $prefixL;
            }
            else
            {
            $pr = $prefixR;
            }
        }
        else
        {
        $pr = $rig_prefix;
        }

if($rig_type == 2)
{
    if($i > 1)
    {
    $ha_name = ($ha_basename + "_b");
    }
    else
    {
    $ha_name = ($ha_basename + "_f");
    }
}
else
{

        if($rig_type == 3)
        {
            if($i < 2)
            {
            $ar_basename = "wing";
            $ar_name = "wing";
            $ha_basename = "hand";
            $ha_name = "hand";
            }
            else
            {
            $ar_basename = "leg";
            $ar_name = "leg";
            $ha_basename = "foot";
            $ha_name = "foot";
            }
           
        }

    if($i > 1)
    {
        if($rig_type == 3)
        {
        $ha_name = $ha_basename;
        }
        else
        {
        $ha_name = ($ha_basename + ($i/2));
        }
    }
    else
    {
    $ha_name = $ha_basename;
    }
}   
    $handname = ($pr + $ha_name + "_");


int $numerillo = 5;

if(`gmatch $ha_name "*_b*"` == 1)
{
$numerillo = 4;
}
if(`gmatch $ha_name "*_f*"` == 1)
{
$numerillo = 4;
}
if(`size($ha_name)` == 3)
{
$numerillo = 4;
}
if(`gmatch $ha_name "*hoof*"` == 1)
{
$numerillo = 5;
}

$armName = ($pr + $ar_basename +  substring($ha_name,$numerillo,(size($ha_name))) + "_");

string $armEnd;

if(`objExists ($armName + "end_PIV")`)
{
$armEnd = ($armName + "end_PIV");
}

if(`objExists ($armName + "end_JNT")`)
{
$armEnd = ($armName + "end_JNT");
}

if(`gmatch $ar_name "*leg*"` == 1)
{
$fingerName = "toe";
}
else
{
$fingerName = "finger";
}

if($rig_type == 2)
{

        hand $handname $armName $fingers;       

            if(`objExists ($armName + "GRP")`)
            {
            select $armEnd ($handname + "GRP");
            copyT;
            select $armEnd ($handname + "PIV");
            pointConstraint -name ($handname + "piv_POC");
            scaleConstraint -mo -name ($handname + "piv_SAC");
            
            setAttr ($handname + $fingerName + "1_PIV.tx") -10;
            if(`objExists ($handname + $fingerName + "2_PIV")`)
            {
            setAttr ($handname + $fingerName + "2_PIV.tx") -10;
            }
            if(`objExists ($handname + $fingerName + "3_PIV")`)
            {
            setAttr ($handname + $fingerName + "3_PIV.tx") -10;
            }
            if(`objExists ($handname + $fingerName + "4_PIV")`)
            {
            setAttr ($handname + $fingerName + "4_PIV.tx") -10;
            }
           
                if($quad_rig_type == 1)
                {
                setAttr ($handname + $fingerName + "1_PIV.t") 0 0 0;
                }
                else
                {
                    if(`gmatch $armEnd "*_L_*"` == 1)
                    {
                    catchQuiet(`setAttr ($armEnd + ".r") -90 -10  90`);
                    }
                }
               
            select -cl;
            }
}
else
{

hand $handname $armName $fingers;

    if(`objExists ($armName + "GRP")`)
    {
   
        if($rig_type == 3)
        {
            if(`gmatch $armName "*wing*"` ==1)
            {
            setAttr ($handname + $fingerName + "2_PIV.r") 90 -75 -90;   
            setAttr ($handname + $fingerName + "2_PIV.t") 0 -2 0;   
            setAttr ($handname + $fingerName + "2a_PIV.r") 0 0 -25;   
            setAttr ($handname + $fingerName + "2a_PIV.t") 0 -14 0;   
            setAttr ($handname + $fingerName + "2b_PIV.r") 0 0 -25;   
            setAttr ($handname + $fingerName + "2b_PIV.t") 0 -14 0;   
            setAttr ($handname + $fingerName + "2c_PIV.r") 0 0 -25;   
            setAttr ($handname + $fingerName + "2c_PIV.t") 0 -14 0;

            select $armEnd ($handname + "GRP");
            copyT;
            select $armEnd ($handname + "PIV");
            pointConstraint -name ($handname + "piv_POC");
            orientConstraint -name ($handname + "piv_ORC");
            scaleConstraint -name ($handname + "piv_SAC");
            select -cl;
            }
            else
            {
            setAttr ($handname + "PIV.r") 0 0 0;
            select $armEnd ($handname + "PIV");
            pointConstraint -name ($handname + "piv_POC");
            orientConstraint -mo -name ($handname + "piv_ORC");
            scaleConstraint -name ($handname + "piv_SAC");
            setAttr ($handname + $fingerName + "1_PIV.t") 0 3 0;
            setAttr ($handname + $fingerName + "1_PIV.r") -180 0 0;
            setAttr ($handname + $fingerName + "2_PIV.t") 0 -3 1;
            setAttr ($handname + $fingerName + "2_PIV.r") -10 0 0;
            setAttr ($handname + $fingerName + "2_PIV.s") 1 1.5 1;
            setAttr ($handname + $fingerName + "3_PIV.t") 0 -3 0;
            setAttr ($handname + $fingerName + "3_PIV.r") 0 0 0;
            setAttr ($handname + $fingerName + "3_PIV.s") 1 1.5 1;
            setAttr ($handname + $fingerName + "4_PIV.t") 0 -3 -1;
            setAttr ($handname + $fingerName + "4_PIV.r") 10 0 0;
            setAttr ($handname + $fingerName + "4_PIV.s") 1 1.5 1;
            select -cl;
            }
        }
        else
        {
            select $armEnd ($handname + "GRP");
            copyT;
            select $armEnd ($handname + "PIV");
            pointConstraint -name ($handname + "piv_POC");
            orientConstraint -name ($handname + "piv_ORC");
            scaleConstraint -mo -name ($handname + "piv_SAC");
            //parent ($handname + "PIV") $armEnd;

            select -cl;
        }
    }
}




    if(`objExists ($rig_prefix + "M_spine_GRP")`)
    {
    parent ($handname + "GRP") ($rig_prefix + "M_spine_GRP");
    }

   
    if(($i%2) == 1)
    {

    simmetry $ha_name;
    select -cl;
       
    }

select -cl;
}

//=== end hands


//===========================================================
//===========================================================
//===========================================================

//=== legs

for($i = 0; $i < $human_legs; $i++)
{
   
        if($human_legs > 1)
        {   
   
            if(!($i%2))
            {
            $pr = $prefixL;
            }
            else
            {
            $pr = $prefixR;
            }
        }
        else
        {
        $pr = ($rig_prefix + "M_");
        }

    if($i > 1)
    {
    $le_name = ($le_basename + ($i/2));
    }
    else
    {
    $le_name = $le_basename;
    }
   
    $legname = ($pr + $le_name + "_");
   
leg $legname human;


$spinename = ($rig_prefix + "M_spine_");
string $hipPIV;

    if(`objExists ($spinename + "GRP")`)
    {
    $hipPIV = ($spinename + "hip_PIV");
    }

    if(`objExists $hipPIV`)
    {
    parent ($legname + "GRP") $hipPIV;
    select $hipPIV ($legname + "torso_PIV"); delete `parentConstraint`;
    parent ($legname + "torso_PIV") $hipPIV;
    }

    if($rig_type == 2)
    {
    setAttr ($legname + "root_PIV.rotateX") -90;
    }

    if(`objExists ($rig_prefix + "M_spine_GRP")`)
    {
    parent ($legname + "GRP") ($rig_prefix + "M_spine_GRP");
    }

    if(($i%2) == 1)
    {
    simmetry $le_name;
    }
        
print "legs done";
select -cl;
}

//=== end legs


//===========================================================
//===========================================================
//===========================================================


//=== feet


for($i = 0; $i < $human_feet; $i++)
{
   
        if($human_feet > 1)
        {   
   
            if(!($i%2))
            {
            $pr = $prefixL;
            }
            else
            {
            $pr = $prefixR;
            }
        }
        else
        {
        $pr = ($rig_prefix + "M_");
        }

    if($i > 1)
    {
    $foo_name = ($foo_basename + ($i/2));
    }
    else
    {
    $foo_name = $foo_basename;
    }
   
    $footname = ($pr + $foo_name + "_");



if(`gmatch $foo_name "foot"` == 1)
{
$legName = ($pr + "leg_");
}
else
{
$legName = ($pr + "leg" + substring($foo_name,5,(size($foo_name))) +  "_");
}

    if($doToes > 0)
    {
    hand $footname $legName $fingers;

            if(`objExists ($legName + "GRP")`)
            {
            select ($legName + "end_PIV") ($footname + "GRP");
            copyT;
            select ($legName + "end_PIV") ($footname + "PIV");
            pointConstraint -name ($footname + "piv_POC");
            orientConstraint -mo -name ($footname + "piv_ORC");
            scaleConstraint -name ($footname + "piv_SCC");
                if(`gmatch $legName "*_L_*"` == 1)
                {
                setAttr ($legName + "end_PIV.s") .7 .7 .7;
                }
            select -cl;
            }




        if(`objExists ($rig_prefix + "M_spine_GRP")`)
        {
        parent ($footname + "GRP") ($rig_prefix + "M_spine_GRP");
        }
       
    if(($i%2) == 1)
    {

        simmetry $foo_name;
        select -cl;
       
    }

    select -cl;

    }
    else
    {
    foot $footname ($legName + "end_PIV");


    select ($legName + "end_PIV") ($footname + "GRP");
    parentConstraint -name ($footname + "grp_PAC");
    select ($legName + "end_PIV") ($footname + "root_PIV");
    parentConstraint -name ($footname + "root_piv_PAC");
    setAttr  ($footname + "root_PIVShape.lodVisibility") 0;
               
        if(`gmatch $legName "*_L_*"` == 1)
        {
        //setAttr ($footname + "toe1_PIV.t") 0 -1 8;
        //setAttr ($footname + "toe1_PIV.r") -90 0 0;
        }
    select -cl;

            if(`objExists ($rig_prefix + "M_spine_GRP")`)
            {
            parent ($footname + "GRP") ($rig_prefix + "M_spine_GRP");
            }


        if(($i%2) == 1)
        {
        simmetry $foo_name;
        }
    select -cl;
    }
}

//=== end feet

//===========================================================

//=== tentacles

for($i = 0; $i < $tentacles; $i++)
{
        if($tentacles > 1)
        {   
   
            if(!($i%2))
            {
            $pr = $prefixL;
            }
            else
            {
            $pr = $prefixR;
            }
        }
        else
        {
        $pr = ($rig_prefix + "M_");
        }

    if($i > 1)
    {
    $tentname = ($tentbasename + ($i/2));
    }
    else
    {
    $tentname = $tentbasename;
    }

    $tentaclename = ($pr + $tentname);


tentacle $tentaclename;
//setAttr ($tentaclename + "_GRP.rx") 180;




    if(`objExists ($rig_prefix + "M_spine_GRP")`)
    {
    parent ($tentaclename + "_GRP") ($rig_prefix + "M_spine_GRP");
    }
        if(($i%2) == 1)
        {
        simmetry $tentname;
        setAttr ($tentaclename + "_GRP.template") 1;
        }

}

//=== end tentacles

//===========================================================



//===========================================================

//=== tails

for($i = 0; $i < $tails; $i++)
{
        if($tails > 1)
        {   
   
            if(!($i%2))
            {
            $pr = $prefixL;
            }
            else
            {
            $pr = $prefixR;
            }
        }
        else
        {
        $pr = ($rig_prefix + "M_");
        }

    if($i > 1)
    {
    $taname = ($tabasename + ($i/2));
    }
    else
    {
    $taname = $tabasename;
    }

    $tailname = ($pr + $taname);


tail $tailname;



    if(`objExists ($rig_prefix + "M_spine_GRP")`)
    {
    parent ($tailname + "_GRP") ($rig_prefix + "M_spine_GRP");
   
        if($tails > 1)
        {
        setAttr ($tailname + "_GRP.r") (5*$i) 0 0;
        select ($spinename + "hip_PIV") ($tailname + "_GRP");
        delete `pointConstraint`;
        }
        else
        {
        setAttr ($tailname + "_GRP.r") 0 0 0;
        select ($spinename + "hip_PIV") ($tailname + "_GRP");
        delete `pointConstraint`;
        }
           
    select -cl;

    }
   
        if(($i%2) == 1)
        {
        simmetry $taname;
        setAttr ($tailname + "_GRP.template") 1;
        }

}

//=== end tails

//===========================================================

//=== fins

for($i = 0; $i < $fins; $i++)
{
        if($fins > 1)
        {   
   
            if(!($i%2))
            {
            $pr = $prefixL;
            }
            else
            {
            $pr = $prefixR;
            }
        }
        else
        {
        $pr = ($rig_prefix + "M_");
        }

    if($i > 1)
    {
    $finname = ($finbasename + ($i/2));
    }
    else
    {
    $finname = $finbasename;
    }

    $finname = ($pr + $finname);


fin $finname;
//setAttr ($finname + "_GRP.rx") 180;




    if(`objExists ($rig_prefix + "M_spine_GRP")`)
    {
    parent ($finname + "_GRP") ($rig_prefix + "M_spine_GRP");
    }

        if(($i%2) == 1)
        {
        simmetry $finname;
        setAttr ($finname + "_GRP.template") 1;
        }
}

//=== end fins


//=== flippers

for($i = 0; $i < $flippers; $i++)
{
        if($flippers > 1)
        {   
   
            if(!($i%2))
            {
            $pr = $prefixL;
            }
            else
            {
            $pr = $prefixR;
            }
        }
        else
        {
        $pr = ($rig_prefix + "M_");
        }

    if($i > 1)
    {
    $flipname = ($flipbasename + ($i/2));
    }
    else
    {
    $flipname = $flipbasename;
    }

    $flippername = ($pr + $flipname);


flipper $flippername;




    if(`objExists ($rig_prefix + "M_spine_GRP")`)
    {
    parent ($flippername + "_GRP") ($rig_prefix + "M_spine_GRP");
    }
        if(($i%2) == 1)
        {
        simmetry $flipname;
        setAttr ($flippername + "_GRP.template") 1;
        }

}

//=== end flippers

//===========================================================





















//=== cleanup

//=== groups

if(`objExists ($rig_prefix + "M_spine_GRP")`)
{

    if(`objExists ($rig_prefix + "dont_GRP")`)
    {
    // catchQuiet(`parent "*locs_GRP" "*no_trans_GRP" ($rig_prefix +  "dont_GRP")`);
    }
    else
    {
    //group -name ($rig_prefix + "dont_GRP") "*locs_GRP" "*no_trans_GRP";
    group -name ($rig_prefix + "dont_GRP") "*no_trans_GRP";
     
    setAttr -lock true -keyable false ($rig_prefix + "dont_GRP.tx");
    setAttr -lock true -keyable false ($rig_prefix + "dont_GRP.ty");
    setAttr -lock true -keyable false ($rig_prefix + "dont_GRP.tz");
    setAttr -lock true -keyable false ($rig_prefix + "dont_GRP.rx");
    setAttr -lock true -keyable false ($rig_prefix + "dont_GRP.ry");
    setAttr -lock true -keyable false ($rig_prefix + "dont_GRP.rz");
    setAttr -lock true -keyable false ($rig_prefix + "dont_GRP.sx");
    setAttr -lock true -keyable false ($rig_prefix + "dont_GRP.sy");
    setAttr -lock true -keyable false ($rig_prefix + "dont_GRP.sz");
    setAttr -lock true -keyable false ($rig_prefix + "dont_GRP.v");
    }
}

//=== selection sets


//=== readwrite_SEL

select -cl;

if(`objExists "*rw_SEL"`)
{
select "*rw_SEL";
if(`objExists ($rig_prefix + "rw_SEL")` == 0)
{
sets -n ($rig_prefix + "rw_SEL");
}
select -ne "*rw_SEL";
select -d -ne ($rig_prefix + "rw_SEL");
delete;
select -cl;
}

if(`objExists "*rw_SEL"`)
{   
    if(`objExists "*_R_*rw_SEL"`)
    {
    select "*R*rw_SEL";
    string $Rsel[] = `ls -sl`;
        for($i = 0;$i < size($Rsel);$i++)
        {
        setAttr ($Rsel[$i] + ".v") 0;
        }
    }
}

if(`objExists ($rig_prefix + "R_*")`)
{
select ($rig_prefix + "R_*");
sets -rm ($rig_prefix + "rw_SEL");
}

//=== end readwrite_SEL

//=== delete_SEL

select -cl;

if(`objExists "*del_SEL"`)
{
select "*del_SEL";
if(`objExists ($rig_prefix + "del_SEL")` == 0)
{
sets -n ($rig_prefix + "del_SEL");
}
select -ne "*del_SEL";
select -d -ne ($rig_prefix + "del_SEL");
delete;
select -cl;
}


//=== end delete_SEL

//=== //print infos into the rig

if(`objExists "*ROOT"` == 0)
{
$poop = `CreateEmptyGroup`;
rename $poop ($rig_prefix + $rig_name);

addAttr -ln "version" -dt "string" ($rig_prefix + $rig_name);
addAttr -ln "prefix" -dt "string" ($rig_prefix + $rig_name);
addAttr -ln "name" -dt "string" ($rig_prefix + $rig_name);
addAttr -ln "locs" -dt "string"  ($rig_prefix + $rig_name);
addAttr -ln "env" -dt "string"  ($rig_prefix + $rig_name);

if($hires == 1)
{
setAttr -type "string" ($rig_prefix + $rig_name + ".version") "hires";
}
else
{
setAttr -type "string" ($rig_prefix + $rig_name + ".version") "lores";
}

setAttr -type "string" ($rig_prefix + $rig_name + ".prefix") $rig_pref;
setAttr -type "string" ($rig_prefix + $rig_name + ".name") $rig_name;
setAttr -e -lock true ($rig_prefix + $rig_name + ".name");

//=== end //print infos into the rig

setAttr -e -keyable false ($rig_prefix + $rig_name + ".tx");
setAttr -e -keyable false ($rig_prefix + $rig_name + ".ty");
setAttr -e -keyable false ($rig_prefix + $rig_name + ".tz");
setAttr -e -keyable false ($rig_prefix + $rig_name + ".rx");
setAttr -e -keyable false ($rig_prefix + $rig_name + ".ry");
setAttr -e -keyable false ($rig_prefix + $rig_name + ".rz");
setAttr -e -keyable false ($rig_prefix + $rig_name + ".sx");
setAttr -e -keyable false ($rig_prefix + $rig_name + ".sy");
setAttr -e -keyable false ($rig_prefix + $rig_name + ".sz");
setAttr -e -keyable false ($rig_prefix + $rig_name + ".nodeState");

setAttr -l true ($rig_prefix + $rig_name + ".tx");
setAttr -l true ($rig_prefix + $rig_name + ".ty");
setAttr -l true ($rig_prefix + $rig_name + ".tz");
setAttr -l true ($rig_prefix + $rig_name + ".rx");
setAttr -l true ($rig_prefix + $rig_name + ".ry");
setAttr -l true ($rig_prefix + $rig_name + ".rz");
setAttr -l true ($rig_prefix + $rig_name + ".sx");
setAttr -l true ($rig_prefix + $rig_name + ".sy");
setAttr -l true ($rig_prefix + $rig_name + ".sz");
setAttr -l true ($rig_prefix + $rig_name + ".nodeState");
}


if(`objExists "*ctrl"` == 0)
{
    string $slit[] = `ls "*upv*CLS" "*LOC"`;
    for($i = 0; $i < size($slit); $i++)
    {
    catchQuiet(`setAttr ($slit[$i] + ".v") 0`);
    }

    string $slit[] = `ls "*PIVShape"`;
    for($i = 0; $i < size($slit); $i++)
    {
    catchQuiet(`setAttr ($slit[$i] + ".overrideColor") 16`);
    catchQuiet(`setAttr ($slit[$i] + ".overrideEnabled") 1`);
    }
}


select -cl;

//print "locs done OK";


}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



//=== 2004 Felix Balbas


source "generateChannelMenu.mel" ;

//fcConstraint;
//fcdbDisableWarnings;

///===================procs


proc cleanConstraint(string $c)
{
string $attr = ".constraintTranslate";
if(nodeType($c) == "aimConstraint" || nodeType($c) ==
"orientConstraint")
    $attr = ".constraintRotate";

if(nodeType($c) == "scaleConstraint")
    $attr = ".constraintScale";
     
  string $plug =  $c +$attr;

    if(`objExists $plug`)
    {
    dgeval  $plug;
    dgdirty $plug;
    }
}

//================================================================
//================================================================
//================================================================
//================================================================
//================================================================
//================================================================

global proc string do_spine()
{

//==== global variables

//=== names

global string $rig_pref;
global string $rig_name;
global string $rig_prefix;
global string $prefixL;
global string $prefixR;
global string $rig_dir;

//=== modules

global int $hires;
global int $normal_spines;
global int $long_spines;
global int $long_necks;
global int $short_necks;
global int $heads;
global int $human_arms;
global int $human_legs;
global int $quadr_legs;
global int $human_feet;;
global int $one_finger_hands;
global int $two_finger_hands;
global int $three_finger_hands;
global int $four_finger_hands;
global int $five_finger_hands;
global int $bird_wings;
global int $bat_wings;
global int $tentacles;
global int $tails;
global int $fins;
global int $flippers;
global int $hiresSpine;
global int $hiresReptSpine;
global int $hiresHead;
global int $hiresQuadrLeg;
global int $hiresShortNeck;
global int $hiresLongNeck;
global int $hiresArm;
global int $hiresTentacle;
global int $hiresLeg;
global int $hiresFlipper;
global int $hiresFin;
global int $hires1FingHand;
global int $hiresBirdWing;
global int $hires2FingHand;
global int $hiresBatWing;
global int $hires3FingHand;
global int $hiresTail;
global int $hires4FingHand;
global int $hires5FingHand;

//==== end global variables

getGlobVar ;

string $spinebasename = "spine";
string $spinename = "spine";
string $spinename;
string $pr;
string $spineNodes[];
int $spinesNum = ($normal_spines + $long_spines);


for($i = 0; $i < $normal_spines; $i++)
{
        if($normal_spines > 1)
        {   
   
            if(!($i%2))
            {
            $pr = $prefixL;
            }
            else
            {
            $pr = $prefixR;
            }
        }
        else
        {
        $pr = ($rig_prefix + "M_");
        }

    if($i > 1)
    {
    $spinename = ($spinebasename + ($i/2));
    }
    else
    {
    $spinename = $spinebasename;
    }
   
        if(`objExists ($spinename + "end_LOC")`)
        {
        ////print "\nDONE\n";
        }
        else
        {
        $spinename = ($pr + $spinename);
        showHidden -all;
        normal_spine_rig $spinename;
        }
   
}

return $spinename;

}

//====================================================================
//====================================================================
//====================================================================
//====================================================================

global proc string[] do_short_neck()
{

//==== global variables

//=== names

global string $rig_pref;
global string $rig_name;
global string $rig_prefix;
global string $prefixL;
global string $prefixR;
global string $rig_dir;

//=== modules

global int $hires;
global int $normal_spines;
global int $long_spines;
global int $long_necks;
global int $short_necks;
global int $heads;
global int $human_arms;
global int $human_legs;
global int $quadr_legs;
global int $human_feet;;
global int $one_finger_hands;
global int $two_finger_hands;
global int $three_finger_hands;
global int $four_finger_hands;
global int $five_finger_hands;
global int $bird_wings;
global int $bat_wings;
global int $tentacles;
global int $tails;
global int $fins;
global int $flippers;
global int $hiresSpine;
global int $hiresReptSpine;
global int $hiresHead;
global int $hiresQuadrLeg;
global int $hiresShortNeck;
global int $hiresLongNeck;
global int $hiresArm;
global int $hiresTentacle;
global int $hiresLeg;
global int $hiresFlipper;
global int $hiresFin;
global int $hires1FingHand;
global int $hiresBirdWing;
global int $hires2FingHand;
global int $hiresBatWing;
global int $hires3FingHand;
global int $hiresTail;
global int $hires4FingHand;
global int $hires5FingHand;

//==== end global variables

getGlobVar ;


string $sn_basename = "neck";
string $sn_name = "neck";
string $neckname;
string $pr;
string $shortNeckLocs[];
string $necks[];
clear $necks;

string $spinename = ($rig_prefix+"M_spine");

for($i = 0; $i < $short_necks; $i++)
{
        if($short_necks > 1)
        {   
   
            if(!($i%2))
            {
            $pr = $prefixL;
            }
            else
            {
            $pr = $prefixR;
            }
        }
        else
        {
        $pr = ($rig_prefix + "M_");
        }

    if($i > 1)
    {
    $sn_name = ($sn_basename + ($i/2));
    }
    else
    {
    $sn_name = $sn_basename;
    }

    $neckname = ($pr + $sn_name + "_");


showHidden -all;
    
    short_neck_rig $neckname;
    
    $necks[size($necks)] = $neckname;
   
    if(`objExists ($spinename + "_end_PIV")`)
    {
    parent ($neckname + "root_LOC") ($spinename + "_end_PIV");
    }
    else
    {
    parent ($neckname + "root_LOC") ($neckname + "root_rot_ctrl");
    }
   
        if(`objExists ($neckname + "root_ROC")`)
        {
        delete ($neckname + "root_ROC");
        delete ($neckname + "root_POC");
        }
   
        if(`objExists ($rig_prefix + "no_transform_GRP")`)
        {
        parent ($neckname + "no_trans_GRP") ($rig_prefix +  "no_transform_GRP");
        }

    select -cl;

}

return $necks;


}

//====================================================================
//====================================================================
//====================================================================
//====================================================================




global proc creature_rig()
{

cycleCheck -e off;

//==== global variables

global string $FsRigPrefix;
global string $FsRigName;

//=== names

global string $rig_pref;
global string $rig_name;
global string $rig_prefix;
global string $prefixL;
global string $prefixR;
global string $rig_dir;

//=== modules

global int $doEnv;
global int $hires;
global int $normal_spines;
global int $long_spines;
global int $long_necks;
global int $short_necks;
global int $heads;
global int $human_arms;
global int $human_legs;
global int $quadr_legs;
global int $human_feet;;
global int $one_finger_hands;
global int $two_finger_hands;
global int $three_finger_hands;
global int $four_finger_hands;
global int $five_finger_hands;
global int $bird_wings;
global int $bat_wings;
global int $tentacles;
global int $tails;
global int $fins;
global int $flippers;
global int $rig_type;
global int $quad_rig_type;
global int $bird_rig_type;
global int $rept_rig_type;
global int $hires;
global int $normal_spines;
global int $long_spines;
global int $long_necks;
global int $short_necks;
global int $heads;
global int $human_arms;
global int $human_legs;
global int $quadr_legs;
global int $human_feet;
global int $one_finger_hands;
global int $two_finger_hands;
global int $three_finger_hands;
global int $four_finger_hands;
global int $five_finger_hands;
global int $bird_wings;
global int $bat_wings;
global int $tentacles;
global int $tails;
global int $fins;
global int $flippers;
global int $doStretch;
global int $doToes;
getGlobVar;

string $wireDefCommand;

//==============================================================================
//==============================================================================

//=== locs scene cleaup

showHidden -all;
dgdirty -a;

string $constr[] = `ls -typ constraint`;
for($i = 0; $i < size($constr); $i++)
{

cleanConstraint $constr[$i];
setAttr ($constr[$i] + ".nodeState") 9;
}

if(`objExists ($rig_prefix + "dont_GRP")`)
{
select ($rig_prefix + "dont_GRP");
sets -add ($rig_prefix + "del_SEL");
}

//=== end locs scene cleaup


//============================================================================================
//========================================== RIGS ============================================
//============================================================================================


//=== spines

string $spinename = `do_spine`;

//=== necks

//=== short neck

string $necks[] = `do_short_neck`;

//=== end short neck

//=== long neck

string $lg_basename = "neck";
string $lg_name = "neck";
string $neckname;
string $pr;
string $longNeckLocs[];
//string $necks[];
//clear $necks;

for($i = 0; $i < $long_necks; $i++)
{
        if($long_necks > 1)
        {   
   
            if(!($i%2))
            {
            $pr = $prefixL;
            }
            else
            {
            $pr = $prefixR;
            }
        }
        else
        {
        $pr = ($rig_prefix + "M_");
        }

    if($i > 1)
    {
    $lg_name = ($lg_basename + ($i/2));
    }
    else
    {
    $lg_name = $lg_basename;
    }

    $neckname = ($pr + $lg_name + "_");


showHidden -all;

    long_neck_rig $neckname;
    $necks[size($necks)] = $neckname;
   

    select -cl;

}

//=== end long neck

//=== end necks

//=== heads

do_head;

//=== end heads

//=== arms

string $arms[] = `do_arm`;

//=== legs

do_leg;

//
//=== end legs

//=== hands

string $ha_basename = "hand";
string $ha_name = "hand";
string $handname;
string $pr;
string $armName;
int $hands = $five_finger_hands + $four_finger_hands +  $three_finger_hands + $two_finger_hands + $one_finger_hands;
int $fingers ;
string $currentFingers[];
if($rig_type == 2)
{
$ar_basename = "leg";
$ar_name = "leg";

    if($quad_rig_type == 1)
    {
    $ha_basename = "hoof";
    $ha_name = "hoof";
    }
   
    if($quad_rig_type == 2)
    {
    $ha_basename = "paw";
    $ha_name = "paw";
    }
}


//===



if($one_finger_hands > 0)
{
    for($i = 0; $i < $one_finger_hands; $i++)
    {
    $currentFingers[size($currentFingers)] = "one";
    }
}

if($two_finger_hands > 0)
{
    for($i = 0; $i < $two_finger_hands; $i++)
    {
    $currentFingers[size($currentFingers)] = "two";
    }
}

if($three_finger_hands > 0)
{
    for($i = 0; $i < $three_finger_hands; $i++)
    {
    $currentFingers[size($currentFingers)] = "three";
    }
}

if($four_finger_hands > 0)
{
    for($i = 0; $i < $four_finger_hands; $i++)
    {
    $currentFingers[size($currentFingers)] = "four";
    }
}

if($five_finger_hands > 0)
{

    for($i = 0; $i < $five_finger_hands; $i++)
    {
    $currentFingers[size($currentFingers)] = "five";
    }
}


for($i = 0; $i < $hands; $i++)
{

if(`gmatch $currentFingers[$i] "one"`)
{
$fingers = 1;
}
if(`gmatch $currentFingers[$i] "two"`)
{
$fingers = 2;
}
if(`gmatch $currentFingers[$i] "three"`)
{
$fingers = 3;
}
if(`gmatch $currentFingers[$i] "four"`)
{
$fingers = 4;
}
if(`gmatch $currentFingers[$i] "five"`)
{
$fingers = 5;
}
   
        if($hands > 1)
        {   
   
            if(!($i%2))
            {
            $pr = $prefixL;
            }
            else
            {
            $pr = $prefixR;
            }
        }
        else
        {
        $pr = $rig_prefix;
        }

if($rig_type == 2)
{
    if($i > 1)
    {
    $ha_name = ($ha_basename + "_b");
    }
    else
    {
    $ha_name = ($ha_basename + "_f");
    }
}
else
{

        if($rig_type == 3)
        {
            if($i < 2)
            {
            $ar_basename = "wing";
            $ar_name = "wing";
            $ha_basename = "hand";
            $ha_name = "hand";
            }
            else
            {
            $ar_basename = "leg";
            $ar_name = "leg";
            $ha_basename = "foot";
            $ha_name = "foot";
            }
           
        }

    if($i > 1)
    {
        if($rig_type == 3)
        {
        $ha_name = $ha_basename;
        }
        else
        {
        $ha_name = ($ha_basename + ($i/2));
        }
    }
    else
    {
    $ha_name = $ha_basename;
    }
}   
    $handname = ($pr + $ha_name + "_");


int $numerillo = 5;

if(`gmatch $ha_name "*_b*"` == 1)
{
$numerillo = 4;
}
if(`gmatch $ha_name "*_f*"` == 1)
{
$numerillo = 4;
}
if(`size($ha_name)` == 3)
{
$numerillo = 4;
}
if(`gmatch $ha_name "*hoof*"` == 1)
{
$numerillo = 5;
}

$armName = $arms[$i];

showHidden -all;


if(`objExists ("*"+$armName+"*")`)
{

print ("\nrigging hand: hand_rig "+$handname+" "+$armName+" "+$fingers+" "+$ha_basename+"\n;");
hand_rig $handname $armName $fingers $ha_basename;

}
else
{
spaceLocator -name ($handname+"arm_LOC");
select ($handname+"PIV") ($handname+"arm_LOC");
delete `parentConstraint`;
print ("\nrigging hand: hand_rig "+$handname+" "+$handname+"arm_LOC "+$fingers+" "+$ha_basename+"\n;");
hand_rig $handname ($handname+"arm_LOC")  $fingers $ha_basename;
}
   
}

//=== end hands

//=== feet

global int $hiresFoot;
getGlobVar;

string $foo_basename = "foot";
string $foo_name = "foot";
string $footname;
string $pr;
string $legName;

for($i = 0; $i < $human_feet; $i++)
{
        if($human_feet > 1)
        {   
   
            if(!($i%2))
            {
            $pr = $prefixL;
            }
            else
            {
            $pr = $prefixR;
            }
        }
        else
        {
        $pr = ($rig_prefix + "M_");
        }

    if($i > 1)
    {
    $foo_name = ($foo_basename + ($i/2));
    }
    else
    {
    $foo_name = $foo_basename;
    }
   
    $footname = ($pr + $foo_name);

if(`gmatch $foo_name "foot"` == 1)
{
$legName = ($pr + "leg_");
}
else
{
$legName = ($pr + "leg" + substring($foo_name,5,(size($foo_name))) +  "_");
}

showHidden -all;

if($doToes == 1)
{
    if($rig_type == 1)
    {
    hand_rig $footname $legName $fingers $foo_basename;
    //human_foot_rig $footname $legname;
    }
}
else
{
//hand_rig $footname $legName 1 $foo_basename;
human_foot_rig $footname $legName ;
}
   


select -cl;
}

//=== end feet





//=== tentacles

string $tentbasename = "tentacle";
string $tentname = "tentacle";
string $tentaclename;
string $pr;

for($i = 0; $i < $tentacles; $i++)
{
        if($tentacles > 1)
        {   
   
            if(!($i%2))
            {
            $pr = $prefixL;
            }
            else
            {
            $pr = $prefixR;
            }
        }
        else
        {
        $pr = ($rig_prefix + "M_");
        }

    if($i > 1)
    {
    $tentname = ($tentbasename + ($i/2));
    }
    else
    {
    $tentname = $tentbasename;
    }

    $tentaclename = ($pr + $tentname + "_");

showHidden -all;
   
string $wires[] = `tentacle_rig $tentaclename 0 1 $hires`;

    if(`objExists ($spinename + "_hip_LOC")`)
    {
    spaceLocator -name ($tentaclename + "root_ref_LOC");
    select ($spinename + "_hip_xtra_ctrl") ($tentaclename +  "root_ref_LOC");
    copyTrans;
    select ($spinename + "_hip_LOC") ($tentaclename + "root_ref_LOC");
    dnDoConstraint ("POC");
    select ($spinename + "_hip_xtra_ctrl") ($tentaclename +  "root_ref_LOC");
    dnDoConstraint ("ORC");
    parent ($tentaclename + "root_ref_LOC") ($rig_prefix + "hip_PIV");
    parent ($tentaclename + "root_ctrl_LOC") ($tentaclename +  "root_ref_LOC");
    }
    else
    {
        if(`objExists ($rig_prefix + "controls_GRP")`)
        {
        parent ($tentaclename + "root_ctrl_LOC") ($rig_prefix +  "controls_GRP");
        }
       
    }

        if(`objExists ($rig_prefix + "no_transform_GRP")`)
        {
        parent ($tentaclename + "no_trans_GRP") ($rig_prefix +  "no_transform_GRP");
        }



//================ flip rot axes

            if(`gmatch $tentaclename "*_L_*"` == 1)
            {
            setAttr ($tentaclename + "root_ctrl.rot_axes") 180;
            }

//=============== end flip rot axes
   
select -cl;

}

//=== end tentacles


//=== tails

string $tabasename = "tail";
string $taname = "tail";
string $tailname;
string $pr;

for($i = 0; $i < $tails; $i++)
{
        if($tails > 1)
        {   
   
            if(!($i%2))
            {
            $pr = $prefixL;
            }
            else
            {
            $pr = $prefixR;
            }
        }
        else
        {
        $pr = ($rig_prefix + "M_");
        }

    if($i > 1)
    {
    $taname = ($tabasename + ($i/2));
    }
    else
    {
    $taname = $tabasename;
    }

    $tailname = ($pr + $taname + "_");

showHidden -all;
       
tail_rig $tailname 0 1;

    if(`objExists ($spinename + "_hip_LOC")`)
    {
    spaceLocator -name ($tailname + "root_ref_LOC");
    select ($spinename + "_hip_xtra_ctrl") ($tailname + "root_ref_LOC");
    copyTrans;
    select ($spinename + "_hip_LOC") ($tailname + "root_ref_LOC");
    dnDoConstraint ("POC");
    select ($spinename + "_hip_xtra_ctrl") ($tailname + "root_ref_LOC");
    dnDoConstraint ("ORC");
    parent ($tailname + "root_ref_LOC") ($rig_prefix + "hip_PIV");
    parent ($tailname + "root_ctrl_LOC") ($tailname + "root_ref_LOC");
    }
    else
    {
        if(`objExists ($rig_prefix + "controls_GRP")`)
        {
        parent ($tailname + "root_ctrl_LOC") ($rig_prefix + "controls_GRP");
        }
   
    }

if(`objExists ($rig_prefix + "no_transform_GRP")`)
{
parent ($tailname + "no_trans_GRP") ($rig_prefix + "no_transform_GRP");
}


}

//=== end tails


//=== fins

string $finbasename = "fin";
string $finname = "fin";
string $finname;
string $pr;

for($i = 0; $i < $fins; $i++)
{
        if($fins > 1)
        {   
   
            if(!($i%2))
            {
            $pr = $prefixL;
            }
            else
            {
            $pr = $prefixR;
            }
        }
        else
        {
        $pr = ($rig_prefix + "M_");
        }

    if($i > 1)
    {
    $finname = ($finbasename + ($i/2));
    }
    else
    {
    $finname = $finbasename;
    }

    $finname = ($pr + $finname + "_");

showHidden -all;
       
fin_rig $finname 0 1 5;

    if(`objExists ($spinename + "_hip_LOC")`)
    {
    spaceLocator -name ($finname + "root_ref_LOC");
    select ($spinename + "_hip_xtra_ctrl") ($finname + "root_ref_LOC");
    copyTrans;
    select ($spinename + "_hip_LOC") ($finname + "root_ref_LOC");
    dnDoConstraint ("POC");
    select ($spinename + "_hip_xtra_ctrl") ($finname + "root_ref_LOC");
    dnDoConstraint ("ORC");
    parent ($finname + "root_ref_LOC") ($rig_prefix + "hip_PIV");
    parent ($finname + "root_ctrl_LOC") ($finname + "root_ref_LOC");
    }
    else
    {
        if(`objExists ($rig_prefix + "controls_GRP")`)
        {
        parent ($finname + "root_ctrl_LOC") ($rig_prefix + "controls_GRP");
        }
   
    }

if(`objExists ($rig_prefix + "no_transform_GRP")`)
{
parent ($finname + "no_trans_GRP") ($rig_prefix + "no_transform_GRP");
}

/*   
if(`objExists "*_fin*_grp"`)
{
delete "*_fin*_grp";
}
*/

}

//=== end fins


//=== flippers

string $flipbasename = "flipper";
string $flipname = "flipper";
string $flippername;
string $pr;

string $le_basename = "leg";
string $le_name = "leg";
string $legname;

for($i = 0; $i < $flippers; $i++)
{
        if($flippers > 1)
        {   
   
            if(!($i%2))
            {
            $pr = $prefixL;
            }
            else
            {
            $pr = $prefixR;
            }
        }
        else
        {
        $pr = ($rig_prefix + "M_");
        }

    if($i > 1)
    {
    $flipname = ($flipbasename + ($i/2));
    $le_name = ($le_basename + ($i/2));
    }
    else
    {
    $flipname = $flipbasename;
    $le_name = $le_basename;
    }

    $flippername = ($pr + $flipname + "_");
    $legname = ($pr + $le_name);

showHidden -all;
   
flipper_rig $flippername 0 1 $hires;


//================ flip rot axes

            if(`gmatch $flippername "*_L_*"` == 1)
            {
            setAttr ($flippername + "root_ctrl.rot_axes") 180;
            }

//=============== end flip rot axes

if(`objExists ($rig_prefix + "no_transform_GRP")`)
{
parent ($flippername + "no_trans_GRP") ($flippername + "upvs_GRP")
($flippername + "jnts_GRP") ($rig_prefix + "no_transform_GRP");
}

if(`objExists ($legname + "_end_JNT")`)
{

spaceLocator -name ($flippername + "root_ctrl_0_LOC");
select ($flippername + "root_ctrl_LOC") ($flippername +  "root_ctrl_0_LOC");
$o = `orientConstraint`; delete $o;
$p = `pointConstraint`; delete $p;
parent ($flippername + "root_ctrl_LOC") ($flippername +  "root_ctrl_0_LOC");

parent ($flippername + "root_ctrl_0_LOC") ($legname + "_end_JNT");

spaceLocator -name ($flippername + "ik_LOC");
spaceLocator -name ($flippername + "fk_LOC");

select ($flippername + "root_ctrl_0_LOC") ($flippername + "ik_LOC");
$o = `orientConstraint`; delete $o;
$p = `pointConstraint`; delete $p;
select ($flippername + "root_ctrl_0_LOC") ($flippername + "fk_LOC");
$o = `orientConstraint`; delete $o;
$p = `pointConstraint`; delete $p;


select ($flippername + "ik_LOC") ($flippername + "fk_LOC")
($flippername + "root_ctrl_0_LOC");
dnDoConstraint("ORC");

//connectAttr ($legname + "_foot_ctrl.ik") ($flippername +  "root_ctrl_0_LOC.fcWeightORC");

addAttr -ln flipper_follow_rot -at double  -min 0 -max 1 -dv 1
($legname + "_foot_ctrl");
setAttr -e -keyable true ($legname + "_foot_ctrl.flipper_follow_rot");
connectAttr ($legname + "_foot_ctrl.flipper_follow_rot") ($flippername +  "root_ctrl_0_LOC.fcWeightORC");

//=== adding xtra locator for flipping axes orientCostraint

spaceLocator -name ($flippername + "ik_0_LOC");
spaceLocator -name ($flippername + "fk_0_LOC");

select ($flippername + "ik_LOC") ($flippername + "ik_0_LOC");
$o = `orientConstraint`; delete $o;
$p = `pointConstraint`; delete $p;
select ($flippername + "fk_LOC") ($flippername + "fk_0_LOC");
$o = `orientConstraint`; delete $o;
$p = `pointConstraint`; delete $p;

parent ($flippername + "ik_LOC") ($flippername + "ik_0_LOC");
parent ($flippername + "fk_LOC") ($flippername + "fk_0_LOC");

parent ($flippername + "ik_0_LOC") ($legname + "_foot_ctrl");
parent ($flippername + "fk_0_LOC") ($legname + "_end_JNT");

//=== end adding xtra locator for flipping axes orientCostraint

}
   
select -cl;

}

//=== end flippers

//=====================================================================================================
//=====================================================================================================
//=====================================================================================================
//=====================================================================================================
//=====================================================================================================
//=====================================================================================================
//=====================================================================================================
//=====================================================================================================
//=====================================================================================================
//=====================================================================================================
//=====================================================================================================
//=====================================================================================================
//=====================================================================================================


//=== double check on constraints

updateConstraints;

//=== end double check on constraints

//==== groups

//==== groups

if(`objExists ($spinename + "_GRP")`)
{

    if(`objExists ($rig_prefix + "body_local_ctrl")`)
    {
    parent ($spinename + "_GRP") ($spinename + "_body_xtra_ctrl");
    }
}

string $ctlJoints[];
string $list[] =`ls "*_ENV"`;

for($i = 0;$i<size($list);$i++)
{
    if(`gmatch $list[$i] "*_fk_*"`)
    {
        if(`gmatch $list[$i] "*end*"`)
        {
        }
        else
        {
        $ctlJoints[size($ctlJoints)] = $list[$i];
        }
    }
}


//===========================================================================================================================
//=========================================== swap PULs for ENV joints ======================================================
//===========================================================================================================================

if(`objExists "*PUL"`)
{
select "*ENV"; select -d -type joint "*ENV";
dnSwapEnvs `ls -sl`;
}


//===========================================================================================================================
//=========================================== diplay layers            ======================================================
//===========================================================================================================================

if(!`objExists ($rig_prefix + "env_DSP")`)
{
createDisplayLayer -e -name ($rig_prefix + "env_DSP");
select "*ENV";
editDisplayLayerMembers -noRecurse ($rig_prefix + "env_DSP") `ls -sl`;
}

select `ls -typ joint`; select -d `ls -type joint "*ENV"`;

if(`objExists ($spinename + "_CRV")`)
{
select -add ($spinename + "_CRV");
}


if(`objExists ($spinename + "*lead*JNT")`)
{
select -d ($spinename + "*lead*JNT");
}

if(`objExists ($rig_prefix+"*neck*CRV")`)
{
select -add ($rig_prefix+"*neck*CRV");
}

if(`objExists ($rig_prefix + "*twist*JNT")`)
{
select -d ($rig_prefix + "*twist*JNT");
}

if(`objExists ($rig_prefix  + "*xtra*JNT")`)
{
select -d ($rig_prefix + "*xtra*JNT");
}

if(`objExists ($rig_prefix  + "*ik*JNT")`)
{
select -d ($rig_prefix + "*ik*JNT");
}
if(`objExists "*fk*JNT"`)
{
select -d "*fk*JNT";
}


if(`objExists ($rig_prefix + "jnts_DSP")` == 0)
{
createDisplayLayer -name ($rig_prefix + "jnts_DSP");
}

setAttr ($rig_prefix + "jnts_DSP.displayType") 2;
setAttr ($rig_prefix + "jnts_DSP.visibility") 0;
setAttr ($rig_prefix + "jnts_DSP.shading") 0;



if(`objExists ($rig_prefix + "path_CRV")`)
{
select ($rig_prefix + "path_CRV");

if(`objExists ($rig_prefix + "path_DSP")` == 0)
{
createDisplayLayer -name ($rig_prefix + "path_DSP");
}

setAttr ($rig_prefix + "path_DSP.displayType") 0;
setAttr ($rig_prefix + "path_DSP.visibility") 0;

}


if(`objExists ($rig_prefix + "*IKH")`)
{
select ($rig_prefix + "*IKH");
}

if(`objExists ($rig_prefix + "*CRV")`)
{
select -add ($rig_prefix + "*CRV");

    if(`objExists ($rig_prefix + "*neck*CRV")`)
    {
    select -d ($rig_prefix + "*neck*CRV");
    }
    if(`objExists ($spinename + "_CRV")`)
    {
    select -d ($spinename + "_CRV");
    }
}

if(`objExists ($spinename + "*lead*JNT")`)
{
select -add ($spinename + "*lead*JNT");
select -d ($rig_prefix + "path_CRV");
}

if(`objExists ($rig_prefix + "*twist*JNT")`)
{
select -add ($rig_prefix + "*twist*JNT");
}

if(`objExists ($rig_prefix + "*xtra*JNT")`)
{
select -add ($rig_prefix + "*xtra*JNT");
}

if(`objExists ($rig_prefix + "*ik*JNT")`)
{
select -add ($rig_prefix + "*ik*JNT");
}

select -add `ls -typ locator -typ clusterHandle -typ ikEffector`;


if(`objExists ($rig_prefix + "invis_DSP")` == 0)
{
createDisplayLayer -name ($rig_prefix + "invis_DSP");
}

setAttr ($rig_prefix + "invis_DSP.displayType") 1;
setAttr ($rig_prefix + "invis_DSP.v") 1;

if(`objExists ($rig_prefix + "locs_SEL")`)
{
    select ($rig_prefix + "locs_SEL");
    string $list[] = `ls -sl`;
    string $item;
    for($item in $list)
    {
        if(size(`listConnections -d 1 -s 0 $item`) > 0)
        {
        ////print "";
        }
        else
        {
        delete $item;
        }
    }
}
   
if(`objExists ($rig_prefix + "*M_*_ctrl")`)
{
select ($rig_prefix + "*M_*_ctrl");

if(`objExists ($rig_prefix + "M_ctls_DSP")` == 0)
{
createDisplayLayer -name ($rig_prefix + "M_ctls_DSP") `ls ($rig_prefix +  "global*ctrl") ($rig_prefix +  "M_*ctrl") `;
}

    if(`objExists ($rig_prefix + "body_local_ctrlShape")`)
    {
    editDisplayLayerMembers ($rig_prefix + "M_ctls_DSP") ($rig_prefix +  "body_local_ctrl*Shape*");
    }
    if(`objExists  ($rig_prefix + "eyes*ctrl")`)
    {
    editDisplayLayerMembers ($rig_prefix + "M_ctls_DSP")  ($rig_prefix +  "eyes*ctrl");
    }

setAttr ($rig_prefix + "M_ctls_DSP.color") 17;
}

//=====================

if(`objExists ($rig_prefix + "*R_*_ctrl")`)
{
select ($rig_prefix + "*R_*_ctrl") ($rig_prefix + "*R_*_finger*_ENVShape") ("*R_*finger*ENV");
//select -d ("*R_*finger*end*ENV");

    if(`objExists ($rig_prefix + "R_ctls_DSP")` == 0)
    {
    createDisplayLayer -name ($rig_prefix + "R_ctls_DSP");
    }
    
setAttr ($rig_prefix + "R_ctls_DSP.color") 13;
}

//=====================

if(`objExists ($rig_prefix + "*L_*_ctrl")`)
{
select ($rig_prefix + "*L_*_ctrl")($rig_prefix + "*L*_finger*_ENVShape") ("*L_*finger*ENV");
//select -d ("*L_*finger*end*ENV");

    if(`objExists ($rig_prefix + "L_ctls_DSP")` == 0)
    {
    createDisplayLayer -name ($rig_prefix + "L_ctls_DSP");
    }
    
setAttr ($rig_prefix + "L_ctls_DSP.color") 6;
}

//=====================

select -cl;

if(`objExists ($rig_prefix + "*_PUL")`)
{
select ($rig_prefix + "*_PUL");
}

if(`objExists ($rig_prefix + "*_MMC")`)
{
select -add ($rig_prefix + "*_MMC");
}


if(`objExists ($rig_prefix + "*CRV")`)
{
editDisplayLayerMembers ($rig_prefix + "invis_DSP") `ls "*CRV" "*DST"`;
}

for($stronzo in `ls "*CRV" "*DST"`)
{
setAttr ($stronzo+".v") 0;
setAttr -lock 1 ($stronzo+".v");
}

editDisplayLayerMembers ($rig_prefix + "invis_DSP") `ls -type ikHandle`;
editDisplayLayerMembers ($rig_prefix + "invis_DSP") `ls -type clusterHandle`;

//==== no pulls

if(`objExists "*PULShape"`)
delete "*PULShape";

delete `ls -type rexPass`;
select -cl;


//=== delete selection groups

if(`objExists ($rig_prefix + "mirror_nodes_SEL")`)
{
select ($rig_prefix + "mirror_nodes_SEL");
sets -rm ($rig_prefix + "mirror_nodes_SEL");
delete ($rig_prefix + "mirror_nodes_SEL");
}


if(`objExists ($rig_prefix + "rw_SEL")`)
{
select ($rig_prefix + "rw_SEL");
sets -rm ($rig_prefix + "rw_SEL");
delete ($rig_prefix + "rw_SEL");
}

//=== end delete selection groups

//=== envelope

if(`objExists "*modelGeo_null"`)
{
    if(`objExists ($rig_prefix + "no_transform_GRP")`)
    catchQuiet(`parent "*modelGeo_null" ($rig_prefix + "no_transform_GRP")`);
}
else
{
    if(`objExists ($rig_prefix+"body_geo")`)
        if(`objExists ($rig_prefix + "no_transform_GRP")`)
        catchQuiet(`parent ($rig_prefix+"body_geo") ($rig_prefix + "no_transform_GRP")`);
}
   

if(`objExists ($rig_prefix + $rig_name)`)
{
    if($hires == 0)
    {
    setAttr -typ "string" ($rig_prefix + $rig_name + ".version") "lores";
    }
    else
    {
    setAttr -typ "string" ($rig_prefix + $rig_name + ".version") "hires";
    }
}

//=== end envelope

//=============================================================================================
//=== scale_rig
//=============================================================================================

string $scalable_joints[] = `ls
($rig_prefix +"M_neck_*_ik_JNT")  ($rig_prefix +"M_neck_*_ENV") ($rig_prefix +"M_spine_*_JNT") ($rig_prefix +"M_spine_spine*_ENV") ($rig_prefix
+"?_foot*_ENV") ($rig_prefix +"M_spine_hip_LOC")
`;

for($item in $scalable_joints)
catchQuiet(`connectAttr -f ($rig_prefix +"xtra_global_ctrl.s") ($item+".s")`);


//=== cleanup

string $jnts[] = `ls -type joint`;
for($item in $jnts)
{
setAttr -keyable false ($item + ".tx");
setAttr -keyable false ($item + ".ty");
setAttr -keyable false ($item + ".tz");
setAttr -keyable false ($item + ".sx");
setAttr -keyable false ($item + ".sy");
setAttr -keyable false ($item + ".sz");
setAttr -keyable false ($item + ".v");
setAttr -keyable false ($item + ".nodeState");
}

clean_scene;
cleanAttr;
hide_locs;
removeMultipleLightLinkers;
cycleCheck -e on;


select -cl;

if(`objExists ($rig_prefix + "*PIV")`)
{
select -add ($rig_prefix + "*PIV");
}
if(`objExists ($rig_prefix + "*ctrl")`)
{
select -add ($rig_prefix + "*ctrl");
}
if(`objExists ($rig_prefix + $rig_name)`)
{
select -add ($rig_prefix + $rig_name);
}
if(`objExists ($rig_prefix + "*_path_CRV")`)
{
select -add ($rig_prefix + "*_path_CRV");
}
if(`objExists ($rig_prefix + "*_vCurve_path_CRV")`)
{
select -add ($rig_prefix + "*_vCurve_path_CRV");
}
if(`objExists ($rig_prefix + "*_path_MPA")`)
{
select -add ($rig_prefix + "*_path_MPA");
}
if(`objExists ($rig_prefix + "*_JNT")`)
{
select -add ($rig_prefix +"*_JNT");
}

if(`objExists ($rig_prefix + $rig_name)`)
{
store_sel ($rig_prefix + $rig_name) all_ctls;
}


if(`objExists ($rig_prefix + "del_SEL")`)
{
sets -rm ($rig_prefix + "del_SEL") `ls -sl`;
delete `sets -q -no ($rig_prefix + "del_SEL")`;
}

//============================================================================================
//=== controls sel
//============================================================================================

    sets -name ($rig_prefix+"M_spine_ctrl_SEL") `ls ($rig_prefix+"M_spine*ctrl")  ($rig_prefix+"*global*ctrl")`;

    select ($rig_prefix+"*ctrl_SEL");
    string $ctls[] = `ls -sl`;
    if(`objExists allAnimControls`)
    {
    delete ($rig_prefix+"*ctrl_SEL");
    sets -add allAnimControls `ls $ctls`;
    }
    else
    {
    delete ($rig_prefix+"*ctrl_SEL");
    sets -n allAnimControls `ls $ctls`;
    }

    if(!`objExists dnRenderGeo`)
    sets -n dnRenderGeo `ls "*geo"`;


//===========================================================================================================================
//===========================================================================================================================
//===========================================================================================================================
//===========================================================================================================================
//===========================================================================================================================
//============ Dneg changes


//===========================================================================================================================
//=========================================== parent main locs ==============================================================
//===========================================================================================================================

if(`objExists ($rig_prefix + "M_spine_end_LOC")`)
{
parent ($rig_prefix + "M_spine_chest_LOC") ($rig_prefix + "M_spine_hip_LOC") ($rig_prefix + "M_spine_spinejnts_GRP");
parent ($rig_prefix + "M_spine_end_LOC") ($rig_prefix + "M_spine_chest_LOC");
select ($rig_prefix + "M_spine_spine10_ENV") ($rig_prefix + "M_spine_chest_LOC");
dnDoConstraint "PAC";
select ($rig_prefix + "M_spine_spine1_ENV") ($rig_prefix + "M_spine_hip_LOC");
dnDoConstraint "PAC";
}

string $envs[] = `sets -q -no ($rig_prefix+"*env_joints_SEL")`;
delete ($rig_prefix+"*env_joints_SEL");
sets -name ($rig_prefix + "env_joints_SEL") `ls $envs`;


select -cl;

//===============================================================================================
//=== rename control/env joints
//===============================================================================================

select allAnimControls;
select -d "*ctrl";
string $other_ctrls[] = `ls -sl`;
for($pippo in $other_ctrls)
{
	if(`size($pippo)`)
	swap_suffix $pippo "ctrl";
}

//===========================================================================================================================
//===========================================================================================================================
//===========================================================================================================================
//===========================================================================================================================
//===========================================================================================================================
//===========================================================================================================================

select -cl;
fxDeleteEmptyLayers;


//=== cleanup

//=== scale stuff according to the spine length

    if(`objExists ($rig_prefix +"M_spine_end_LOC")`)
    {
    select ($rig_prefix +"M_spine_end_LOC") ($rig_prefix+"M_spine_hip_LOC");
    float $dist = `get_distance`;
    float $magicNumber = (1/($dist*4));
/*
    string $list[] = `ls -type joint`;

        for($item in $list)
        {
        setAttr ($item+".radius") $magicNumber;
        }
*/
    string $list[] = `ls "*twist_CRV"`;
    
    for($item in $list)
    setAttr ($item+".s") $magicNumber $magicNumber $magicNumber;
    }

    if(`objExists ($rig_prefix + "env_DSP")`)
    {
    setAttr ($rig_prefix + "env_DSP.displayType") 2;
    setAttr ($rig_prefix + "env_DSP.visibility") 1;
    setAttr ($rig_prefix + "env_DSP.shading") 0;
    }

//=============================================================================================
//=== bind
//=============================================================================================

if(`objExists ($rig_prefix+"body_geo")`)
{
print ("\nbinding\n");
select ($rig_prefix+"env_joints_SEL") ($rig_prefix+"body_geo");
skinCluster -ih -n skinCluster_ENV -tsb;
select  ($rig_prefix+"body_geo");
}


//========================================================================================
//==== getting rid of prefix
//========================================================================================

editDisplayLayerMembers ($rig_prefix + "geo_DSP") `ls "*head_PIV"`;

fcSearchReplace $rig_prefix "";
fcSearchReplace $rig_prefix "";
fcSearchReplace $rig_prefix "";
fcSearchReplace $rig_prefix "";
fcSearchReplace $rig_prefix "";
fcSearchReplace $rig_prefix "";

//=========== STORE BIND POSE

select allAnimControls;
string $command = ("store_pose " + $rig_name+" bind_pose");
eval($command);


//===========================================================================================================================
//=== connect secondary controls
//===========================================================================================================================


    setAttr -lock true -keyable false ($rig_name + ".t");
    setAttr -lock true -keyable false ($rig_name + ".r");
    setAttr -lock true -keyable false ($rig_name + ".s");

    if(!`objExists ($rig_name + ".sec_ctls")`)
    addAttr -k 1 -ln sec_ctls -at bool ($rig_name);
    
    if(!`objExists ($rig_name + ".fast")`)
    addAttr -k 1 -ln fast -at bool ($rig_name);
    
    setAttr ($rig_name+".fast") 1;
    
    string $list[] = `ls "*ctrl" "*xtra*ctrl"`;
    string $newList[];
    /*
    for($i = 0; $i < size($list);$i++)
    {
        if(`objExists ($list[$i] + ".sec")`)
        {
            if(`getAttr ($list[$i] + ".sec")` >0)
            {
            catchQuiet(`connectAttr -f ($rig_name + ".sec_ctls") ($newList[$i] + ".sec")`);
            catchQuiet(`connectAttr -f ($newList[$i] + ".sec") ($newList[$i] + "Shape.v")`);
            }
        }
    }
    */
        
string $control_joints[] = `ls "*finger*_ctrlShape"`;
    
    for($i = 0; $i < size($control_joints);$i++)
    {
    catchQuiet(`connectAttr -f ($rig_name + ".sec_ctls") ($control_joints[$i] + ".v")`);
    }
}


//============================================================================================
//============================================================================================
//============================================================================================
//============================================================================================
//============================================================================================
//============================================================================================
//============================================================================================
//============================================================================================
//============================================================================================
//============================================================================================
//============================================================================================
//============================================================================================
//============================================================================================
//============================================================================================
//============================================================================================
//============================================================================================
//============================================================================================
//============================================================================================
//============================================================================================
//============================================================================================
//============================================================================================
//--- plugins needed

//evalDeferred("autoLoadPlugin(\"\", \"fcEnv\", \"fcEnv\")");
//evalDeferred("autoLoadPlugin(\"\", \"fcMuscle\", \"fcMuscle\")");
//evalDeferred("autoLoadPlugin(\"\", \"vCurve\", \"vCurve\")");
//evalDeferred("autoLoadPlugin(\"\", \"fcdbMaya\", \"fcdbMaya\")");
//evalDeferred("autoLoadPlugin(\"\", \"assetManager\", \"assetManager\")");

//source "/net/soft/fscfc/creatures/generic/FRIG/frig_module.mel";
//source "/job/xmen3/common/maya/mel/assetManager_launch.mel";

//===

//=== some scripts

global proc sourceGEC()
{
    string $name = `textFieldButtonGrp -q -tx SETTINGS`;
    string $script = ("source \"" + $name + "\"");
    if(size($name)>0)
    {
    eval $script;
    }
    else
    {
    print "NO GEC FILE TO SOURCE";
    }
}

global proc saveIt(string $text)
{
string $name = `textFieldButtonGrp -q -tx FILENAME`;
string $fileName = $name;
$fileId = `fopen $fileName "w"`;
fprint $fileId $text;
fclose $fileId;

    if ( `window -exists fileName` )
    {
    deleteUI -window fileName;
    }

print ("saving " + $text + "into " + $name);

}

global proc editSet()
{
string $editFile = `textFieldButtonGrp -q -tx SETTINGS`;
system("/apps/Linux64/nedit/nedit " + $editFile + "\&");
}

global proc editMel()
{
string $editFile = `textFieldButtonGrp -q -tx MEL`;
system("/apps/Linux64/nedit/nedit " + $editFile + "\&");
}


global proc string[] getFcdbGEO()
{

string $list[] = `ls -sl`;
string $objsBefore[] = `ls -dag`;

global string $rig_pref;
getGlobVar ;
string $modelPath = `textFieldButtonGrp -q -tx fcdbGEO`;
string $fcdbElements[];

    if(size($modelPath)>0)
    {
    tokenize $modelPath ";" $fcdbElements;
    print "\n\n";
    print $fcdbElements;
    print "\n\n";
   
        for($i=0;$i<size($fcdbElements);$i++)
        {
       
            if(size($fcdbElements[$i]) > 0)
            {
           
                if(`gmatch $modelPath "*.mel"`)
                {
                string $command = ("source \""+$modelPath+"\"");
                eval($command);
                }
                else
                {
                    if(`gmatch $modelPath "(*)"`)
                    {
                    string $postLoad;
                    string $newPath = substring($fcdbElements[$i], 2, (size($fcdbElements[$i])-1));
                    string $tokens[];
                    tokenize $newPath " " $tokens;
                   
                    string $AMprefix = $tokens[0];
                    int $idElement = $tokens[1];
                    int $import = $tokens[3];
                   
                        if(`gmatch $tokens[2] "\"\""` == 1)
                        {
                        string $postLoad = "\"\"";
                        }
                        else
                        {
                        string $postLoad = $tokens[2];
                        }
                    //assetManager_addAsset $AMprefix $idElement $postLoad $import;
                    }
                    else
                    {
                    catchQuiet(`file -import $fcdbElements[$i]`);
                    }
                }
            }
       
        }
   
    select `ls -dag`;
    select -d $objsBefore;
    string $origGeo[] = `ls -sl`;
    string $geometry[];
    select $origGeo; displaySmoothness -divisionsU 0 -divisionsV 0 -pointsWire 4 -pointsShaded 1 -polygonObject 1; subdivDisplaySmoothness -smoothness 1;
    
    for($item in $origGeo)
    {
    string $type[] = `ls -st $item`;
        if(`gmatch "transform" $type[1]`)
        {
        rename $item ($rig_pref+"_"+$item);
        $geometry[size($geometry)] = ($rig_pref+"_"+$item);
        }
    }   
        if(`objExists ($rig_pref + "_geo_DSP")`)
        {
        editDisplayLayerMembers ($rig_pref + "_geo_DSP") $geometry;
        setAttr ($rig_pref + "_geo_DSP.displayType") 2;
        }
        else
        {
        createDisplayLayer -n ($rig_pref + "_geo_DSP");
        setAttr ($rig_pref + "_geo_DSP.displayType") 2;
        editDisplayLayerMembers ($rig_pref + "_geo_DSP") $geometry;
        }
   
    select $list;
    }
    else
    {
    print "NO MODEL TO LOAD";
    }
    
    
return $fcdbElements;
}

global proc int set_file_name(string $filename, string $fileType )
{
//textFieldButtonGrp -e -tx FILENAME;
    textFieldButtonGrp -edit -fi $filename FILENAME;
    return 1;
}


global proc save_settings()
{

if ( `window -exists fileName` )
{
deleteUI -window fileName;
}

//==== global variables

//=== names

global string $rig_pref ;
global string $rig_name ;
global string $rig_prefix ;
global string $prefixL ;
global string $prefixR;
global string $rig_dir;

//=== modules

global int $rig_type;
global int $quad_rig_type;
global int $bird_rig_type;
global int $rept_rig_type;
global int $hires;
global int $normal_spines ;
global int $long_spines ;
global int $long_necks ;
global int $short_necks ;
global int $heads ;
global int $human_arms ;
global int $human_legs ;
global int $quadr_legs ;
global int $human_feet ;
global int $one_finger_hands ;
global int $two_finger_hands ;
global int $three_finger_hands ;
global int $four_finger_hands ;
global int $five_finger_hands ;
global int $bird_wings ;
global int $bat_wings ;
global int $tentacles ;
global int $tails ;
global int $fins ;
global int $flippers ;

//=== scripts and models

global string $model ;
global int $doPost ;
global int $doEnv ;
global int $doToes ;
//global int $doFcdb ;
global int $doStretch ;
global string $postScript;
global string $geo;

global int $hiresSpine;
global int $hiresReptSpine;
global int $hiresHead;
global int $hiresQuadrLeg;
global int $hiresShortNeck;
global int $hiresLongNeck;
global int $hiresArm;
global int $hiresTentacle;
global int $hiresLeg;
global int $hiresFlipper;
global int $hiresFin;
global int $hires1FingHand;
global int $hiresBirdWing;
global int $hires2FingHand;
global int $hiresBatWing;
global int $hires3FingHand;
global int $hiresTail;
global int $hires4FingHand;
global int $hires5FingHand;

getGlobVar ;

global string $gecFile;

//==== end global variables

$gecFile = ("textFieldButtonGrp -e -tx \"" +$geo+"\" fcdbGEO;\noptionMenuGrp -e -sl "+$rig_type+" GEC;\ntextField -e -tx "+$rig_pref+" RIG_PREFIX;\ntextField -e -tx "+$rig_name+" RIG_NAME;\noptionMenuGrp -e -sl "+($hires+1)+" RES;\noptionMenuGrp -e -sl "+$quad_rig_type+" QT;\noptionMenuGrp -e -sl "+$bird_rig_type+" BT;\noptionMenuGrp -e -sl "+$rept_rig_type+" RT;\nintField -e -v "+$normal_spines+" normal_spines;\nintField -e -v "+$long_spines+" reptile_spines;\nintField -e -v "+$long_necks+" long_necks;\nintField -e -v "+$short_necks+" short_necks;\nintField -e -v "+$heads+" heads;\nintField -e -v "+$human_arms+" human_arms;\nintField -e -v "+$human_legs+" human_legs;\nintField -e -v "+$quadr_legs+" quadr_legs;\nintField -e -v "+$human_feet+" human_feet;\nintField -e -v "+$one_finger_hands+" one_fing_hands;\nintField -e -v "+$two_finger_hands+" two_fing_hands;\nintField -e -v "+$three_finger_hands+" three_fing_hands;\nintField -e -v "+$four_finger_hands+" four_fing_hands;\nintField -e -v "+$five_finger_hands+" five_fing_hands;\nintField -e -v "+$bird_wings+" bird_wings;\nintField -e -v "+$bat_wings+" bat_wings;\nintField -e -v "+$tentacles+" tentacles;\nintField -e -v "+$tails+" tails;\nintField -e -v "+$fins+" fins;\nintField -e -v "+$flippers+" flippers;\ncheckBox -e -v "+$doPost+" doPost;\ncheckBox -e -v "+$doEnv+" doEnv;\ncheckBox -e -v "+$doStretch+" doStretch;\ncheckBox -e -v "+$doToes+" doToes;\ncheckBox -e -v "+ $hiresSpine +" hiresSpine;\ncheckBox -e -v "+  $hiresReptSpine +" hiresReptSpine;\ncheckBox -e -v "+ $hiresHead +" hiresHead;\ncheckBox -e -v "+ $hiresQuadrLeg +" hiresQuadrLeg;\ncheckBox -e -v "+ $hiresShortNeck +" hiresShortNeck;\ncheckBox -e -v "+  $hiresLongNeck +" hiresLongNeck;\ncheckBox -e -v "+ $hiresArm +" hiresArm;\ncheckBox -e -v "+ $hiresTentacle +" hiresTentacle;\ncheckBox -e -v "+  $hiresLeg +" hiresLeg;\ncheckBox -e -v "+ $hiresFlipper +" hiresFlipper;\ncheckBox -e -v "+ $hiresFin +" hiresFin;\ncheckBox -e -v "+  $hires1FingHand +" hires1FingHand;\ncheckBox -e -v "+ $hiresBirdWing +" hiresBirdWing;\ncheckBox -e -v "+ $hires2FingHand +" hires2FingHand;\ncheckBox -e -v "+ $hiresBatWing +" hiresBatWing;\ncheckBox -e -v "+ $hires3FingHand +" hires3FingHand;\ncheckBox -e -v "+ $hiresTail +" hiresTail;\ncheckBox -e -v "+ $hires4FingHand +" hires4FingHand;\ncheckBox -e -v "+  $hires5FingHand +" hires5FingHand;\ntextFieldButtonGrp -e -tx \""+$postScript+"\" MEL;\ntextFieldButtonGrp -e -tx \""+$rig_dir+"\" ENV;\n");

string $Dialog = `window -t "fileName" fileName`;
columnLayout;
textFieldButtonGrp -label "Label" -text "" -buttonLabel "browse" -buttonCommand "fileBrowser(\"set_file_name\",\"OK\", \"\", 0);" FILENAME;
button -label "OK" -c "saveIt $gecFile";showWindow $Dialog;

}

//===


//======= copy paste stuff
//======= copy paste stuff
//======= copy paste stuff
//======= copy paste stuff
//======= copy paste stuff
//======= copy paste stuff
//======= copy paste stuff
//======= copy paste stuff
//======= copy paste stuff
//======= copy paste stuff
//======= copy paste stuff
//======= copy paste stuff
global proc copy_locs()
{

//==== global variables

//=== names

global string $rig_pref;
global string $rig_name;
global string $rig_prefix;
global string $prefixL;
global string $prefixR;
global string $rig_dir;

//=== modules

global int $hires;
global int $normal_spines;
global int $long_spines;
global int $long_necks;
global int $short_necks;
global int $heads;
global int $human_arms;
global int $human_legs;
global int $quadr_legs;
global int $human_feet;;
global int $one_finger_hands;
global int $two_finger_hands;
global int $three_finger_hands;
global int $four_finger_hands;
global int $five_finger_hands;
global int $bird_wings;
global int $bat_wings;
global int $tentacles;
global int $tails;
global int $fins;
global int $flippers;
global int $hiresSpine;
global int $hiresReptSpine;
global int $hiresHead;
global int $hiresQuadrLeg;
global int $hiresShortNeck;
global int $hiresLongNeck;
global int $hiresArm;
global int $hiresTentacle;
global int $hiresLeg;
global int $hiresFlipper;
global int $hiresFin;
global int $hires1FingHand;
global int $hiresBirdWing;
global int $hires2FingHand;
global int $hiresBatWing;
global int $hires3FingHand;
global int $hiresTail;
global int $hires4FingHand;
global int $hires5FingHand;

//==== end global variables

getGlobVar ;

    //===

string $pose[];
string $tmp[];

if(`objExists ($rig_prefix + "rw_SEL")`)
{
select ($rig_prefix + "rw_SEL");
$pose = `getPose`;
}
else
{
    if(`objExists ($rig_prefix + $rig_name + ".locs")`)
    {
    $pose[0] = `getAttr ($rig_prefix + $rig_name + ".locs")`;
    }
    else
    {
    print "no locs info found";
    }
}



    string $name = $rig_pref;
    $fileName = ("/tmp/" + $name + "_pose.mel");
    string $stringAttr;

    if(`filetest -f  $fileName`)
    {

    string $result = `confirmDialog -title ($fileName + " exists")
-message "do you want to overwrite it?" -button "Yes" -button "No"
-defaultButton "Yes" -cancelButton "No" -dismissString "No"`;

        if(`gmatch $result "Yes"` == 1)
        {
        promptDialog -t filename -tx ($rig_pref);
        $name = `promptDialog -q`;
        $fileName = ("/tmp/" + $name + "_pose.mel");
        $fileId = `fopen $fileName "w"`;
       
       
            for($i = 0; $i < size($pose);$i++)
            {
            fprint $fileId ($pose[$i] + "\n");
            $stringAttr += $pose[$i];
            }
        fclose $fileId;
            if(size($stringAttr) > 0)
            {
            setAttr -typ "string" ($rig_prefix + $rig_name + ".locs")
$stringAttr;
            }
        }
   
    }
    else
    {
    promptDialog -t name -tx ($rig_pref);
    $name = `promptDialog -q`;
    $fileName = ("/tmp/" + $name + "_pose.mel");
    $fileId = `fopen $fileName "w"`;
       
        for($i = 0; $i < size($pose);$i++)
        {
        fprint $fileId ($pose[$i] + "\n");
        $stringAttr += $pose[$i];
        }
    fclose $fileId;
            if(size($stringAttr) > 0)
            {
            setAttr -typ "string" ($rig_prefix + $rig_name + ".locs")
$stringAttr;
            }
    }

select -cl;

if(`checkBox -q -v doEnv` == 1)
{
string $dir = `textFieldButtonGrp -q -tx ENV`;

    if(size($dir)>0)
    {
    system("cp /tmp/" + $name + "_pose.mel " + $dir);
    }
}


print "locs copied OK";

}


////===========================
////==========================

global proc paste_locs()
{

//==== global variables

//=== names

global string $rig_pref;
global string $rig_name;
global string $rig_prefix;
global string $prefixL;
global string $prefixR;
global string $rig_dir;

//=== modules

global int $hires;
global int $normal_spines;
global int $long_spines;
global int $long_necks;
global int $short_necks;
global int $heads;
global int $human_arms;
global int $human_legs;
global int $quadr_legs;
global int $human_feet;;
global int $one_finger_hands;
global int $two_finger_hands;
global int $three_finger_hands;
global int $four_finger_hands;
global int $five_finger_hands;
global int $bird_wings;
global int $bat_wings;
global int $tentacles;
global int $tails;
global int $fins;
global int $flippers;
global int $hiresSpine;
global int $hiresReptSpine;
global int $hiresHead;
global int $hiresQuadrLeg;
global int $hiresShortNeck;
global int $hiresLongNeck;
global int $hiresArm;
global int $hiresTentacle;
global int $hiresLeg;
global int $hiresFlipper;
global int $hiresFin;
global int $hires1FingHand;
global int $hiresBirdWing;
global int $hires2FingHand;
global int $hiresBatWing;
global int $hires3FingHand;
global int $hiresTail;
global int $hires4FingHand;
global int $hires5FingHand;


//==== end global variables

getGlobVar ;
   
    //========================


string $fileName = ("/tmp/" + $rig_pref + "_pose.mel");

if(`checkBox -q -v doEnv` == 1)
{
string $dir = `textFieldButtonGrp -q -tx ENV`;

    if(size($dir)>0)
    {
    string $pluto = $dir;
       
        if(`gmatch $dir "*/"` == 1)
        {
        $dir = $pluto;
        }
        else
        {
        $dir = ($pluto+"/");
        }
   
    $fileName = ($dir + $rig_pref + "_pose.mel");
   
       
   
   
    print ("found file: " + $dir + $rig_pref + "_pose.mel");
    }
}

string $source;
string $at;
string $stringAttr;
string $buff[];
string $pip;

    if(`objExists ($rig_prefix + $rig_name + ".locs")`)
    {
    $at = `getAttr ($rig_prefix + $rig_name + ".locs")`;
    }

        if(size($at) > 0)
        {
   
        $numTokens = `tokenize $at ";" $buff`;
       
            for($i = 0; $i < size($buff); $i++)
            {
            eval $buff[$i];
            $stringAttr += $buff[$i];
            }
           
        setAttr -typ "string" ($rig_prefix + $rig_name + ".locs") $stringAttr;
        }
        else
        {
           
            if(`filetest -f  $fileName `)
            {
            string $source = "source \"" + $fileName + "\"";
            eval $source;
       
            $fileId = `fopen $fileName "r"`;
           
                while ( !`feof $fileId` )
                {
                $pip += `fgetline $fileId`;
                }
            setAttr -typ "string" ($rig_prefix + $rig_name + ".locs") $pip;
            fclose $fileId;
            }
            else
            {
            print "not found";
            }

        }
   
print "locs pasted OK";

}

//====================


global proc import_model()
{
fcdbShowLoadGui();
}


global proc do_locs()
{
creature_locs;
//==== global variables

//=== names

global string $rig_pref;
global string $rig_name;
global string $rig_prefix;
global string $prefixL;
global string $prefixR;
global string $rig_dir;

//=== modules

global int $hires;
global int $normal_spines;
global int $long_spines;
global int $long_necks;
global int $short_necks;
global int $heads;
global int $human_arms;
global int $human_legs;
global int $quadr_legs;
global int $human_feet;;
global int $one_finger_hands;
global int $two_finger_hands;
global int $three_finger_hands;
global int $four_finger_hands;
global int $five_finger_hands;
global int $bird_wings;
global int $bat_wings;
global int $tentacles;
global int $tails;
global int $fins;
global int $flippers;
global int $hiresSpine;
global int $hiresReptSpine;
global int $hiresHead;
global int $hiresQuadrLeg;
global int $hiresShortNeck;
global int $hiresLongNeck;
global int $hiresArm;
global int $hiresTentacle;
global int $hiresLeg;
global int $hiresFlipper;
global int $hiresFin;
global int $hires1FingHand;
global int $hiresBirdWing;
global int $hires2FingHand;
global int $hiresBatWing;
global int $hires3FingHand;
global int $hiresTail;
global int $hires4FingHand;
global int $hires5FingHand;


//==== end global variables

getGlobVar ;
   
    //========================


string $fileName = ("/tmp/" + $rig_pref + "_pose.mel");

    if(`checkBox -q -v doEnv` == 1)
    {
    string $dir = `textFieldButtonGrp -q -tx ENV`;
   
        if(size($dir)>0)
        {
        $fileName = ($dir + $rig_pref + "_pose.mel");
        print ("found file: " + $dir + $rig_pref + "_pose.mel");
        }
    }

    paste_locs;

}


global proc int readMEL(string $textField)
{
    global string $FsMel;
    $FsMel = `textFieldButtonGrp -q -tx $textField`;
    return 1;
}

global proc int readENV(string $textField)
{
    global string $FsEnv;
    $FsEnv = `textFieldButtonGrp -q -tx $textField`;
    return 1;
}

global proc int read_mel_script( string $filename, string $fileType )
{
    textFieldButtonGrp -edit -fi $filename MEL;
    return 1;
}

global proc int read_env( string $filename, string $fileType )
{
    textFieldButtonGrp -edit -fi $filename ENV;
    return 1;
}

global proc int read_gec_script( string $filename, string $fileType )
{
    textFieldButtonGrp -edit -fi $filename SETTINGS;
    return 1;
}

global proc do_rig()
{
//==== global variables

//=== names

global string $rig_pref;
global string $rig_name;
global string $rig_prefix;
global string $prefixL;
global string $prefixR;
global string $rig_dir;

//=== modules

global int $hires;
global int $normal_spines;
global int $long_spines;
global int $long_necks;
global int $short_necks;
global int $heads;
global int $human_arms;
global int $human_legs;
global int $quadr_legs;
global int $human_feet;;
global int $one_finger_hands;
global int $two_finger_hands;
global int $three_finger_hands;
global int $four_finger_hands;
global int $five_finger_hands;
global int $bird_wings;
global int $bat_wings;
global int $tentacles;
global int $tails;
global int $fins;
global int $flippers;
global int $doStretch;
global int $doToes;
//global int $doFcdb ;
global int $hiresSpine;
global int $hiresReptSpine;
global int $hiresHead;
global int $hiresQuadrLeg;
global int $hiresShortNeck;
global int $hiresLongNeck;
global int $hiresArm;
global int $hiresTentacle;
global int $hiresLeg;
global int $hiresFlipper;
global int $hiresFin;
global int $hires1FingHand;
global int $hiresBirdWing;
global int $hires2FingHand;
global int $hiresBatWing;
global int $hires3FingHand;
global int $hiresTail;
global int $hires4FingHand;
global int $hires5FingHand;

//==== end global variables

getGlobVar ;

creature_rig;
paste_controls;

}

int $status = 1;

global proc string createQuadLayout(string $parent){

    setParent $parent;
    string $child2 = `optionMenuGrp -label " type" -cc retrieve_quad_type
-columnWidth 1 60 -columnWidth 2 100 QT`;
        menuItem -label "equine";
        menuItem -label "feline";
        menuItem -label "ungulate";
       
   
    return $child2;
}

global proc string createBirdLayout(string $parent){

    setParent $parent;
    string $child3 = `optionMenuGrp -label " type" -cc retrieve_bird_type
-columnWidth 1 60 -columnWidth 2 100 BT`;
        menuItem -label "bird";
        menuItem -label "bat";
        menuItem -label "dragon";

    return $child3;
}


global proc string createReptLayout(string $parent){

    setParent $parent;
    string $child4 = `optionMenuGrp -label " type" -cc
retrieve_reptile_type -columnWidth 1 60 -columnWidth 2 100 RT`;
        menuItem -label "snake";
        menuItem -label "lizzard";

    return $child4;
}


global proc string createFishLayout(string $parent){

    setParent $parent;
        string $child5 = `rowColumnLayout -numberOfColumns 2 -cw 1 100 -cw 2
26`;
    return $child5;   
}


//==== sets

global proc rig_sets()
{

//=== names

global string $rig_pref;
global string $rig_name;
global string $rig_prefix;
global string $prefixL;
global string $prefixR;
global string $rig_dir;
global string $rig_dir;
//=== modules

global int $rig_type;
global int $quad_rig_type;
global int $bird_rig_type;
global int $rept_rig_type;
global int $hires;
global int $normal_spines;
global int $long_spines;
global int $long_necks;
global int $short_necks;
global int $heads;
global int $human_arms;
global int $human_legs;
global int $quadr_legs;
global int $human_feet;
global int $one_finger_hands;
global int $two_finger_hands;
global int $three_finger_hands;
global int $four_finger_hands;
global int $five_finger_hands;
global int $bird_wings;
global int $bat_wings;
global int $tentacles;
global int $tails;
global int $fins;
global int $flippers;
global int $doStretch;
global int $doToes;
global int $hiresSpine;
global int $hiresReptSpine;
global int $hiresHead;
global int $hiresQuadrLeg;
global int $hiresShortNeck;
global int $hiresLongNeck;
global int $hiresArm;
global int $hiresTentacle;
global int $hiresLeg;
global int $hiresFlipper;
global int $hiresFin;
global int $hires1FingHand;
global int $hiresBirdWing;
global int $hires2FingHand;
global int $hiresBatWing;
global int $hires3FingHand;
global int $hiresTail;
global int $hires4FingHand;
global int $hires5FingHand;

getGlobVar ;
   
    if($hires == 1)
    {
    checkBox -e -v 1 doToes;
    checkBox -e -v 1 hiresSpine;
    checkBox -e -v 1 hiresReptSpine;
    checkBox -e -v 1 hiresHead;
    checkBox -e -v 1 hiresQuadrLeg;
    checkBox -e -v 1 hiresShortNeck;
    checkBox -e -v 1 hiresLongNeck;
    checkBox -e -v 1 hiresArm;
    checkBox -e -v 1 hiresTentacle;
    checkBox -e -v 1 hiresLeg;
    checkBox -e -v 1 hiresFlipper;
    checkBox -e -v 1 hiresFin;
    checkBox -e -v 1 hires1FingHand;
    checkBox -e -v 1 hiresBirdWing;
    checkBox -e -v 1 hires2FingHand;
    checkBox -e -v 1 hiresBatWing;
    checkBox -e -v 1 hires3FingHand;
    checkBox -e -v 1 hiresTail;
    checkBox -e -v 1 hires4FingHand;
    checkBox -e -v 1 hires5FingHand;
    }
    else
    {
    checkBox -e -v 0 doToes;
    checkBox -e -v 0 hiresSpine;
    checkBox -e -v 0 hiresReptSpine;
    checkBox -e -v 0 hiresHead;
    checkBox -e -v 0 hiresQuadrLeg;
    checkBox -e -v 0 hiresShortNeck;
    checkBox -e -v 0 hiresLongNeck;
    checkBox -e -v 0 hiresArm;
    checkBox -e -v 0 hiresTentacle;
    checkBox -e -v 0 hiresLeg;
    checkBox -e -v 0 hiresFlipper;
    checkBox -e -v 0 hiresFin;
    checkBox -e -v 0 hires1FingHand;
    checkBox -e -v 0 hiresBirdWing;
    checkBox -e -v 0 hires2FingHand;
    checkBox -e -v 0 hiresBatWing;
    checkBox -e -v 0 hires3FingHand;
    checkBox -e -v 0 hiresTail;
    checkBox -e -v 0 hires4FingHand;
    checkBox -e -v 0 hires5FingHand;
    }
   

    if($rig_type == 1)
    {
    resetVar;
    intField -e -v 1 normal_spines;
    intField -e -v 1 short_necks;
    intField -e -v 1 heads;
    intField -e -v 2 human_arms;
    intField -e -v 2 human_legs;
    intField -e -v 2 human_feet;
    intField -e -v 2 five_fing_hands;
    }

    if($rig_type == 2)
    {
        if($quad_rig_type == 1)
        {
        resetVar;
        intField -e -v 1 normal_spines;
        intField -e -v 1 short_necks;
        intField -e -v 1 heads;
        intField -e -v 4 human_arms;
        intField -e -v 4 one_fing_hands;
        intField -e -v 1 tails;
        }
        if($quad_rig_type == 2)
        {
        resetVar;
        intField -e -v 1 normal_spines;
        intField -e -v 1 short_necks;
        intField -e -v 1 heads;
        intField -e -v 4 human_arms;
        intField -e -v 4 four_fing_hands;
        intField -e -v 1 tails;
        }
        if($quad_rig_type == 3)
        {
        resetVar;
        intField -e -v 1 normal_spines;
        intField -e -v 1 short_necks;
        intField -e -v 1 heads;
        intField -e -v 4 human_arms;
        intField -e -v 4 two_fing_hands;
        intField -e -v 1 tails;
        }   
    }

    if($rig_type == 3)
    {
        if($bird_rig_type == 1)
        {
        resetVar;
        intField -e -v 1 normal_spines;
        intField -e -v 1 long_necks;
        intField -e -v 1 heads;
        intField -e -v 4 human_arms;
        //intField -e -v 2 human_legs;
        intField -e -v 2 two_fing_hands;
        intField -e -v 2 four_fing_hands;
        }
        if($bird_rig_type == 2)
        {
        resetVar;
        intField -e -v 1 normal_spines;
        intField -e -v 1 short_necks;
        intField -e -v 1 heads;
        intField -e -v 2 bat_wings;
        intField -e -v 2 human_legs;
        intField -e -v 2 four_fing_hands;
        }
        if($bird_rig_type == 3)
        {
        resetVar;
        intField -e -v 1 normal_spines;
        intField -e -v 1 short_necks;
        intField -e -v 1 heads;
        intField -e -v 2 bat_wings;
        intField -e -v 2 human_legs;
        intField -e -v 2 four_fing_hands;
        intField -e -v 1 tails;
        }
    }
   
    if($rig_type == 4)
    {
        if($rept_rig_type == 1)
        {
        resetVar;
        intField -e -v 1 reptile_spines;
        intField -e -v 1 heads;
        }
        if($rept_rig_type == 2)
        {
        resetVar;
        intField -e -v 1 reptile_spines;
        intField -e -v 1 heads;
        intField -e -v 4 human_arms;
        intField -e -v 4 five_fing_hands;
        intField -e -v 1 tails;
        }
    }
   
    if($rig_type == 5)
    {
    resetVar;
    intField -e -v 1 normal_spines;
    intField -e -v 1 heads;
    intField -e -v 4 fins;
    }

}


global proc retrieve_reptile_type()
{
int $rept_rig_type = `optionMenuGrp -q -sl RT`;
rig_sets;
}

global proc retrieve_bird_type()
{
int $bird_rig_type = `optionMenuGrp -q -sl BT`;
rig_sets;
}


global proc retrieve_quad_type()
{
int $quad_rig_type = `optionMenuGrp -q -sl QT`;
rig_sets;
}

//==== quads
//==== quads
//==== quads
//==== quads

global proc retrieve_rig_type()
{
int $rig_type = `optionMenuGrp -q -sl GEC`;
tabLayout -e -sti $rig_type TABS;
rig_sets;
}

global proc retrieve_rig_res()
{
$hires = (`optionMenuGrp -q -sl RES` -1);

    if($hires == 1)
    {
    checkBox -e -v 1 doToes;
    checkBox -e -v 1 hiresSpine;
    checkBox -e -v 1 hiresReptSpine;
    checkBox -e -v 1 hiresHead;
    checkBox -e -v 1 hiresQuadrLeg;
    checkBox -e -v 1 hiresShortNeck;
    checkBox -e -v 1 hiresLongNeck;
    checkBox -e -v 1 hiresArm;
    checkBox -e -v 1 hiresTentacle;
    checkBox -e -v 1 hiresLeg;
    checkBox -e -v 1 hiresFlipper;
    checkBox -e -v 1 hiresFin;
    checkBox -e -v 1 hires1FingHand;
    checkBox -e -v 1 hiresBirdWing;
    checkBox -e -v 1 hires2FingHand;
    checkBox -e -v 1 hiresBatWing;
    checkBox -e -v 1 hires3FingHand;
    checkBox -e -v 1 hiresTail;
    checkBox -e -v 1 hires4FingHand;
    checkBox -e -v 1 hires5FingHand;
    }
    else
    {
    checkBox -e -v 0 doToes;
    checkBox -e -v 0 hiresSpine;
    checkBox -e -v 0 hiresReptSpine;
    checkBox -e -v 0 hiresHead;
    checkBox -e -v 0 hiresQuadrLeg;
    checkBox -e -v 0 hiresShortNeck;
    checkBox -e -v 0 hiresLongNeck;
    checkBox -e -v 0 hiresArm;
    checkBox -e -v 0 hiresTentacle;
    checkBox -e -v 0 hiresLeg;
    checkBox -e -v 0 hiresFlipper;
    checkBox -e -v 0 hiresFin;
    checkBox -e -v 0 hires1FingHand;
    checkBox -e -v 0 hiresBirdWing;
    checkBox -e -v 0 hires2FingHand;
    checkBox -e -v 0 hiresBatWing;
    checkBox -e -v 0 hires3FingHand;
    checkBox -e -v 0 hiresTail;
    checkBox -e -v 0 hires4FingHand;
    checkBox -e -v 0 hires5FingHand;
    }

}

global proc update_rigPrefix(string $textField)
{
    global string $FsRigPrefix;
    //getGlobVar;
    $FsRigPrefix = `textField -q -tx $textField`;

}

global proc update_rigName(string $textField)
{

    global string $FsRigName;
    //getGlobVar;
    $FsRigName = `textField -q -tx $textField`;

}

global proc doPostscript()
{

string $postscriptname = eval("textFieldButtonGrp -q -tx MEL");
string $script;
string $tokens[];
string $script;
string $scriptName;
string $melscript;

    if(size($postscriptname) > 0)
    {
    $script = ("source \"" + $postscriptname + "\"");
    //tokenize $postscriptname "/" $tokens;
    //$scriptName =  $tokens[(size($tokens)-1)];
    //$melscript = `substring $scriptName 1 (size($scriptName) - 4)`;
    eval $script;
    //eval $melscript;
    }
    else
    {
    print "NOTHING TO RUN";
    }

}


global proc doAll()
{

global string $rig_prefix;
global string $rig_name;
global string $rig_dir;
global int $doEnv;

getGlobVar;

file -f -new;

string $model = `textFieldButtonGrp -q -tx fcdbGEO`;

    if(size($model) > 0)
    {
    getFcdbGEO;
    }
   
do_locs;
do_rig;
paste_controls;
copy_settings;
connect_sec;


//========================================================================================
//=== do post mel script
//========================================================================================

    if(`checkBox -q -v doPost` == 1)
    {
    doPostscript;
    }
    
//========================================================================================
//==== bind
//========================================================================================

load_env;

}



global proc fs_build_rig()
{

//==== global variables

global string $FsRigPrefix;
global string $FsRigName;

//=== names

global string $rig_pref;
global string $rig_name;
global string $rig_prefix;
global string $prefixL;
global string $prefixR;
global string $rig_dir;

//=== modules

global int $hires;
global int $normal_spines;
global int $long_spines;
global int $long_necks;
global int $short_necks;
global int $heads;
global int $human_arms;
global int $human_legs;
global int $quadr_legs;
global int $human_feet;;
global int $one_finger_hands;
global int $two_finger_hands;
global int $three_finger_hands;
global int $four_finger_hands;
global int $five_finger_hands;
global int $bird_wings;
global int $bat_wings;
global int $tentacles;
global int $tails;
global int $fins;
global int $flippers;
global int $hiresSpine;
global int $hiresReptSpine;
global int $hiresHead;
global int $hiresQuadrLeg;
global int $hiresShortNeck;
global int $hiresLongNeck;
global int $hiresArm;
global int $hiresTentacle;
global int $hiresLeg;
global int $hiresFlipper;
global int $hiresFin;
global int $hires1FingHand;
global int $hiresBirdWing;
global int $hires2FingHand;
global int $hiresBatWing;
global int $hires3FingHand;
global int $hiresTail;
global int $hires4FingHand;
global int $hires5FingHand;

getGlobVar ;

//==== end global variables


if ( `window -exists fs_rig_builder` )
deleteUI -window fs_rig_builder;
string $window = `window -title "FS GENERIC RIG BUILDER"
fs_rig_builder`;





                    string $bodyform = `formLayout`;

                    string $bodytabs = `tabLayout -innerMarginWidth 5
-innerMarginHeight 5` ;

                    formLayout -edit

                    -attachForm $bodytabs "top"    0

                      -attachForm $bodytabs "left"   0

                      -attachForm $bodytabs "bottom" 0

                      -attachForm $bodytabs "right"  0
                                       
                      $bodyform;


$bodyLayout = `columnLayout`;
text -l "" -height 10;
setParent $bodyLayout;


$row = `rowColumnLayout -cw 1 60 -cw 2 40 -cw 3 50 -numberOfColumns 4`;

if($FsRigPrefix == "")
    $FsRigPrefix = "CR00";

if($FsRigName == "")
    $FsRigName = "CREATURE_ROOT";

text -l "PREFIX" -fn boldLabelFont -al right;
textField -tx $FsRigPrefix -ip 0 -fn boldLabelFont -cc
"update_rigPrefix RIG_PREFIX" -w 30 -h 25 RIG_PREFIX;

text -l "_NAME" -fn boldLabelFont -al right;
textField -tx $FsRigName -ip 0 -fn boldLabelFont -cc "update_rigName RIG_NAME" -w 100 -h 25 RIG_NAME;

separator -height 10;
separator -height 10;
separator -height 10;
separator -height 10;
setParent $row;
setParent $bodyLayout;

text -l "" -height 5;
text -l "GEC file (overall setup)" -fn boldLabelFont -height 20;
text -l "" -height 5;

textFieldButtonGrp -w 270 -ad2 1 -buttonLabel "Browse"  -fi "" -buttonCommand "fileBrowser(\"read_gec_script\",\"OK\", \"\", 0);" SETTINGS;
setParent $bodyLayout;

$secLayout = `rowColumnLayout -cw 1 125 -cw 2 125 -numberOfColumns 2`;

button -label "COPY GEC" -c copy_settings -w 92 -h 25 COPY_SET;
button -label "SAVE GEC" -c save_settings -w 92 -h 25 STORE_SET;
button -label "REFRESH" -c sourceGEC -w 92 -h 25 REFRESH;
button -label "EDIT GEC" -c editSet -w 92 -h 25 EDITSETTINGS;
setParent $secLayout;
separator -height 20;
separator -height 20;
setParent $bodyLayout;

$secLayout = `rowColumnLayout -cw 1 125 -cw 2 125 -numberOfColumns 2`;

text -l "GEOMETRY" -fn boldLabelFont -al left -height 20;
text -l "";
//checkBox -l "fcdb element" fcdb;
setParent $secLayout;
setParent $bodyLayout;

textFieldButtonGrp -w 260 -ad2 1 -buttonLabel "load GEO"  -fi "" -buttonCommand "getFcdbGEO" fcdbGEO;
setParent $bodyLayout;



$secLayout = `rowColumnLayout -cw 1 125 -cw 2 125 -numberOfColumns 2`;
separator -height 20;
separator -height 20;

button -label "IMPORT LOCS" -c do_locs        -h 25 GO;
button -label "RIG" -c do_rig            -h 25 RIG;
button -label "STORE LOCS" -c copy_locs        -h 25 COPY_LOCS;
button -label "STORE CTRLS" -c copy_controls    -h 25 COPY_CAGES;
button -label "PASTE LOCS" -c paste_locs    -h 25 PASTE_LOCS;
button -label "STORE ENV" -c copy_env    -h 25 PASTE_CAGES;

separator -height 20;
separator -height 20;

setParent $secLayout;
setParent $bodyLayout;

$secLayout = `rowColumnLayout -cw 1 125 -cw 2 125 -numberOfColumns 2`;
text -l "STORED INFO" -fn boldLabelFont -al left -height 20;
checkBox -l "specify directory" doEnv;
setParent $secLayout;
setParent $bodyLayout;

textFieldButtonGrp -w 270 -ad2 1 -buttonLabel "Browse"  -fi ""
-buttonCommand "fileBrowser(\"read_env\",\"OK\", \"\", 4);" ENV;
setParent $bodyLayout;

$secLayout = `rowColumnLayout -cw 1 125 -cw 2 125 -numberOfColumns 2`;
separator -height 20;
separator -height 20;
setParent $secLayout;
setParent $bodyLayout;


$secLayout = `rowColumnLayout -cw 1 125 -cw 2 125 -numberOfColumns 2`;
text -l "POST SCRIPT" -fn boldLabelFont -al left -height 20;
checkBox -l "use script" doPost;
setParent $secLayout;
setParent $bodyLayout;

textFieldButtonGrp -w 270 -ad2 1 -buttonLabel "Browse"  -fi ""
-buttonCommand "fileBrowser(\"read_mel_script\",\"OK\", \"\", 0);" MEL;

setParent $bodyLayout;

$secLayout = `rowColumnLayout -cw 1 125 -cw 2 125 -numberOfColumns 2`;


button -label "EDIT SCRIPT" -c editMel -w 92 -h 25 EDITMEL;
button -label "RUN SCRIPT" -c doPostscript -w 92 -h 25 DOMEL;
separator -height 20;
separator -height 20;
setParent $secLayout;
setParent $bodyLayout;

button -label "DO ALL" -c doAll -w 250 -h 40 DOALL;
setParent $bodyLayout;

$secLayout = `rowColumnLayout -cw 1 125 -cw 2 125 -numberOfColumns 2`;

separator -height 20;
separator -height 20;
optionMenuGrp -label " RES" -cc retrieve_rig_res -columnWidth 1 60 -columnWidth 2 100 RES;
menuItem -label "lores";
menuItem -label "hires";

checkBox -l "STRETCHY" doStretch;
setParent $secLayout;
setParent $bodyLayout;

optionMenuGrp -label " RIG" -cc retrieve_rig_type -columnWidth 1 60 -columnWidth 2 100 GEC;
menuItem -label "biped";
menuItem -label "quadruped";
menuItem -label "volatile";
menuItem -label "reptile";
menuItem -label "fish";
//menuItem -label "freak";
//menuItem -label "grindylow";
//menuItem -label "harryFlip";
//menuItem -label "mermaid";

text -l "" -height 20;



    string $form = `formLayout`;
    string $tabs = `tabLayout -innerMarginWidth 0 -innerMarginHeight 0
-tv 0 TABS`;
    formLayout -edit
        -attachForm $tabs "top"    0
        -attachForm $tabs "left"   0
        -attachForm $tabs "bottom" 0
        -attachForm $tabs "right"  0
        $form;
       
        string $child1 = `rowColumnLayout -numberOfColumns 3`;
                //checkBox -l "TOES" doToes;
                setParent ..;

        string $child2 = `createQuadLayout $tabs`;

        string $child3 = `createBirdLayout $tabs`;

        string $child4 = `createReptLayout $tabs`;
       
        string $child5 = `createFishLayout $tabs`;

        //string $child6 = `createFreakLayout $tabs`;
               
        //string $child7 = `createGrindylowLayout $tabs`;

        //string $child8 = `createHarryFlippersLayout $tabs`;

        //string $child9 = `createMermaidLayout $tabs`;
       
//tabLayout -edit -tabLabel $child1 "biped" -tabLabel $child2 "quadruped" -tabLabel $child3 "volatile" -tabLabel $child4 "reptile" -tabLabel $child5 "fish" -tabLabel $child6 "freak" -tabLabel $child7 "grindylow" -tabLabel $child8 "harryFlip" -tabLabel $child9 "mermaid" $tabs;tabLayout -edit -tabLabel $child1 "biped" -tabLabel $child2 "quadruped" -tabLabel $child3 "volatile" -tabLabel $child4 "reptile" -tabLabel $child5 "fish" $tabs;
         


setParent $bodyLayout;

$freak = `rowColumnLayout -numberOfColumns 6 -cw 1 62 -cw 2 26 -cw 3 42 -cw 4 72 -cw 5 26 -cw 6 20`;

separator -h 10;
separator -h 10;
separator -h 10;
separator -h 10;
separator -h 10;
separator -h 10;

text -l "modules: ";
text -l "";
text -l "";
text -l "tick for hires";
text -l "";
text -l "";

separator -h 10;
separator -h 10;
separator -h 10;
separator -h 10;
separator -h 10;
separator -h 10;


button -l "spines" -c do_spine;         intField -v 0 -w 30 -h 25 normal_spines;        checkBox -l  ""hiresSpine;
button -l "longSpines";                 intField -v 0 -w 30 -h 25 reptile_spines;       checkBox  -l ""hiresReptSpine;
button -l "heads" -c do_head;           intField -v 0 -w 30 -h 25 heads;                checkBox  -l ""hiresHead;
button -l "quadrLegs";                  intField -v 0 -w 30 -h 25 quadr_legs;           checkBox  -l ""hiresQuadrLeg;
button -l "necks"  -c do_short_neck;    intField -v 0 -w 30 -h 25 short_necks;          checkBox  -l ""hiresShortNeck;
button -l "longNecks";                  intField -v 0 -w 30 -h 25 long_necks;           checkBox  -l ""hiresLongNeck;
button -l "arms" -c do_arm;             intField -v 0 -w 30 -h 25 human_arms;           checkBox  -l ""hiresArm;
button -l "tentac";                     intField -v 0 -w 30 -h 25 tentacles;            checkBox -l "" hiresTentacle;
button -l "legs" -c do_leg;             intField -v 0 -w 30 -h 25 human_legs;           checkBox -l "" hiresLeg;
button -l "flippers";                   intField -v 0 -w 30 -h 25 flippers;             checkBox  -l ""hiresFlipper;
button -l "feet" -c do_foot;            intField -v 0 -w 30 -h 25 human_feet;           checkBox  -l ""doToes;
button -l "fins";                       intField -v 0 -w 30 -h 25 fins;                 checkBox  -l ""hiresFin;
button -l "1fHands" -c do_hand;         intField -v 0 -w 30 -h 25 one_fing_hands;       checkBox  -l ""hires1FingHand;
button -l "wings";                      intField -v 0 -w 30 -h 25 bird_wings;           checkBox -l "" hiresBirdWing;
button -l "2fHands" -c do_hand;         intField -v 0 -w 30 -h 25 two_fing_hands;       checkBox  -l ""hires2FingHand;
button -l "batWings";                   intField -v 0 -w 30 -h 25 bat_wings;            checkBox -l "" hiresBatWing;
button -l "3fHands" -c do_hand;         intField -v 0 -w 30 -h 25 three_fing_hands;     checkBox  -l ""hires3FingHand;
button -l "tails";                      intField -v 0 -w 30 -h 25 tails;                checkBox  -l ""hiresTail;
button -l "4fHands" -c do_hand;         intField -v 0 -w 30 -h 25 four_fing_hands;      checkBox -l "" hires4FingHand;
button -l "5fHands" -c do_hand;         intField -v 0 -w 30 -h 25 five_fing_hands;      checkBox  -l ""hires5FingHand;

separator -h 10;
separator -h 10;
separator -h 10;
separator -h 10;
separator -h 10;
separator -h 10;
separator -h 10;
separator -h 10;
separator -h 10;
separator -h 10;
separator -h 10;
separator -h 10;
setParent $bodyLayout;

button -label "RESET" -c "resetVar" -w 250 -h 40 RESET;
setParent $bodyLayout;


setParent ..;


//===========================================================================================================================
//===========================================================================================================================
//===========================================================================================================================
//===========================================================================================================================
//==================================================    FACE    =============================================================
//===========================================================================================================================
//===========================================================================================================================
//===========================================================================================================================




$faceLayout = `columnLayout -adjustableColumn true`;

//source "/net/soft/fscfc/creatures/generic/RIG/rig_builder/faceLayout";

setParent $faceLayout;

setParent ..;

$propsLayout = `columnLayout -adjustableColumn true`;

//source "/net/soft/fscfc/creatures/generic/RIG/rig_builder/faceLayout";

setParent $propsLayout;



//=== end face layout


       
        tabLayout -edit

              -tabLabel $bodyLayout "MAIN" -tabLabel $faceLayout "FACE"
-tabLabel $propsLayout "PROPS" 

              $bodytabs;

window -e -wh 288 1045 -s 0 $window;
showWindow $window;
readMEL MEL;
readENV ENV;
rig_sets;

}




source "generateChannelMenu.mel";
//fcConstraint;


//==== tentacle locs
//================================

global proc string[] build_tentacle(string $name, int $num, float
$step)
{

string $locs[];
string $pivs[];
string $cls[];
string $upvs[];
float $locx;
float $locy;
float $locz;
string $cmd = "curve -n " + $name + "_CRV -d 2 ";

    //float $step = 3.000;
    float $scale = 0.77;
    float $offset = 0.000;

    for($i = 0; $i < $num; $i++)
    {
    $locNum = ($i + 1);
    spaceLocator -name ($name + "_" + $locNum + "_PIV");
    spaceLocator -name ($name + "_" + $locNum + "_LOC");
    spaceLocator -name ($name + "_" + $locNum + "_upv_LOC");
    $pivs[`size $pivs`] = ($name + "_" + $locNum + "_PIV");
    $locs[`size $locs`] = ($name + "_" + $locNum + "_LOC");
    $upvs[`size $upvs`] = ($name + "_" + $locNum + "_upv_LOC");
   
   
    setAttr ($name + "_" + $locNum + "_upv_LOC.ty") $offset;
    setAttr ($name + "_" + $locNum + "_upv_LOC.tx") 3;
    setAttr ($name + "_" + $locNum + "_LOC.ty") $offset;
    setAttr ($name + "_" + $locNum + "_PIV.ty") $offset;
   
    $offset -= $step;
    $step *= $scale;
       
    parent ($name + "_" + $locNum + "_upv_LOC") ($name + "_" + $locNum +  "_PIV");
    select ($name + "_" + $locNum + "_PIV") ($name + "_" + $locNum +  "_LOC");
    pointConstraint -name ($name + "_" + $locNum + "_loc_POC");

    setAttr ($name + "_" + $locNum + "_upv_LOC.v") 0;
    $locx = `getAttr ($name + "_" + $locNum + "_PIV.tx")`;
    $locy = `getAttr ($name + "_" + $locNum + "_PIV.ty")`;
    $locz = `getAttr ($name + "_" + $locNum + "_PIV.tz")`;
    $cmd += "-p " + $locx + " " + $locy + " " + $locz + " ";
   
            if($i > 0)
            {
            select ($name + "_" + $locNum + "_LOC") ($name + "_" + ($locNum -1)
+ "_LOC");
            aimConstraint -n ($name + "_" + ($locNum -1) + "_loc_AIC") -weight 1
-aimVector 1 0 0 -upVector 0 -1 0 -worldUpType "object" -worldUpObject
($name + "_" + ($locNum -1) + "_upv_LOC");
                if($locNum == $num)
                {
                select ($name + "_" + ($locNum -1) + "_LOC") ($name + "_" + $locNum
+ "_LOC");
                aimConstraint -n ($name + "_" + $locNum + "_loc_AIC") -weight 1
-aimVector -1 0 0 -upVector 0 -1 0 -worldUpType "object" -worldUpObject
($name + "_" + $locNum + "_upv_LOC");
                }
            }
       
   
    }

eval($cmd);
string $curves[] = `ls -sl`;
string $curve = $curves[0];

    for($i = 0; $i < size($pivs); $i++)
    {
    $locNum = ($i + 1);
float $pos[] = `getAttr ($name + "_CRV.controlPoints[" + $i + "]")`;
spaceLocator -name ($name + "_" + $locNum + "_CLS");
setAttr ($name + "_" + $locNum + "_CLS.v") 0;
setAttr ($name + "_" + $locNum + "_CLS.t") $pos[0] $pos[1] $pos[2];
connectAttr ($name + "_" + $locNum + "_CLS.worldPosition[0]") ($name +  "_CRV.controlPoints[" + $i + "]");
    parent ($name + "_" + $locNum + "_CLS") ($name + "_" + $locNum +  "_PIV");
$cls[`size $cls`] = ($name + "_" + $locNum + "_CLS");
    }

select $curve;
string $upvCurve[] = `duplicate -name ($name + "_upv_CRV")`;

    for($i = 0; $i < size($pivs); $i++)
    {
    $locNum = ($i + 1);
   
   
float $upvpos[] = `getAttr ($name + "_" + $locNum +  "_upv_LOC.worldPosition")`;
spaceLocator -name ($name + "_" + $locNum + "_upv_CLS");
setAttr ($name + "_" + $locNum + "_upv_CLS.t") $upvpos[0] $upvpos[1]
$upvpos[2];
connectAttr ($name + "_" + $locNum + "_upv_CLS.worldPosition[0]")
($name + "_upv_CRV.controlPoints[" + $i + "]");
parent ($name + "_" + $locNum + "_upv_CLS") ($name + "_" + $locNum +  "_CLS");
$cls[`size $cls`] = ($name + "_" + $locNum + "_upv_CLS");
   
   
    }



if(size($pivs) == 3)
{
setAttr -keyable false ($pivs[1] + ".rx");
setAttr -keyable false ($pivs[1] + ".ry");
setAttr -keyable false ($pivs[1] + ".rz");
}


$GRP = `CreateEmptyGroup`;
rename $GRP ($name + "_GRP");
parent $pivs $locs ($name + "_GRP");

$clsGRP = `CreateEmptyGroup`;
rename $clsGRP ($name + "_no_trans_GRP");
parent $curve $upvCurve ($name + "_no_trans_GRP");
setAttr ($upvCurve[0] + ".template") 1;
setAttr ($curve + ".template") 1;
select -cl;


if($num == 3)
{
select $pivs;
averageOrient;
}

select $pivs;
string $listu[] = `ls -sl`;

rename $pivs[0] ($name + "_root_PIV");
rename $pivs[size($listu)-1] ($name + "_end_PIV");

rename $locs[0] ($name + "_root_LOC");
rename $locs[size($listu)-1] ($name + "_end_LOC");

rename $upvs[0] ($name + "_root_upv_LOC");
rename $upvs[size($listu)-1] ($name + "_end_upv_LOC");

rename $cls[0] ($name + "_root_CLS");
rename $cls[size($listu)-1] ($name + "_end_CLS");

$pivs[0] = ($name + "_root_PIV");
$pivs[size($listu)-1] = ($name + "_end_PIV");

select -cl;
return $pivs;

}


//==== end build tentacle
//=============================================
//=============================================
//=============================================

//==== flipper locs
//================================

global proc string[] build_flipper(string $name, int $num)
{

string $locs[];
string $pivs[];
string $cls[];
string $upvs[];
float $locx;
float $locy;
float $locz;
string $cmd = "curve -n " + $name + "_CRV -d 2 ";

    float $step = 3.000;
    float $scale = 0.77;
    float $offset = 0.000;

    for($i = 0; $i < $num; $i++)
    {
    $locNum = ($i + 1);
    spaceLocator -name ($name + "_" + $locNum + "_PIV");
    spaceLocator -name ($name + "_" + $locNum + "_LOC");
    spaceLocator -name ($name + "_" + $locNum + "_upv_LOC");
    $pivs[`size $pivs`] = ($name + "_" + $locNum + "_PIV");
    $locs[`size $locs`] = ($name + "_" + $locNum + "_LOC");
    $upvs[`size $upvs`] = ($name + "_" + $locNum + "_upv_LOC");
   
   
    setAttr ($name + "_" + $locNum + "_upv_LOC.ty") $offset;
    setAttr ($name + "_" + $locNum + "_upv_LOC.tx") 3;
    setAttr ($name + "_" + $locNum + "_LOC.ty") $offset;
    setAttr ($name + "_" + $locNum + "_PIV.ty") $offset;
   
    $offset -= $step;
    $step *= $scale;
       
    parent ($name + "_" + $locNum + "_upv_LOC") ($name + "_" + $locNum +  "_PIV");
    select ($name + "_" + $locNum + "_PIV") ($name + "_" + $locNum +  "_LOC");
    pointConstraint -name ($name + "_" + $locNum + "_loc_POC");

    setAttr ($name + "_" + $locNum + "_upv_LOC.v") 0;
    $locx = `getAttr ($name + "_" + $locNum + "_PIV.tx")`;
    $locy = `getAttr ($name + "_" + $locNum + "_PIV.ty")`;
    $locz = `getAttr ($name + "_" + $locNum + "_PIV.tz")`;
    $cmd += "-p " + $locx + " " + $locy + " " + $locz + " ";
   
            if($i > 0)
            {
            select ($name + "_" + $locNum + "_LOC") ($name + "_" + ($locNum -1)
+ "_LOC");
            aimConstraint -n ($name + "_" + ($locNum -1) + "_loc_AIC") -weight 1
-aimVector 1 0 0 -upVector 0 -1 0 -worldUpType "object" -worldUpObject
($name + "_" + ($locNum -1) + "_upv_LOC");
                if($locNum == $num)
                {
                select ($name + "_" + ($locNum -1) + "_LOC") ($name + "_" + $locNum
+ "_LOC");
                aimConstraint -n ($name + "_" + $locNum + "_loc_AIC") -weight 1
-aimVector -1 0 0 -upVector 0 -1 0 -worldUpType "object" -worldUpObject
($name + "_" + $locNum + "_upv_LOC");
                }
            }
       
   
    }

eval($cmd);
string $curves[] = `ls -sl`;
string $curve = $curves[0];

    for($i = 0; $i < size($pivs); $i++)
    {
    $locNum = ($i + 1);
float $pos[] = `getAttr ($name + "_CRV.controlPoints[" + $i + "]")`;
spaceLocator -name ($name + "_" + $locNum + "_CLS");
setAttr ($name + "_" + $locNum + "_CLS.v") 0;
setAttr ($name + "_" + $locNum + "_CLS.t") $pos[0] $pos[1] $pos[2];
connectAttr ($name + "_" + $locNum + "_CLS.worldPosition[0]") ($name +  "_CRV.controlPoints[" + $i + "]");
    parent ($name + "_" + $locNum + "_CLS") ($name + "_" + $locNum +  "_PIV");
$cls[`size $cls`] = ($name + "_" + $locNum + "_CLS");
    }

select $curve;
string $upvCurve[] = `duplicate -name ($name + "_upv_CRV")`;

    for($i = 0; $i < size($pivs); $i++)
    {
    $locNum = ($i + 1);
   
   
float $upvpos[] = `getAttr ($name + "_" + $locNum +  "_upv_LOC.worldPosition")`;
spaceLocator -name ($name + "_" + $locNum + "_upv_CLS");
setAttr ($name + "_" + $locNum + "_upv_CLS.t") $upvpos[0] $upvpos[1]
$upvpos[2];
connectAttr ($name + "_" + $locNum + "_upv_CLS.worldPosition[0]")
($name + "_upv_CRV.controlPoints[" + $i + "]");
parent ($name + "_" + $locNum + "_upv_CLS") ($name + "_" + $locNum +  "_CLS");
$cls[`size $cls`] = ($name + "_" + $locNum + "_upv_CLS");
   
   
    }



if(size($pivs) == 3)
{
setAttr -keyable false ($pivs[1] + ".rx");
setAttr -keyable false ($pivs[1] + ".ry");
setAttr -keyable false ($pivs[1] + ".rz");
}


$GRP = `CreateEmptyGroup`;
rename $GRP ($name + "_GRP");
parent $pivs $locs ($name + "_GRP");

$clsGRP = `CreateEmptyGroup`;
rename $clsGRP ($name + "_no_trans_GRP");
parent $curve $upvCurve ($name + "_no_trans_GRP");
setAttr ($upvCurve[0] + ".template") 1;
setAttr ($curve + ".template") 1;
select -cl;


if($num == 3)
{
select $pivs;
averageOrient;
}

select $pivs;
string $listu[] = `ls -sl`;

rename $pivs[0] ($name + "_root_PIV");
rename $pivs[size($listu)-1] ($name + "_end_PIV");

rename $locs[0] ($name + "_root_LOC");
rename $locs[size($listu)-1] ($name + "_end_LOC");

rename $upvs[0] ($name + "_root_upv_LOC");
rename $upvs[size($listu)-1] ($name + "_end_upv_LOC");

rename $cls[0] ($name + "_root_CLS");
rename $cls[size($listu)-1] ($name + "_end_CLS");

$pivs[0] = ($name + "_root_PIV");
$pivs[size($listu)-1] = ($name + "_end_PIV");

select -cl;
return $pivs;

}


//==== end build flipper
//=============================================
//=============================================
//=============================================


global proc visualize()
{
/*
modelEditor -e -allObjects 0 modelPanel1;
modelEditor -e -polymeshes 1 modelPanel1;
modelEditor -e -locators 1 modelPanel1;
modelEditor -e -nurbsCurves 1 modelPanel1;
modelEditor -e -joints 1 modelPanel1;


modelEditor -e -allObjects 0 modelPanel2;
modelEditor -e -polymeshes 1 modelPanel2;
modelEditor -e -locators 1 modelPanel2;
modelEditor -e -nurbsCurves 1 modelPanel2;
modelEditor -e -joints 1 modelPanel2;

modelEditor -e -allObjects 0 modelPanel3;
modelEditor -e -polymeshes 1 modelPanel3;
modelEditor -e -locators 1 modelPanel3;
modelEditor -e -nurbsCurves 1 modelPanel3;
modelEditor -e -joints 1 modelPanel3;

modelEditor -e -allObjects 0 modelPanel4;
modelEditor -e -polymeshes 1 modelPanel4;
modelEditor -e -locators 1 modelPanel4;
modelEditor -e -nurbsCurves 1 modelPanel4;
modelEditor -e -joints 1 modelPanel4;
*/
}


//=============================================
//======================================= SPINE
//=============================================

string $normalSpineLocs[];

global proc string[] normal_spine(string $spineName)
{
    string $normalSpineLocs[];
    cycleCheck -e off;
    visualize;
   
    int $rig_type = `optionMenuGrp -q -sl GEC`;
   
    string $name;
        if(`gmatch $spineName "*_"` == 1)
        {
        $name = $spineName;
        }
        else
        {
        $name = ($spineName + "_");
        }
       
   
    file -import -type "mayaBinary" -rpr $name
("/hosts/guildford/user_data/ARCHIVE/FELIX/RIG/MODULES/1/SPINE/linear_spine.mb");
   
    select SEL;
    string $list[] = `ls -sl`;
    string $item;
    for($item in $list)
    {
    rename $item ($name + $item);
    }
    sets -rm SEL;
    delete SEL; select -cl;
    rename del_SEL ($name + "del_SEL");
    rename rw_SEL ($name + "rw_SEL");

$rig_type = `optionMenuGrp -q -sl GEC`;

    if($rig_type ==2)
    {
    setAttr ($name + "GRP.rz") -90;
    }
   
    if(`objExists "*ConfigurationScriptNode"`)
    {
    delete "*ConfigurationScriptNode";
    }
   
    $normalSpineLocs[`size($normalSpineLocs)`] = ($name + "hip_PIV");
    $normalSpineLocs[`size($normalSpineLocs)`] = ($name + "end_PIV");
    select -cl;
    cycleCheck -e on;
    return $normalSpineLocs;
   
}

//=============================================
//======================================= SPINE
//=============================================

string $normalSpineLocs[];

global proc string[] desp_spine(string $spineName)
{
    string $normalSpineLocs[];
    cycleCheck -e off;
    visualize;
   
    int $rig_type = `optionMenuGrp -q -sl GEC`;
   
    string $name;
        if(`gmatch $spineName "*_"` == 1)
        {
        $name = $spineName;
        }
        else
        {
        $name = ($spineName + "_");
        }
       
   
    file -import -type "mayaBinary" -rpr $name ("/hosts/guildford/user_data/ARCHIVE/FELIX/RIG/MODULES/1/SPINE/spine_locs.mb");
   
    select SEL;
    string $list[] = `ls -sl`;
    string $item;
    for($item in $list)
    {
     catchQuiet(`rename $item ($name + $item)`);
    }
    sets -rm SEL;
    delete SEL; select -cl;
    rename del_SEL ($name + "del_SEL");
    rename rw_SEL ($name + "rw_SEL");

$rig_type = `optionMenuGrp -q -sl GEC`;

    if($rig_type ==2)
    {
    setAttr ($name + "GRP.rz") -90;
    }
   
    if(`objExists "*ConfigurationScriptNode"`)
    {
    delete "*ConfigurationScriptNode";
    }
   
    $normalSpineLocs[`size($normalSpineLocs)`] = ($name + "hip_PIV");
    $normalSpineLocs[`size($normalSpineLocs)`] = ($name + "end_PIV");
    select -cl;
    cycleCheck -e on;
    return $normalSpineLocs;
   
}


global proc string[] long_spine(string $spineName)
{

visualize;
cycleCheck -e off;

string $longSpineLocs[];
string $name;
int $num = 6;

    if(`gmatch $spineName "*_"` == 1)
    {
    $name = substring($spineName, 1, size($spineName));
    //print ("\nname = " + $name + "\n");
    }
    else
    {
    $name = $spineName;
    //print ("\nname = " + $spineName + "\n");
    }

string $spineEndNode = ($name + "_end_PIV");
string $spineRootNode = ($name + "_root_PIV");

string $pivs[] = `build_tentacle $name $num 3`;
rename ($pivs[0] + "_PIV") $spineRootNode;
rename ($pivs[$num -1] + "_PIV") $spineEndNode;

if(`objExists "*ConfigurationScriptNode"`)
{
delete "*ConfigurationScriptNode";
}

select -cl;
cycleCheck -e on;

$longSpineLocs[`size($longSpineLocs)`] = $spineRootNode;
$longSpineLocs[`size($longSpineLocs)`] = $spineEndNode;
return $longSpineLocs;
}

//=============================================
//======================================== NECK
//=============================================

//=== short neck

global proc string[] short_neck(string $shortNeckName)
{


string $tmpName;

if(`gmatch $shortNeckName "*_"` == 1)
{
$tmpName = substring($shortNeckName, 1, size($shortNeckName));
}
else
{
$tmpName = $shortNeckName;
}

$shortNeckName = $tmpName;

//== get spine name

string $spineName = "spine";
string $SPINEname;

    if(`gmatch $spineName "*_"` == 1)
    {
    $SPINEname = substring($spineName, 1, size($spineName));
    //print ("\nname = " + $SPINEname + "\n");
    }
    else
    {
    $SPINEname = $spineName;
    //print ("\nname = " + $spineName + "\n");
    }

    string $spineEndNode = ($SPINEname + "_end_PIV");
    string $spineRootNode = ($SPINEname + "_root_PIV");

//=== end get spine name

    cycleCheck -e off;
    visualize;
   
    int $num = 3;
   
    select -cl;
   
    string $locs[] = `build_tentacle $shortNeckName $num 3`;
       
    select $locs;
    string $locsList[] = `ls -sl`;
    for($item in $locsList)
    {
    setAttr ($item + ".overrideEnabled") 1;
    setAttr ($item + ".overrideColor") 16;
    }
   
        for($i = 1; $i < size($locs); $i ++)
        {
        setAttr ($locs[$i] + ".ty") (2 * $i);
        }

    select -cl;
    cycleCheck -e on;
   
   
    select ($shortNeckName + "*PIV");
    sets -n ($shortNeckName + "_rw_SEL");
    select -cl;
    select ($shortNeckName + "*LOC");
    if(`objExists ($shortNeckName + "*PIV_ROC")`)
    {
    select -add ($shortNeckName + "*PIV_ROC");
    }
    select -d ($shortNeckName + "*upv_LOC");
    sets -n ($shortNeckName + "_del_SEL");
    select -cl;
    rename $locs[size($locs) -1] ($shortNeckName + "_end_PIV");
   
    return {$locs[0], $locs[1], ($shortNeckName + "_end_PIV")};
}


//=== end short neck


//=== long neck

global proc string[] long_neck(string $longNeckName)
{


string $tmpName;

if(`gmatch $longNeckName "*_"` == 1)
{
$tmpName = substring($longNeckName, 1, size($longNeckName));
}
else
{
$tmpName = $longNeckName;
}

$longNeckName = $tmpName;

string $name = $longNeckName;

//== get spine name

string $spineName = "spine";
string $SPINEname;

    if(`gmatch $spineName "*_"` == 1)
    {
    $SPINEname = substring($spineName, 1, size($spineName));
    }
    else
    {
    $SPINEname = $spineName;
    }

    string $spineEndNode = ($SPINEname + "_end_PIV");
    string $spineRootNode = ($SPINEname + "_root_PIV");

//=== end get spine name


file -import -type "mayaAscii" -rpr $name
("/hosts/guildford/user_data/ARCHIVE/FELIX/RIG/MODULES/1/LONG_NECK/long_neck.ma");

    string $nodes[] = `sets -q -no SEL`;
    sets -rm SEL $nodes;
    for($i = 0; $i<size($nodes);$i++)
    {
    rename $nodes[$i] ($name + "_" + $nodes[$i]);
    }

delete SEL;

return $nodes;

}



//=== end long neck


//=============================================
//======================================== HEAD
//=============================================


global proc head(string $headName)
{
cycleCheck -e off;
visualize;

string $name;

    if(`gmatch $headName "*_"` == 1)
    {
    $name = substring($headName, 1, size($headName));
    //print ("\nname = " + $name + "\n");
    }
    else
    {
    $name = $headName;
    //print ("\nname = " + $headName + "\n");
    }

int $rig_type = `optionMenuGrp -q -sl GEC`;

file -import -type "mayaBinary" -rpr $name ("/hosts/guildford/user_data/ARCHIVE/FELIX/RIG/MODULES/1/HEAD/head.mb");

    string $list[] = `sets -q -no SEL`;
   
    for($item in $list)
    {
    rename $item ($name + $item);
    }
sets -rm SEL;
delete SEL; select -cl;
rename del_SEL ($name + "del_SEL");
rename rw_SEL ($name + "rw_SEL");


if(`objExists "*ConfigurationScriptNode"`)
{
delete "*ConfigurationScriptNode";
}

select -cl;
cycleCheck -e on;


}



//=============================================
//======================================== HAND
//=============================================


global proc hand(string $handName, string $armName, int $num)
{

global int $rig_type;
getGlobVar;


cycleCheck -e off;
visualize;

string $name;
string $finger;

if(`gmatch $handName "*hand*"` == 1)
{
$finger = "finger";
}
else
{
$finger = "toe";
}

    if(`gmatch $handName "*_"` == 1)
    {
    $name = substring($handName, 1, size($handName));
    }
    else
    {
    $name = $handName;
    }

select -cl;


    if(`objExists ($name + "grp")`)
    {
    }
    else
    {

        if(`gmatch $name "*hand*"` == 1)
        {
        catchQuiet(`file -import -type "mayaAscii" -rpr $name ("/hosts/guildford/user_data/ARCHIVE/FELIX/RIG/MODULES/1/HAND/hand.ma")`);
        }
        else
        {   
        catchQuiet(`file -import -type "mayaBinary" -rpr $name ("/hosts/guildford/user_data/ARCHIVE/FELIX/RIG/MODULES/1/HAND/hand_foot.mb")`);
        }
   
    select SEL;
    string $list[] = `ls -sl`;
    string $item;

        for($item in $list)
        {
        rename $item ($name + $item);
        }
    sets -rm SEL;
    delete SEL;
    rename del_SEL ($name + "del_SEL");
    rename rw_SEL ($name + "rw_SEL");
       
        if($num == 1)
        {
        delete ($name + "*" + $finger + "5*PIV") ($name + "*" + $finger +  "5*loc");
        delete ($name + "*" + $finger + "4*PIV") ($name + "*" + $finger +  "4*loc");
        delete ($name + "*" + $finger + "3*PIV") ($name + "*" + $finger +  "3*loc");
        delete ($name + "*" + $finger + "2*PIV") ($name + "*" + $finger +  "2*loc");
        }
        if($num == 2)
        {
        delete ($name + "*" + $finger + "5*PIV") ($name + "*" + $finger +  "5*loc");
        delete ($name + "*" + $finger + "4*PIV") ($name + "*" + $finger +  "4*loc");
        delete ($name + "*" + $finger + "3*PIV") ($name + "*" + $finger +  "3*loc");
        }
        if($num == 3)
        {
        delete ($name + "*" + $finger + "5*PIV") ($name + "*" + $finger +  "5*loc");
        delete ($name + "*" + $finger + "4*PIV") ($name + "*" + $finger +  "4*loc");
        }
        if($num == 4)
        {
        delete ($name + "*" + $finger + "5*PIV") ($name + "*" + $finger +  "5*loc");
        }
       
   
    }


if(`objExists "*ConfigurationScriptNode"`)
{
delete "*ConfigurationScriptNode";
}

select -cl;
cycleCheck -e on;
}

//=== end hand


//=============================================
//========================================= LEG
//=============================================

global proc leg(string $legName, string $type)
{
cycleCheck -e off;
visualize;

select -cl;

string $name;

    if(`gmatch $legName "*_"` == 1)
    {
    $name = substring($legName, 1, size($legName));
    }
    else
    {
    $name = $legName;
    }

    if(`objExists ($name + "grp")`)
    {
    //print "\nright leg already there\n";
    }
    else
    {

    file -import -type "mayaBinary" -rpr $name ("/hosts/guildford/user_data/ARCHIVE/FELIX/RIG/MODULES/1/LEG/" + $type + "_leg.mb");
    select SEL;
    string $list[] = `ls -sl`;
    string $item;

        for($item in $list)
        {
        rename $item ($name + $item);
        }
            sets -rm SEL;
            delete SEL;
            rename del_SEL ($name + "del_SEL");
            rename rw_SEL ($name + "rw_SEL");
           
            if(`objExists ($name + "stretch_CRVShape->leg_LGT")`)
            {
            rename ($name + "stretch_CRVShape->leg_LGT") ($name +  "stretch_CRVShape->" + $name + "leg_LGT");
            }

    select -cl;
    }


if(`objExists "*ConfigurationScriptNode"`)
{
delete "*ConfigurationScriptNode";
}

select -cl;
cycleCheck -e on;
}





//=============================================
//======================================== FOOT
//=============================================


global proc foot(string $footName, string $legEndNode)
{
cycleCheck -e off;
visualize;

select -cl;

string $name;

    if(`gmatch $footName "*_"` == 1)
    {
    $name = substring($footName, 1, size($footName));
    //print ("\nname = " + $name + "\n");
    }
    else
    {
    $name = $footName;
    //print ("\nname = " + $footName + "\n");
    }


    if(`objExists ($name + "grp")`)
    {
    //print "\nright foot already there\n";
    }
    else
    {


    file -import -type "mayaBinary" -rpr $name ("/hosts/guildford/user_data/ARCHIVE/FELIX/RIG/MODULES/1/FOOT/human_foot.mb");

    string $list[] = `sets -q -no SEL`;

        for($item in $list)
        {
        rename $item ($name + $item);
        }

    
    sets -rm SEL `sets -q -no SEL`;
    delete SEL;
    rename del_SEL ($name + "del_SEL");
    rename rw_SEL ($name + "rw_SEL");
    }

if(`objExists "*ConfigurationScriptNode"`)
{
delete "*ConfigurationScriptNode";
}

select -cl;
cycleCheck -e on;
}

//=================================================
//======================================== TENTACLE
//=================================================


global proc tentacle(string $name)
{
cycleCheck -e off;
visualize;

select -cl;

build_tentacle $name 11 3;

    select ($name + "*PIV") ($name + "_GRP");
    select -d ($name + "_no_trans_GRP");
    sets -n ($name + "_rw_SEL");
    select -cl;
cycleCheck -e on;
}


//=================================================
//======================================== ROPE
//=================================================


global proc rope(string $name, int $num)
{
cycleCheck -e off;
visualize;

select -cl;

build_tentacle $name $num 3;

    select ($name + "*PIV") ($name + "_GRP");
    select -d ($name + "_no_trans_GRP");
    sets -n ($name + "_rw_SEL");
    select -cl;
cycleCheck -e on;
}


//=================================================
//========================================= FLIPPER
//=================================================


global proc flipper(string $name)
{
cycleCheck -e off;
visualize;
select -cl;

build_flipper $name 11;

    select ($name + "*PIV") ($name + "_GRP");
    select -d ($name + "_no_trans_GRP");
    sets -n ($name + "_rw_SEL");
    select -cl;
cycleCheck -e on;
}


//=================================================
//============================================ TAIL
//=================================================


global proc tail(string $name)
{
cycleCheck -e off;
visualize;

select -cl;

build_tentacle $name 10 10;

    select ($name + "*PIV") ($name + "_GRP");
    select -d ($name + "_no_trans_GRP");
    sets -n ($name + "_rw_SEL");

string $list[] = `ls ($name + "*upv_CLS")`;
string $item ;
for($item in $list)
{
setAttr ($item + ".t") 0 0 3;
}

string $list[] = `ls ($name + "*PIV")`;
string $item ;
for($item in $list)
{
setAttr ($item + ".r") 0 0 90;
}



select -cl;
cycleCheck -e on;
}
//=================================================
//============================================= FIN
//=================================================


global proc fin(string $name)
{
cycleCheck -e off;
visualize;

select -cl;

build_tentacle $name 4 3;

    select ($name + "*PIV") ($name + "_GRP");
    select -d ($name + "_no_trans_GRP");
    sets -n ($name + "_rw_SEL");

select -cl;
cycleCheck -e on;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



//=== 2004 Felix Balbas
//=== group of scripts to rig creature modules such as spine, leg, etc
//=== utilities used directly by the creature_rig script and indirectly by the fs_build_rig

//=== tentacle_rig
//=== normal_spine_rig
//=== long_spine_rig
//=== short_neck_rig
//=== long_neck_rig_rig
//=== head_rig

//=== human_limb_rig
//=== hand_rig
//=== human_foot_rig

//=== flipper_rig
//=== tail_rig
//=== fin_rig
//=== rope_rig

source "generateChannelMenu.mel" ;


//=== tentacle rig

    global proc string[] tentacle_rig(string $name, int $constraint, int $dyn, int $hires)
    {
//==== global variables

global string $FsRigPrefix;
global string $FsRigName;

//=== names

global string $rig_pref;
global string $rig_name;
global string $rig_prefix;
global string $prefixL;
global string $prefixR;

//=== modules

global int $hires;
global int $normal_spines;
global int $long_spines;
global int $long_necks;
global int $short_necks;
global int $heads;
global int $human_arms;
global int $human_legs;
global int $quadr_legs;
global int $human_feet;;
global int $one_finger_hands;
global int $two_finger_hands;
global int $three_finger_hands;
global int $four_finger_hands;
global int $five_finger_hands;
global int $bird_wings;
global int $bat_wings;
global int $tentacles;
global int $tails;
global int $fins;
global int $flippers;
global int $rig_type;
global int $quad_rig_type;
global int $bird_rig_type;
global int $rept_rig_type;
global int $hires;
global int $normal_spines;
global int $long_spines;
global int $long_necks;
global int $short_necks;
global int $heads;
global int $human_arms;
global int $human_legs;
global int $quadr_legs;
global int $human_feet;
global int $one_finger_hands;
global int $two_finger_hands;
global int $three_finger_hands;
global int $four_finger_hands;
global int $five_finger_hands;
global int $bird_wings;
global int $bat_wings;
global int $tentacles;
global int $tails;
global int $fins;
global int $flippers;
global int $doStretch;
global int $doToes;
getGlobVar;
////getGlobSet;

    select -cl;

select ($name + "GRP");
string $listGrps[] = `ls -sl`;
select -cl;
string $tentacle;
string $tentacleNames[];
string $neckLocs[];
string $memberCage[];


for($t = 0; $t < size($listGrps); $t++)
{
select $listGrps[$t];
string $tentacleName[] = `strip_suffix 0`;
$tentacleNames[`size($tentacleNames)`] = $tentacleName[0];

select ($tentacleNames[$t] + "_*_LOC");
select -d ($tentacleNames[$t] + "_*_upv_LOC");
string $listLocs[] = `ls -sl`;

//=== fix root and end in the right order;

string $nnn[];

for($i = 0; $i < size($listLocs); $i++)
{

    if($i > 0)
    {
    $nnn[size($nnn)] = $listLocs[$i-1];
    }
    else
    {
    $nnn[size($nnn)] = $listLocs[size($listLocs) - 1];
    }
   
}   


//=== end fix


$listLocs = $nnn;
select $listLocs;


string $listNames[] = `strip_suffix 0`;



select -cl;
string $conSel[];

//=== get ctls scale

select $listLocs[0] $listLocs[size($listLocs) -1];
float $tentLength = `get_distance`;
float $ctrl_scale = ($tentLength / 100);
float $scale = 0.1;
float $incr = 1;

select -cl;

//=== end get ctls scale

    for($i = 0; $i < size($listLocs); $i++)
    {
               

                    //=== import controls
                   
                    if($i == 0)
                    {
                    file -import -type "mayaAscii" -rpr ($listNames[$i]) -options "v=0" "/hosts/guildford/user_data/ARCHIVE/FELIX/RIG/CNTRLS/tent_cntrl.ma";
                    }
                    else
                    {
                    file -import -type "mayaAscii" -rpr ($listNames[$i]) -options "v=0" "/hosts/guildford/user_data/ARCHIVE/FELIX/RIG/CNTRLS/cntrl.ma";
                    }
                   
                    if($i%2)
                    {
                    setAttr ctrl.sec 1;
                    setAttr rot_ctrl.sec 1;
                    }
                   
                   
                    spaceLocator -name ctrl_xtra_LOC;
                    select ctrl_xtra_LOC;
                    sets -add SEL;
                    parent ctrl_xtra_LOC ctrl_LOC;
                    setAttr ctrl_xtra_LOC.t 0 0 0;
                    setAttr ctrl_xtra_LOC.r 0 0 0;
                    setAttr ctrl_xtra_LOC.s 1 1 1;
                    parent ctrl ctrl_xtra_LOC;
                    setAttr ctrl_xtra_LOCShape.v 0;
                                       
                    select SEL;
                    string $list[] = `ls -sl`;
                    sets -rm SEL;
                    delete SEL;
                    select -cl;
                    string $item;
                    for($item in $list)
                    {
                    rename $item ($listNames[$i] + "_" + $item);
                    }
                   
                   
                    setAttr ($listNames[$i] + "_ctrl_LOC.s") ($ctrl_scale * $incr)
($ctrl_scale * $incr) ($ctrl_scale * $incr);
                    $incr -= $scale;
                    makeIdentity -a 1 -s 1 ($listNames[$i] + "_ctrl_LOC");
                    select $listLocs[$i] ($listNames[$i] + "_ctrl_LOC");
                    $n = `orientConstraint`;
                    delete `orientConstraint`;
                    select $listLocs[$i] ($listNames[$i] + "_ctrl_LOC");
                    $n = `pointConstraint`;
                    delete `pointConstraint`;
                   
                   

                select ($listNames[$i] + "_ctrl_LOC");
                //rotate -r -os -90 0 -90;
                    //parent ($listNames[$i] + "_upv_LOC") ($listNames[$i] +  "_rot_ctrl");
                    select -cl;
                    delete ($listNames[$i] + "_rot_ctrl_UPV");
                   
                    if(`objExists ($listNames[$i] + "_cls_POC")`)
                    {
                    delete ($listNames[$i] + "_cls_POC");
                    }
                   
                   
                    if(`objExists ($listNames[$i] + "_CLH")`)
                    {
                    parent -w ($listNames[$i] + "_CLS");
                    delete ($listNames[$i] + "_PIV");
                    parent ($listNames[$i] + "_CLH") ($listNames[$i] + "_rot_ctrl");
                    }
                    else
                    {
                    parent -w ($listNames[$i] + "_CLS");
                    delete ($listNames[$i] + "_PIV");
                    parent ($listNames[$i] + "_CLS") ($listNames[$i] + "_rot_ctrl");
                    }
                   
                   
                    select -cl;

                    shadingNode -asUtility plusMinusAverage -name ($listNames[$i] +  "_x_ADD");
                    shadingNode -asUtility plusMinusAverage -name ($listNames[$i] +  "_y_ADD");
                    shadingNode -asUtility plusMinusAverage -name ($listNames[$i] +  "_z_ADD");
                   
                    if($i == 0)
                    {
                    $conSel[size($conSel)] = ($listNames[$i] + "_ctrl");
                    }
                    else
                    {
                        if($i == (size($listLocs)-1))
                        {
                        $conSel[size($conSel)] = ($listNames[$i] + "_ctrl");
                        }
                        else
                        {
                        $conSel[size($conSel)] = ($listNames[$i] + "_ctrl_LOC");
                        }
                    }

                    if($i > 0)
                    {
                    parent ($listNames[$i] + "_ctrl_LOC") ($listNames[$i -1] +  "_rot_ctrl");
                    addAttr -ln curlx -at double ($listNames[$i-1] + "_ctrl");
                    setAttr -e -keyable true ($listNames[$i-1] + "_ctrl.curlx");
                    addAttr -ln curly -at double ($listNames[$i-1] + "_ctrl");
                    setAttr -e -keyable true ($listNames[$i-1] + "_ctrl.curly");
                    addAttr -ln curlz -at double ($listNames[$i-1] + "_ctrl");
                    setAttr -e -keyable true ($listNames[$i-1] + "_ctrl.curlz");
                    }
                    else
                    {
                    connectAttr ($listNames[$i] + "_ctrl.rot_axes") ($listNames[$i] +  "_ctrl_xtra_LOC.rx");
                    }
                   
                    select -cl;
    }


//=== connect curls


if($constraint == 1)
{
select ($name + "*ctrl_LOC");
string $sel[] = `ls -sl`;
select -d ($name + "*root_ctrl_LOC") ($name + "*rot_ctrl_LOC");
parent -w;

select $sel;
makeIdentity -a 1 -s 1 -t 1 -r 1;

select $conSel;
averagePointConstraint;
}

    select $listLocs;
    string $lista[] = `ls -sl`;
        for($n = 0; $n < (size($lista)); $n++)
        {
            for($i = 0; $i < $n; $i ++)
            {
            connectAttr -f ($listNames[$i] + "_ctrl.curlx") ($listNames[$n] +  "_x_ADD.input1D[" + ($i) + "]");
            connectAttr -f ($listNames[$i] + "_ctrl.curly") ($listNames[$n] +  "_y_ADD.input1D[" + ($i) + "]");
            connectAttr -f ($listNames[$i] + "_ctrl.curlz") ($listNames[$n] +  "_z_ADD.input1D[" + ($i) + "]");
           
                                    }
                if($n > 0)
                {
                connectAttr -f ($listNames[$n] + "_x_ADD.output1D") ($listNames[$n]
+ "_ctrl_xtra_LOC.rx");
                connectAttr -f ($listNames[$n] + "_y_ADD.output1D") ($listNames[$n]
+ "_ctrl_xtra_LOC.ry");
                connectAttr -f ($listNames[$n] + "_z_ADD.output1D") ($listNames[$n]
+ "_ctrl_xtra_LOC.rz");
                }
        }


string $wire1;
string $wire2 = ($name + "upv_CRV");;


if(`objExists ($name + "*CRV")`)
{
int $num = size($lista);
//select ($name + "CRV") ($name + "upv_CRV");
$wire1 = ($name + "CRV");

if($dyn == 1)
{
select ($name + "CRV");
string $dynElements[] = `makeCurveDyn`;


addAttr -ln stretch -at double  -min 0 -max 1 -dv 0 ($name +  "root_ctrl");
addAttr -ln dynamic -at double -min 0 -max 1 -dv 1 ($name +  "root_ctrl");
addAttr -ln dyn_stiffness -at double  -min 0 -max 1 -dv 1 ($name +  "root_ctrl");
addAttr -ln dyn_iterations -at double  -min 0 -max 100 -dv 10 ($name +  "root_ctrl");
addAttr -ln dyn_tip_stiffness -at double -min 0 -max 1 -dv 0 ($name +  "root_ctrl");
addAttr -ln dyn_mid_stiffness -at double  -min 0 -max 1 -dv 0 ($name +  "root_ctrl");
addAttr -ln dyn_gravity -at double  -min 0 -max 1 -dv 0.1 ($name +  "root_ctrl");
addAttr -ln dyn_damp -at double  -min 0 -max 100 -dv 80 ($name +  "root_ctrl");


setAttr -e -keyable true ($name + "root_ctrl.dynamic");
setAttr -e -keyable true ($name + "root_ctrl.dyn_iterations");
setAttr -e -keyable true ($name + "root_ctrl.stretch");
setAttr -e -keyable true ($name + "root_ctrl.dyn_gravity");
setAttr -e -keyable true ($name + "root_ctrl.sx");
setAttr -e -keyable true ($name + "root_ctrl.sy");
setAttr -e -keyable true ($name + "root_ctrl.sz");


connectAttr ($name + "root_ctrl.dynamic") ($dynElements[2] + ".blend");

string $shape[] = `listRelatives -typ shape $dynElements[0]`;

connectAttr ($name + "root_ctrl.dyn_stiffness") ($shape[0] +  ".stiffness");
connectAttr ($name + "root_ctrl.dyn_iterations") ($shape[0] +  ".iterations");
connectAttr ($name + "root_ctrl.dyn_mid_stiffness") ($shape[0] +  ".stiffnessScale[1].stiffnessScale_Position");
connectAttr ($name + "root_ctrl.dyn_tip_stiffness") ($shape[0] +  ".stiffnessScale[1].stiffnessScale_FloatValue");
connectAttr ($name + "root_ctrl.dyn_gravity") ($shape[0] + ".gravity");
connectAttr ($name + "root_ctrl.dyn_damp") ($shape[0] + ".damp");
connectAttr ($name + "root_ctrl.stretch") ($shape[0] + ".lengthFlex");


select $dynElements[2] ($name + "upv_CRV");
$wire1 = $dynElements[2];

}
else
{
select ($name + "CRV") ($name + "upv_CRV");
$wire1 = ($name + "CRV");
}

/*
select ($name + "root_ctrl") ($name + "end_ctrl");
$memberCage[0] = `memberCage $name 0.5 1`;
*/


int $jntNum;


if(`gmatch $name "*5*"` == 1)
{
$jntNum = 10;
}
else
{
    if(`gmatch $name "*6*"` == 1)
    {
    $jntNum = 10;
    }
    else
    {
   
        if(`gmatch $name "*7*"` == 1)
        {
        $jntNum = 10;
        }
        else
        {
            if($hires == 1)
            {
            $jntNum = 30;
            }
            else
            {
            $jntNum = 10;
            }
        }
    }

}





////print ("\nthe name is " + $name + "\n");
////print ("\nthe number is " + $jntNum + "\n");


//=== grindylow specific

string $comm;

if(`gmatch $name "*[5-7]*"` == 1)
{
$comm = ("joints_on_path_upv " + $name + " " + $jntNum);
}
else
{
$comm = ("joints_on_path_upv2 " + $name + " " + $jntNum);
}


string $neckLocs[] = eval($comm);

//=== end grindylow specific

//string $neckLocs[] = `joints_on_path_upv $name $jntNum`;
string $listJntNames[] = $neckLocs;





    //=== cages
   
    for($p = 1; $p < $jntNum; $p++)
    {
        if($p == $jntNum)
        {
        string $jointChild[] = `listRelatives -typ joint $neckLocs[$jntNum
-1]`;
        rename $jointChild[0] ($listJntNames[$jntNum -1] + "_JNT");
        select ($listJntNames[$jntNum -1] + "_JNT")  ($listJntNames[$jntNum
-2] + "_JNT");
        pullCage $listJntNames[$jntNum -1] 3 1;
        }
        else
        {
        string $jointCd[] = `listRelatives -typ joint ($neckLocs[$p -1] +  "_jnt_LOC")`;
        rename $jointCd[0] ($listJntNames[$p -1] + "_JNT");
        string $jointCd2[] = `listRelatives -typ joint ($neckLocs[$p] +  "_jnt_LOC")`;
        rename $jointCd2[0] ($listJntNames[$p] + "_JNT");

        select ($listJntNames[$p -1] + "_JNT") ($listJntNames[$p] + "_JNT");
        pullCage $listJntNames[$p -1] 3 1;
        }
    }




    //=== end cages
   
//=== new stretch

if(`objExists ($name + "fin_CRV.stretch")`)
{
connectAttr ($name + "root_ctrl.stretch") ($name + "fin_CRV.stretch");
}

//=== end new stretch

parent ($name + "jnts_GRP") ($name + "upvs_GRP") ($name +  "no_trans_GRP");


//=== scale rig

if(`objExists ($rig_prefix + $rig_name + ".scale_rig")`)
{

select ($name + "*_jnt_LOC");
string $list[] = `ls -sl`;
string $item;
select -cl;
    for($item in $list)
    {
    connectAttr ($rig_prefix + $rig_name + ".scale_rig") ($item + ".sx");
    connectAttr ($rig_prefix + $rig_name + ".scale_rig") ($item + ".sy");
    connectAttr ($rig_prefix + $rig_name + ".scale_rig") ($item + ".sz");

    setAttr -keyable false ($item + ".sx");
    setAttr -keyable false ($item + ".sy");
    setAttr -keyable false ($item + ".sz");
    }
}

//=== end scale rig


string $tmp[];
for($i = 0; $i < size($neckLocs); $i++)
{
$tmp[size($tmp)] = ($neckLocs[$i] + "_jnt_LOC");
}

$neckLocs = $tmp;

return {$wire1, $wire2, $memberCage[0]};


select -cl;
//print "\nTENTACLE RIG DONE\n";
}
else
{
return {$wire1, $wire2, $memberCage[0]};
select -cl;
//print "\nTENTACLE RIG DONE\n";
}

}

}

//=== end tentacle rig

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//=== long spine rig


    global proc long_spine_rig(string $spineName)
    {

//==== global variables

global string $FsRigPrefix;
global string $FsRigName;

//=== names

global string $rig_pref;
global string $rig_name;
global string $rig_prefix;
global string $prefixL;
global string $prefixR;

//=== modules

global int $hires;
global int $normal_spines;
global int $long_spines;
global int $long_necks;
global int $short_necks;
global int $heads;
global int $human_arms;
global int $human_legs;
global int $quadr_legs;
global int $human_feet;;
global int $one_finger_hands;
global int $two_finger_hands;
global int $three_finger_hands;
global int $four_finger_hands;
global int $five_finger_hands;
global int $bird_wings;
global int $bat_wings;
global int $tentacles;
global int $tails;
global int $fins;
global int $flippers;
global int $rig_type;
global int $quad_rig_type;
global int $bird_rig_type;
global int $rept_rig_type;
global int $hires;
global int $normal_spines;
global int $long_spines;
global int $long_necks;
global int $short_necks;
global int $heads;
global int $human_arms;
global int $human_legs;
global int $quadr_legs;
global int $human_feet;
global int $one_finger_hands;
global int $two_finger_hands;
global int $three_finger_hands;
global int $four_finger_hands;
global int $five_finger_hands;
global int $bird_wings;
global int $bat_wings;
global int $tentacles;
global int $tails;
global int $fins;
global int $flippers;
global int $doStretch;
global int $doToes;
getGlobVar;
////getGlobSet;

    select -cl;
   
    string $name;
   
    if(`gmatch $spineName "*_"` == 1)
    {
    $name = substring($spineName, 1, size($spineName));
    ////print ("\nname = " + $name + "\n");
    }
    else
    {
    $name = $spineName;
    ////print ("\nname = " + $spineName + "\n");
    }

select ($name + "_grp");
string $listGrps[] = `ls -sl`;
select -cl;
string $neck;
string $neckNames[];


for($t = 0; $t < size($listGrps); $t++)
{
select $listGrps[$t];
string $neckName[] = `strip_suffix 0`;
$neckNames[`size($neckNames)`] = $neckName[0];

select ($neckNames[$t] + "_*_loc");
select -d ($neckNames[$t] + "*_upv_loc");
    if(`objExists ($neckNames[$t] + "*_piv_loc")`)
    {
    select -d ($neckNames[$t] + "*_piv_loc");
    }

string $listLocs[] = `ls -sl`;
select $listLocs;
string $listNames[] = `strip_suffix 0`;
select -cl;
    for($i = 0; $i < size($listLocs); $i++)
    {
               

                //=== get cntrls scale
                float $sp[] = `xform -query -worldSpace -translation $listLocs[0]`;
                float $ep[] = `xform -query -worldSpace -translation $listLocs[1]`;
               
                $d = `distanceDimension -sp $sp[0] $sp[1] $sp[2] -ep $ep[0] $ep[1]
$ep[2]` ;
               
                float $tentLength = `getAttr ($d + ".distance")`;
                float $cntrl_scale = ($tentLength/30);
                delete $d;
               
                if(`objExists distanceDimension1`)
                {
                delete distanceDimension1;
                }
               
                //=== end get cntrls scale
           
           

           
                    //=== import controls
                   
                    file -import -type "mayaAscii" -rpr ($listNames[$i]) -options
"v=0" "/hosts/guildford/user_data/ARCHIVE/FELIX/RIG/CNTRLS/cntrl.ma";
                   
                    spaceLocator -name cntrl_xtra_loc;
                    parent cntrl_xtra_loc cntrl_loc;
                    setAttr cntrl_xtra_loc.t 0 0 0;
                    setAttr cntrl_xtra_loc.r 0 0 0;
                    setAttr cntrl_xtra_loc.s 1 1 1;
                    parent cntrl cntrl_xtra_loc;
                    setAttr cntrl_xtra_locShape.v 0;
                   
                    select -r cntrl_xtra_loc cntrl_loc cntrl rot_cntrl_loc rot_cntrl
rot_cntrl_UPV cntrl_UPV ;
                    string $list[] = `ls -sl`;
                    select -cl;
                    string $item;
                    for($item in $list)
                    {
                    rename $item ($listNames[$i] + "_" + $item);
                    }
                   
                    setAttr ($listNames[$i] + "_cntrl_loc.s") $cntrl_scale
$cntrl_scale $cntrl_scale;
                    makeIdentity -a 1 -s 1 ($listNames[$i] + "_cntrl_loc");
                    select $listLocs[$i] ($listNames[$i] + "_cntrl_loc");
                    copyTrans;
                    select ($listNames[$i] + "_cntrl_loc");
                    rotate -r -os 0 -90 0 ;
                    ////print ("\n" + $listNames[$i] + "\n");
                    parent ($listNames[$i] + "_upv_loc") ($listNames[$i] +  "_rot_cntrl");
                    select -cl;
                    delete ($listNames[$i] + "_rot_cntrl_UPV");
                    delete ($listNames[$i] + "_cls_POC");
                    select ($listNames[$i] + "_rot_cntrl")($listNames[$i] +  "_CLSHandle");
                    pointConstraint -name ($listNames[$i] + "_cls_POC");
                    orientConstraint -name ($listNames[$i] + "_cls_ROC");
                    select -cl;
                    /*
                    if($i > 0)
                    {
                    parent ($listNames[$i] + "_cntrl_loc") ($listNames[$i -1] +  "_cntrl");
                    }
                    */
                    select -cl;
    }

//select ($name + "_end_cntrl") ($name + "_?_cntrl_loc") ($name +  "_root_cntrl");
//averagePointConstraint;
//select ($name + "_end_cntrl") ($name + "_?_cntrl_loc") ($name +  "_root_cntrl");
//averageOrient;

select -cl;
delete $listGrps[$t];
}

//print "\nLONG NECK RIG DONE\n";
select -cl;
    }


//=== end long spine rig

//=====================================================================================
//=====================================================================================
//=====================================================================================
//=====================================================================================
//=====================================================================================
//=====================================================================================
//=====================================================================================
//=====================================================================================
//=====================================================================================
//=====================================================================================
//=====================================================================================
//=====================================================================================
//=====================================================================================
//=====================================================================================
//=====================================================================================
//=====================================================================================
//=====================================================================================
//=====================================================================================
//=====================================================================================
//=====================================================================================

global proc long_neck_rig(string $neckName)
{
    //=== global variables

   
//==== global variables

global string $FsRigPrefix;
global string $FsRigName;

//=== names

global string $rig_pref;
global string $rig_name;
global string $rig_prefix;
global string $prefixL;
global string $prefixR;

//=== modules

global int $hires;
global int $normal_spines;
global int $long_spines;
global int $long_necks;
global int $short_necks;
global int $heads;
global int $human_arms;
global int $human_legs;
global int $quadr_legs;
global int $human_feet;;
global int $one_finger_hands;
global int $two_finger_hands;
global int $three_finger_hands;
global int $four_finger_hands;
global int $five_finger_hands;
global int $bird_wings;
global int $bat_wings;
global int $tentacles;
global int $tails;
global int $fins;
global int $flippers;
global int $rig_type;
global int $quad_rig_type;
global int $bird_rig_type;
global int $rept_rig_type;
global int $hires;
global int $normal_spines;
global int $long_spines;
global int $long_necks;
global int $short_necks;
global int $heads;
global int $human_arms;
global int $human_legs;
global int $quadr_legs;
global int $human_feet;
global int $one_finger_hands;
global int $two_finger_hands;
global int $three_finger_hands;
global int $four_finger_hands;
global int $five_finger_hands;
global int $bird_wings;
global int $bat_wings;
global int $tentacles;
global int $tails;
global int $fins;
global int $flippers;
global int $doStretch;
global int $doToes;
getGlobVar;
//getGlobSet;

    cycleCheck -e off;
    string $main_locs[];
    int $num = 5;
    string $base_name = "neck";
    string $upv_ext = "upv_";
    string $name = $neckName;

    //=== global variables

//=== check if name has an underscore

    if(`gmatch $neckName "*_"` == 1)
    {
    $name = $neckName;
    }
    else
    {
    $name = ($neckName + "_");
    }

//==== end check if name has an underscore

    //=== define beginning and end nodes

    string $neckEndNode = ($name + "end_LOC");
    string $neckRootNode = ($name + "root_LOC");

    //=== end define beginning and end nodes


//=======================================================================================================================
//================================================ CONTROLS =============================================================
//=======================================================================================================================

showHidden -all;

file -import -type "mayaAscii" -rpr $name
"/hosts/guildford/user_data/ARCHIVE/FELIX/RIG/CNTRLS/neck_cntrls.ma";

select ($name + "root_PIV") ($name + "head_PIV");
float $dist = `get_distance`;
float $scale_cntrls = ($dist*.1);


string $list[] = `sets -q -no controls_SEL`;

sets -rm controls_SEL $list;
delete controls_SEL;

string $item;
for($item in $list)
{
rename $item ($name + $item);
}


//================================ position controls

select ($name + "head_PIV")  ($name + "head_ctrl_LOC");
delete`pointConstraint`;
select ($name + "end_PIV") ($name + "end_ctrl_LOC");
delete`pointConstraint`;
select ($name + "headside_PIV") ($name + "headside_ctrl_LOC");
delete`pointConstraint`;
select ($name + "rootside_PIV") ($name + "rootside_ctrl_LOC");
delete`pointConstraint`;
select ($name + "root_PIV") ($name + "root_ctrl_LOC");
delete`pointConstraint`;


//=== end controls setup
//=======================================================================================================================
//================================ PARENT SPLINE LOCS TO CONTROLS =======================================================
//=======================================================================================================================

string $cons[] = `ls ($name + "*jnt_POC")`;
for($i = 0;$i<size($cons);$i++)
{
setAttr ($cons[$i] + ".nodeState") 10;
}
delete $cons;


select ($name + "*PIV");
    string $list[] = `ls -sl`;
    string $item;
    dgdirty -a;
   
        for($item in $list)
        {
        string $pip[];
       
            if(`objExists $item`)
            {
            $pip = `listConnections -d 1 -t constraint $item`;
            }
           
            if(size($pip) > 0)
            {
             catchQuiet(`delete $pip`);
            }
           
            if(`objExists $item`)
            {
             catchQuiet(`delete $item`);
            }
        }

parent ($name + "spline_head_LOC") ($name + "head_ctrl");
parent ($name + "spline_headside_LOC") ($name + "headside_ctrl");
parent ($name + "spline_rootside_LOC") ($name + "rootside_ctrl");

parent ($name + "spline_root_LOC") ($name + "root_ctrl");

parent ($name + "spline_end_LOC") ($name + "head_ctrl");

//================================================================================



    //==============================================================================================================
    //============================================ CREATE new locs =================================================

    //==============================================================================================================
   
    parent ($name + "extras_GRP") ($name + "upv_extras_GRP") ($name +  "no_trans_GRP");
   

    //====== NEW LOCS
   
    //=== main ones
   
    spaceLocator -name $neckRootNode;   
    spaceLocator -name ($name + "head_LOC");
    spaceLocator -name $neckEndNode;
   
   
    select ($name + "root_ctrl") $neckRootNode;
    copyTrans;
   
    select ($name + "head_ctrl") ($name + "head_LOC");
    copyTrans;
   
    select ($name + "root_lead_end_JNT") $neckEndNode;
    copyT;
    select ($name + "GRP") $neckEndNode;
    copyR;
   
/*   
select controls_SEL;
string $list[] = `ls -sl`;
sets -rm controls_SEL;
string $item;
for($item in $list)
{
select ($item + "Shape.cv[0:16]");
scale ($scale_cntrls * 0.4) ($scale_cntrls * 0.4) ($scale_cntrls *
0.4);
}
*/
   
    select $neckRootNode $neckEndNode ($name + "head_LOC");
    group -name ($name + "main_locs_GRP");
   
    //=== end main ones
   


//=== controls parent contraints

if(`objExists ($rig_prefix + "M_spine_end_LOC")`)
{
parent ($name + "controls_GRP") ($rig_prefix + "M_spine_end_LOC");
select ($rig_prefix + "M_spine_end_LOC") ($name + "root_ctrl_LOC");
parentConstraint -mo -name ($name + "root_ctrl_loc_PAC");

setAttr ($name + "head_ctrl_LOC.r") 0 0 0;
setAttr ($name + "end_ctrl_LOC.r") 0 0 0;
setAttr ($name + "headside_ctrl_LOC.r") 0 0 0;
setAttr ($name + "rootside_ctrl_LOC.r") 0 0 0;
setAttr ($name + "root_ctrl_LOC.r") 0 0 0;

select ($name + "head_ctrl") ($rig_prefix + "hip_PIV") ($name +  "headside_ctrl_LOC");
dnDoConstraint ("PAC");
connectAttr -f ($name + "head_ctrl.follow") ($name +  "headside_ctrl_LOC.fcWeightPAC");

select ($name + "root_ctrl") ($rig_prefix + "hip_PIV") ($name +  "rootside_ctrl_LOC");
dnDoConstraint( "PAC");
connectAttr -f ($name + "root_ctrl.follow") ($name +  "rootside_ctrl_LOC.fcWeightPAC");
}
else
{
spaceLocator -name ($rig_prefix + "hip_PIV");
spaceLocator -name ($rig_prefix + "M_spine_end_LOC");


parent ($name + "controls_GRP") ($rig_prefix + "M_spine_end_LOC");
select ($rig_prefix + "M_spine_end_LOC") ($name + "root_ctrl_LOC");
parentConstraint -mo -name ($name + "root_ctrl_loc_PAC");

select ($name + "head_ctrl") ($rig_prefix + "hip_PIV") ($name +  "headside_ctrl_LOC");
dnDoConstraint ("PAC");
connectAttr -f ($name + "head_ctrl.follow") ($name +  "headside_ctrl_LOC.fcWeightPAC");

select ($name + "root_ctrl") ($rig_prefix + "hip_PIV") ($name +  "rootside_ctrl_LOC");
dnDoConstraint( "PAC");
connectAttr -f ($name + "root_ctrl.follow") ($name +  "rootside_ctrl_LOC.fcWeightPAC");
}

//=== set defaults

setAttr ($name + "head_ctrl.follow") 0.5;
setAttr ($name + "root_ctrl.follow") 0.5;


//=== end controls setup


//================================================================================

//============================================ IKS
//++++++++++++++++++++++++++++++++++++++++++++++++

//=== unparent safety CLS constraint locators

string $lista[] = `ls ($name + "*_con_LOC")`;
string $daddies[];
for($i = 0; $i < size($lista); $i++)
{
string $dad[] = `listRelatives -p $lista[$i]`;
$daddies[size($daddies)] = $dad[0];
parent -w $lista[$i];
}

//===== main

select ($name + "root_lead_root_JNT") ($name + "root_lead_end_JNT")
($name + "cls_CRV");
ikHandle -sol ikSplineSolver -ccv false -pcv false -name ($name +  "root_lead_IKH");
select ($name + "head_lead_end_JNT") ($name + "head_lead_root_JNT")
($name + "cls_rev_CRV");
ikHandle -sol ikSplineSolver -ccv false -roc false -pcv false -name
($name + "head_lead_IKH");

//==== upv

select ($name + "root_lead_upv_root_JNT") ($name +  "root_lead_upv_end_JNT") ($name + "cls_upv_CRV");
ikHandle -sol ikSplineSolver -ccv false -pcv false -name ($name +  "root_lead_upv_IKH");
select ($name + "head_lead_upv_end_JNT") ($name +  "head_lead_upv_root_JNT") ($name + "cls_upv_rev_CRV");
ikHandle -sol ikSplineSolver -ccv false -roc false -pcv false -name
($name + "head_lead_upv_IKH");

//=== parent safety CLS constraint locators back

for($i = 0; $i < size($lista); $i++)
{
parent $lista[$i] $daddies[$i];
}
select -cl;


//===============================================
//+++++++++++++++++++++++++++++++++++++++++++++++
//== connect control attributes to spine_spline attributes

//connectAttr ($name + "root_ctrl.head_lead") ($name +  "CRV.chest_lead");
connectAttr ($name + "root_ctrl.root_lead") ($name + "CRV.hip_lead");
connectAttr ($name + "root_ctrl.stretchy") ($name + "CRV.stretchy");


//===========================================================================================================================
//=========================================== ENV joints ====================================================================
//===========================================================================================================================

int $num = 5;
select ($name + "CRV") ($name + "upv_CRV");
string $envJoints[] = `joints_on_path_upv2 $name $num`;
select ($envJoints[$num - 1] + "_JNT") $neckEndNode;
pointConstraint -name ($name + "end_loc_POC");
select ($name + "head_LOC") $neckEndNode;
orientConstraint -name ($name + "end_loc_ORC");

//========== cages

for($i = 0; $i < ($num - 1); $i++)
{
    select ($envJoints[$i] + "_JNT") ($envJoints[$i + 1] + "_JNT");
    pullCage ($name + ($i+1)) (1.2 * $scale_cntrls) 1;

}


//===========================================================================================================================
//=========================================== constrain MAIN LOCS ===========================================================
//===========================================================================================================================

string $envLocs[];

for($i = 0; $i < size($envJoints); $i++)
{
$envLocs[size($envLocs)] = ($envJoints[$i] + "_jnt_LOC");
}

select $envLocs ($name + "head_LOC");
string $closetsJntLoc = `find_closest`;
select $closetsJntLoc ($name + "head_LOC");
pointConstraint -mo -name ($name + "head_loc_POC");
select ($name + "head_ctrl") ($name + "head_LOC");
orientConstraint -name ($name + "head_loc_ORC");


select $envLocs[0] $neckRootNode;
pointConstraint -mo -name ($name + "root_loc_POC");
select ($name + "root_ctrl") $neckRootNode;
orientConstraint -mo -name ($name + "root_loc_ORC");

//if(`objExists ($rig_prefix + "no_transform_GRP")`)
//{
parent ($name + "no_trans_GRP") ($rig_prefix + "no_transform_GRP");
//}

select -cl;
}

//=== end long neck rig


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//=== flipper_rig

    global proc string[] flipper_rig(string $name, int $constraint, int
$dyn, int $hires)
    {

    select -cl;

//==== global variables

global string $FsRigPrefix;
global string $FsRigName;

//=== names

global string $rig_pref;
global string $rig_name;
global string $rig_prefix;
global string $prefixL;
global string $prefixR;

//=== modules

global int $hires;
global int $normal_spines;
global int $long_spines;
global int $long_necks;
global int $short_necks;
global int $heads;
global int $human_arms;
global int $human_legs;
global int $quadr_legs;
global int $human_feet;;
global int $one_finger_hands;
global int $two_finger_hands;
global int $three_finger_hands;
global int $four_finger_hands;
global int $five_finger_hands;
global int $bird_wings;
global int $bat_wings;
global int $tentacles;
global int $tails;
global int $fins;
global int $flippers;
global int $rig_type;
global int $quad_rig_type;
global int $bird_rig_type;
global int $rept_rig_type;
global int $hires;
global int $normal_spines;
global int $long_spines;
global int $long_necks;
global int $short_necks;
global int $heads;
global int $human_arms;
global int $human_legs;
global int $quadr_legs;
global int $human_feet;
global int $one_finger_hands;
global int $two_finger_hands;
global int $three_finger_hands;
global int $four_finger_hands;
global int $five_finger_hands;
global int $bird_wings;
global int $bat_wings;
global int $tentacles;
global int $tails;
global int $fins;
global int $flippers;
global int $doStretch;
global int $doToes;
getGlobVar;
//getGlobSet;

select -cl;


select ($name + "GRP");
string $listGrps[] = `ls -sl`;
select -cl;
string $flipper;
string $flipperNames[];
string $neckLocs[];
string $memberCage[];


for($t = 0; $t < size($listGrps); $t++)
{
select $listGrps[$t];
string $flipperName[] = `strip_suffix 0`;
$flipperNames[`size($flipperNames)`] = $flipperName[0];

select ($flipperNames[$t] + "_*_LOC");
select -d ($flipperNames[$t] + "_*_upv_LOC");
string $listLocs[] = `ls -sl`;

//=== fix root and end in the right order;

string $nnn[];

for($i = 0; $i < size($listLocs); $i++)
{

    if($i > 0)
    {
    $nnn[size($nnn)] = $listLocs[$i-1];
    }
    else
    {
    $nnn[size($nnn)] = $listLocs[size($listLocs) - 1];
    }
   
}   


//=== end fix


$listLocs = $nnn;
select $listLocs;


string $listNames[] = `strip_suffix 0`;



select -cl;
string $conSel[];

//=== get ctls scale

select $listLocs[0] $listLocs[size($listLocs) -1];
float $tentLength = `get_distance`;
float $ctrl_scale = ($tentLength / 100);
float $scale = 0.1;
float $incr = 1;

select -cl;

//=== end get ctls scale

    for($i = 0; $i < size($listLocs); $i++)
    {
               

                    //=== import controls
                   
                    if($i == 0)
                    {
                    file -import -type "mayaAscii" -rpr ($listNames[$i]) -options
"v=0" "/hosts/guildford/user_data/ARCHIVE/FELIX/RIG/CNTRLS/tent_cntrl.ma";
                    }
                    else
                    {
                    file -import -type "mayaAscii" -rpr ($listNames[$i]) -options
"v=0" "/hosts/guildford/user_data/ARCHIVE/FELIX/RIG/CNTRLS/cntrl.ma";
                    }
                   
                    if($i%2)
                    {
                    setAttr ctrl.sec 1;
                    setAttr rot_ctrl.sec 1;
                    }
                   
                   
                    spaceLocator -name ctrl_xtra_LOC;
                    select ctrl_xtra_LOC;
                    sets -add SEL;
                    parent ctrl_xtra_LOC ctrl_LOC;
                    setAttr ctrl_xtra_LOC.t 0 0 0;
                    setAttr ctrl_xtra_LOC.r 0 0 0;
                    setAttr ctrl_xtra_LOC.s 1 1 1;
                    parent ctrl ctrl_xtra_LOC;
                    setAttr ctrl_xtra_LOCShape.v 0;
                                       
                    select SEL;
                    string $list[] = `ls -sl`;
                    sets -rm SEL;
                    delete SEL;
                    select -cl;
                    string $item;
                    for($item in $list)
                    {
                    rename $item ($listNames[$i] + "_" + $item);
                    }
                   
                   
                    setAttr ($listNames[$i] + "_ctrl_LOC.s") ($ctrl_scale * $incr)
($ctrl_scale * $incr) ($ctrl_scale * $incr);
                    $incr -= $scale;
                    makeIdentity -a 1 -s 1 ($listNames[$i] + "_ctrl_LOC");
                    select $listLocs[$i] ($listNames[$i] + "_ctrl_LOC");
                    $n = `orientConstraint`;
                    delete `orientConstraint`;
                    select $listLocs[$i] ($listNames[$i] + "_ctrl_LOC");
                    $n = `pointConstraint`;
                    delete `pointConstraint`;
                   
                   

                select ($listNames[$i] + "_ctrl_LOC");
                //rotate -r -os -90 0 -90;
                    //parent ($listNames[$i] + "_upv_LOC") ($listNames[$i] +  "_rot_ctrl");
                    select -cl;
                    delete ($listNames[$i] + "_rot_ctrl_UPV");
                   
                    if(`objExists ($listNames[$i] + "_cls_POC")`)
                    {
                    delete ($listNames[$i] + "_cls_POC");
                    }
                   
                   
                    if(`objExists ($listNames[$i] + "_CLH")`)
                    {
                    parent -w ($listNames[$i] + "_CLS");
                    delete ($listNames[$i] + "_PIV");
                    parent ($listNames[$i] + "_CLH") ($listNames[$i] + "_rot_ctrl");
                    }
                    else
                    {
                    parent -w ($listNames[$i] + "_CLS");
                    delete ($listNames[$i] + "_PIV");
                    parent ($listNames[$i] + "_CLS") ($listNames[$i] + "_rot_ctrl");
                    }
                   
                   
                    select -cl;

                    shadingNode -asUtility plusMinusAverage -name ($listNames[$i] +  "_x_ADD");
                    shadingNode -asUtility plusMinusAverage -name ($listNames[$i] +  "_y_ADD");
                    shadingNode -asUtility plusMinusAverage -name ($listNames[$i] +  "_z_ADD");
                   
                    if($i == 0)
                    {
                    $conSel[size($conSel)] = ($listNames[$i] + "_ctrl");
                    }
                    else
                    {
                        if($i == (size($listLocs)-1))
                        {
                        $conSel[size($conSel)] = ($listNames[$i] + "_ctrl");
                        }
                        else
                        {
                        $conSel[size($conSel)] = ($listNames[$i] + "_ctrl_LOC");
                        }
                    }

                    if($i > 0)
                    {
                    parent ($listNames[$i] + "_ctrl_LOC") ($listNames[$i -1] +  "_rot_ctrl");
                    addAttr -ln curlx -at double ($listNames[$i-1] + "_ctrl");
                    setAttr -e -keyable true ($listNames[$i-1] + "_ctrl.curlx");
                    addAttr -ln curly -at double ($listNames[$i-1] + "_ctrl");
                    setAttr -e -keyable true ($listNames[$i-1] + "_ctrl.curly");
                    addAttr -ln curlz -at double ($listNames[$i-1] + "_ctrl");
                    setAttr -e -keyable true ($listNames[$i-1] + "_ctrl.curlz");
                    }
                    else
                    {
                    connectAttr ($listNames[$i] + "_ctrl.rot_axes") ($listNames[$i] +  "_ctrl_xtra_LOC.rx");
                    }
                   
                    select -cl;
    }


//=== connect curls


if($constraint == 1)
{
select ($name + "*ctrl_LOC");
string $sel[] = `ls -sl`;
select -d ($name + "*root_ctrl_LOC") ($name + "*rot_ctrl_LOC");
parent -w;

select $sel;
makeIdentity -a 1 -s 1 -t 1 -r 1;

select $conSel;
averagePointConstraint;
}

    select $listLocs;
    string $lista[] = `ls -sl`;
        for($n = 0; $n < (size($lista)); $n++)
        {
            for($i = 0; $i < $n; $i ++)
            {
            connectAttr -f ($listNames[$i] + "_ctrl.curlx") ($listNames[$n] +  "_x_ADD.input1D[" + ($i) + "]");
            connectAttr -f ($listNames[$i] + "_ctrl.curly") ($listNames[$n] +  "_y_ADD.input1D[" + ($i) + "]");
            connectAttr -f ($listNames[$i] + "_ctrl.curlz") ($listNames[$n] +  "_z_ADD.input1D[" + ($i) + "]");
           
                                    }
                if($n > 0)
                {
                connectAttr -f ($listNames[$n] + "_x_ADD.output1D") ($listNames[$n]
+ "_ctrl_xtra_LOC.rx");
                connectAttr -f ($listNames[$n] + "_y_ADD.output1D") ($listNames[$n]
+ "_ctrl_xtra_LOC.ry");
                connectAttr -f ($listNames[$n] + "_z_ADD.output1D") ($listNames[$n]
+ "_ctrl_xtra_LOC.rz");
                }
        }


string $wire1;
string $wire2 = ($name + "upv_CRV");;


if(`objExists ($name + "*CRV")`)
{
int $num = size($lista);
$wire1 = ($name + "CRV");

if($dyn == 1)
{
select ($name + "CRV");
string $dynElements[] = `makeCurveDyn`;


addAttr -ln stretch -at double  -min 0 -max 1 -dv 0 ($name +  "root_ctrl");
addAttr -ln dynamic -at double -min 0 -max 1 -dv 1 ($name +  "root_ctrl");
addAttr -ln dyn_stiffness -at double  -min 0 -max 1 -dv 1 ($name +  "root_ctrl");
addAttr -ln dyn_iterations -at double  -min 0 -max 100 -dv 10 ($name +  "root_ctrl");
addAttr -ln dyn_tip_stiffness -at double -min 0 -max 1 -dv 0 ($name +  "root_ctrl");
addAttr -ln dyn_mid_stiffness -at double  -min 0 -max 1 -dv 0 ($name +  "root_ctrl");
addAttr -ln dyn_gravity -at double  -min 0 -max 1 -dv 0.1 ($name +  "root_ctrl");
addAttr -ln dyn_damp -at double  -min 0 -max 100 -dv 80 ($name +  "root_ctrl");


setAttr -e -keyable true ($name + "root_ctrl.dynamic");
setAttr -e -keyable true ($name + "root_ctrl.dyn_iterations");
setAttr -e -keyable true ($name + "root_ctrl.stretch");
setAttr -e -keyable true ($name + "root_ctrl.dyn_gravity");


connectAttr ($name + "root_ctrl.dynamic") ($dynElements[2] + ".blend");

string $shape[] = `listRelatives -typ shape $dynElements[0]`;

connectAttr ($name + "root_ctrl.dyn_stiffness") ($shape[0] +  ".stiffness");
connectAttr ($name + "root_ctrl.dyn_iterations") ($shape[0] +  ".iterations");
connectAttr ($name + "root_ctrl.dyn_mid_stiffness") ($shape[0] +  ".stiffnessScale[1].stiffnessScale_Position");
connectAttr ($name + "root_ctrl.dyn_tip_stiffness") ($shape[0] +  ".stiffnessScale[1].stiffnessScale_FloatValue");
connectAttr ($name + "root_ctrl.dyn_gravity") ($shape[0] + ".gravity");
connectAttr ($name + "root_ctrl.dyn_damp") ($shape[0] + ".damp");
connectAttr ($name + "root_ctrl.stretch") ($shape[0] + ".lengthFlex");


select $dynElements[2] ($name + "upv_CRV");
$wire1 = $dynElements[2];

}
else
{
select ($name + "CRV") ($name + "upv_CRV");
$wire1 = ($name + "CRV");
}

int $jntNum;


if(`gmatch $name "*5*"` == 1)
{
$jntNum = 10;
}
else
{
    if(`gmatch $name "*6*"` == 1)
    {
    $jntNum = 10;
    }
    else
    {
   
        if(`gmatch $name "*7*"` == 1)
        {
        $jntNum = 10;
        }
        else
        {
            if($hires == 1)
            {
            $jntNum = 20;
            }
            else
            {
            $jntNum = 10;
            }
        }
    }

}





////print ("\nthe name is " + $name + "\n");
////print ("\nthe number is " + $jntNum + "\n");


string $neckLocs[] = `joints_on_path_upv $name $jntNum`;
string $listJntNames[] = $neckLocs;

    //=== cages
   
    for($p = 1; $p < $jntNum; $p++)
    {
        if($p == $jntNum)
        {
        string $jointChild[] = `listRelatives -typ joint $neckLocs[$jntNum
-1]`;
        rename $jointChild[0] ($listJntNames[$jntNum -1] + "_JNT");
        select ($listJntNames[$jntNum -1] + "_JNT")  ($listJntNames[$jntNum
-2] + "_JNT");
        pullCage $listJntNames[$jntNum -1] 3 1;
        }
        else
        {
        string $jointCd[] = `listRelatives -typ joint ($neckLocs[$p -1] +  "_jnt_LOC")`;
        rename $jointCd[0] ($listJntNames[$p -1] + "_JNT");
        string $jointCd2[] = `listRelatives -typ joint ($neckLocs[$p] +  "_jnt_LOC")`;
        rename $jointCd2[0] ($listJntNames[$p] + "_JNT");

        select ($listJntNames[$p -1] + "_JNT") ($listJntNames[$p] + "_JNT");
        pullCage $listJntNames[$p -1] 3 1;
        }
    }



    //=== end cages

//=== new stretch

if(`objExists ($name + "fin_CRV.stretch")`)
{
connectAttr ($name + "root_ctrl.stretch") ($name + "fin_CRV.stretch");
}

//=== end new stretch


//=== scale rig

if(`objExists ($rig_prefix + $rig_name + ".scale_rig")`)
{

select ($name + "*_jnt_LOC");
string $list[] = `ls -sl`;
string $item;
select -cl;
    for($item in $list)
    {
    connectAttr ($rig_prefix + $rig_name + ".scale_rig") ($item + ".sx");
    connectAttr ($rig_prefix + $rig_name + ".scale_rig") ($item + ".sy");
    connectAttr ($rig_prefix + $rig_name + ".scale_rig") ($item + ".sz");

    setAttr -keyable false ($item + ".sx");
    setAttr -keyable false ($item + ".sy");
    setAttr -keyable false ($item + ".sz");
    }
}

//=== end scale rig

string $tmp[];
for($i = 0; $i < size($neckLocs); $i++)
{
$tmp[size($tmp)] = ($neckLocs[$i] + "_jnt_LOC");
}

$neckLocs = $tmp;

return {$wire1, $wire2, $memberCage[0]};
select -cl;
//print "\nFLIPPER RIG DONE\n";
}
else
{
return {$wire1, $wire2, $memberCage[0]};
select -cl;
//print "\nFLIPPER RIG DONE\n";
}

}

}

//=== end flipper_rig



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//=== fin rig



    global proc string[] fin_rig(string $name, int $constraint, int $dyn,
int $jntNum )
    {

    select -cl;
//==== global variables

global string $FsRigPrefix;
global string $FsRigName;

//=== names

global string $rig_pref;
global string $rig_name;
global string $rig_prefix;
global string $prefixL;
global string $prefixR;

//=== modules

global int $hires;
global int $normal_spines;
global int $long_spines;
global int $long_necks;
global int $short_necks;
global int $heads;
global int $human_arms;
global int $human_legs;
global int $quadr_legs;
global int $human_feet;;
global int $one_finger_hands;
global int $two_finger_hands;
global int $three_finger_hands;
global int $four_finger_hands;
global int $five_finger_hands;
global int $bird_wings;
global int $bat_wings;
global int $tentacles;
global int $tails;
global int $fins;
global int $flippers;
global int $rig_type;
global int $quad_rig_type;
global int $bird_rig_type;
global int $rept_rig_type;
global int $hires;
global int $normal_spines;
global int $long_spines;
global int $long_necks;
global int $short_necks;
global int $heads;
global int $human_arms;
global int $human_legs;
global int $quadr_legs;
global int $human_feet;
global int $one_finger_hands;
global int $two_finger_hands;
global int $three_finger_hands;
global int $four_finger_hands;
global int $five_finger_hands;
global int $bird_wings;
global int $bat_wings;
global int $tentacles;
global int $tails;
global int $fins;
global int $flippers;
global int $doStretch;
global int $doToes;
getGlobVar;
//getGlobSet;

select ($name + "GRP");
string $listGrps[] = `ls -sl`;
select -cl;
string $tentacle;
string $tentacleNames[];
string $neckLocs[];
string $memberCage[];


for($t = 0; $t < size($listGrps); $t++)
{
select $listGrps[$t];
string $tentacleName[] = `strip_suffix 0`;
$tentacleNames[`size($tentacleNames)`] = $tentacleName[0];

select ($tentacleNames[$t] + "_*_LOC");
select -d ($tentacleNames[$t] + "_*_upv_LOC");
string $listLocs[] = `ls -sl`;

//=== fix root and end in the right order;

string $nnn[];

for($i = 0; $i < size($listLocs); $i++)
{

    if($i > 0)
    {
    $nnn[size($nnn)] = $listLocs[$i-1];
    }
    else
    {
    $nnn[size($nnn)] = $listLocs[size($listLocs) - 1];
    }
   
}   


//=== end fix


$listLocs = $nnn;
select $listLocs;


string $listNames[] = `strip_suffix 0`;



select -cl;
string $conSel[];

//=== get ctls scale

select $listLocs[0] $listLocs[size($listLocs) -1];
float $tentLength = `get_distance`;
float $ctrl_scale = ($tentLength / 100);
float $scale = 0.1;
float $incr = 1;

select -cl;

//=== end get ctls scale

    for($i = 0; $i < size($listLocs); $i++)
    {
               

                    //=== import controls
                   
                    if($i == 0)
                    {
                    file -import -type "mayaAscii" -rpr ($listNames[$i]) -options
"v=0" "/hosts/guildford/user_data/ARCHIVE/FELIX/RIG/CNTRLS/tent_cntrl.ma";
                    }
                    else
                    {
                    file -import -type "mayaAscii" -rpr ($listNames[$i]) -options
"v=0" "/hosts/guildford/user_data/ARCHIVE/FELIX/RIG/CNTRLS/cntrl.ma";
                    }
                   
                    if($i%2)
                    {
                    setAttr ctrl.sec 1;
                    setAttr rot_ctrl.sec 1;
                    }
                   
                   
                    spaceLocator -name ctrl_xtra_LOC;
                    select ctrl_xtra_LOC;
                    sets -add SEL;
                    parent ctrl_xtra_LOC ctrl_LOC;
                    setAttr ctrl_xtra_LOC.t 0 0 0;
                    setAttr ctrl_xtra_LOC.r 0 0 0;
                    setAttr ctrl_xtra_LOC.s 1 1 1;
                    parent ctrl ctrl_xtra_LOC;
                    setAttr ctrl_xtra_LOCShape.v 0;
                                       
                    select SEL;
                    string $list[] = `ls -sl`;
                    sets -rm SEL;
                    delete SEL;
                    select -cl;
                    string $item;
                    for($item in $list)
                    {
                    rename $item ($listNames[$i] + "_" + $item);
                    }
                   
                   
                    setAttr ($listNames[$i] + "_ctrl_LOC.s") ($ctrl_scale * $incr)
($ctrl_scale * $incr) ($ctrl_scale * $incr);
                    $incr -= $scale;
                    makeIdentity -a 1 -s 1 ($listNames[$i] + "_ctrl_LOC");
                    select $listLocs[$i] ($listNames[$i] + "_ctrl_LOC");
                    $n = `orientConstraint`;
                    delete `orientConstraint`;
                    select $listLocs[$i] ($listNames[$i] + "_ctrl_LOC");
                    $n = `pointConstraint`;
                    delete `pointConstraint`;
                   
                   

                select ($listNames[$i] + "_ctrl_LOC");
                //rotate -r -os -90 0 -90;
                    //parent ($listNames[$i] + "_upv_LOC") ($listNames[$i] +  "_rot_ctrl");
                    select -cl;
                    delete ($listNames[$i] + "_rot_ctrl_UPV");
                   
                    if(`objExists ($listNames[$i] + "_cls_POC")`)
                    {
                    delete ($listNames[$i] + "_cls_POC");
                    }
                   
                   
                    if(`objExists ($listNames[$i] + "_CLH")`)
                    {
                    ////print ("\ndeleting " + $listNames[$i] + "_PIV");
                    parent -w ($listNames[$i] + "_CLS");
                    delete ($listNames[$i] + "_PIV");
                    ////print ("\nconstraining " + $listNames[$i] + "_CLH to " +  $listNames[$i] + "_rot_ctrl\n");
                    parent ($listNames[$i] + "_CLH") ($listNames[$i] + "_rot_ctrl");
                    }
                    else
                    {
                    ////print ("\ndeleting " + $listNames[$i] + "_PIV");
                    parent -w ($listNames[$i] + "_CLS");
                    delete ($listNames[$i] + "_PIV");
                    ////print ("\nconstraining " + $listNames[$i] + "_CLS to " +  $listNames[$i] + "_rot_ctrl\n");
                    parent ($listNames[$i] + "_CLS") ($listNames[$i] + "_rot_ctrl");
                    }
                   
                   
                    select -cl;

                    shadingNode -asUtility plusMinusAverage -name ($listNames[$i] +  "_x_ADD");
                    shadingNode -asUtility plusMinusAverage -name ($listNames[$i] +  "_y_ADD");
                    shadingNode -asUtility plusMinusAverage -name ($listNames[$i] +  "_z_ADD");
                   
                    if($i == 0)
                    {
                    $conSel[size($conSel)] = ($listNames[$i] + "_ctrl");
                    }
                    else
                    {
                        if($i == (size($listLocs)-1))
                        {
                        $conSel[size($conSel)] = ($listNames[$i] + "_ctrl");
                        }
                        else
                        {
                        $conSel[size($conSel)] = ($listNames[$i] + "_ctrl_LOC");
                        }
                    }

                    if($i > 0)
                    {
                    parent ($listNames[$i] + "_ctrl_LOC") ($listNames[$i -1] +  "_rot_ctrl");
                    addAttr -ln curlx -at double ($listNames[$i-1] + "_ctrl");
                    setAttr -e -keyable true ($listNames[$i-1] + "_ctrl.curlx");
                    addAttr -ln curly -at double ($listNames[$i-1] + "_ctrl");
                    setAttr -e -keyable true ($listNames[$i-1] + "_ctrl.curly");
                    addAttr -ln curlz -at double ($listNames[$i-1] + "_ctrl");
                    setAttr -e -keyable true ($listNames[$i-1] + "_ctrl.curlz");
                    //connectAttr ($listNames[$i] + "_ctrl.rot_axes") ($listNames[$i] +  "_ctrl_LOC.rx");
                    }
                    else
                    {
                    connectAttr ($listNames[$i] + "_ctrl.rot_axes") ($listNames[$i] +  "_ctrl_xtra_LOC.rx");
                    }
                   
                    select -cl;
    }


//=== connect curls


if($constraint == 1)
{
select ($name + "*ctrl_LOC");
string $sel[] = `ls -sl`;
select -d ($name + "*root_ctrl_LOC") ($name + "*rot_ctrl_LOC");
parent -w;

select $sel;
makeIdentity -a 1 -s 1 -t 1 -r 1;

select $conSel;
averagePointConstraint;
}

    select $listLocs;
    string $lista[] = `ls -sl`;
        for($n = 0; $n < (size($lista)); $n++)
        {
            for($i = 0; $i < $n; $i ++)
            {
            connectAttr -f ($listNames[$i] + "_ctrl.curlx") ($listNames[$n] +  "_x_ADD.input1D[" + ($i) + "]");
            connectAttr -f ($listNames[$i] + "_ctrl.curly") ($listNames[$n] +  "_y_ADD.input1D[" + ($i) + "]");
            connectAttr -f ($listNames[$i] + "_ctrl.curlz") ($listNames[$n] +  "_z_ADD.input1D[" + ($i) + "]");
           
                                    }
                if($n > 0)
                {
                connectAttr -f ($listNames[$n] + "_x_ADD.output1D") ($listNames[$n]
+ "_ctrl_xtra_LOC.rx");
                connectAttr -f ($listNames[$n] + "_y_ADD.output1D") ($listNames[$n]
+ "_ctrl_xtra_LOC.ry");
                connectAttr -f ($listNames[$n] + "_z_ADD.output1D") ($listNames[$n]
+ "_ctrl_xtra_LOC.rz");
                }
        }


string $wire1;
string $wire2 = ($name + "upv_CRV");;


if(`objExists ($name + "*CRV")`)
{
int $num = size($lista);
//select ($name + "CRV") ($name + "upv_CRV");
$wire1 = ($name + "CRV");

if($dyn == 1)
{
select ($name + "CRV");
string $dynElements[] = `makeCurveDyn`;


addAttr -ln stretch -at double  -min 0 -max 1 -dv 0 ($name +  "root_ctrl");
addAttr -ln dynamic -at double -min 0 -max 1 -dv 1 ($name +  "root_ctrl");
addAttr -ln dyn_stiffness -at double  -min 0 -max 1 -dv 1 ($name +  "root_ctrl");
addAttr -ln dyn_iterations -at double  -min 0 -max 100 -dv 10 ($name +  "root_ctrl");
addAttr -ln dyn_tip_stiffness -at double -min 0 -max 1 -dv 0 ($name +  "root_ctrl");
addAttr -ln dyn_mid_stiffness -at double  -min 0 -max 1 -dv 0 ($name +  "root_ctrl");
addAttr -ln dyn_gravity -at double  -min 0 -max 1 -dv 0.1 ($name +  "root_ctrl");
addAttr -ln dyn_damp -at double  -min 0 -max 100 -dv 80 ($name +  "root_ctrl");


setAttr -e -keyable true ($name + "root_ctrl.dynamic");
setAttr -e -keyable true ($name + "root_ctrl.dyn_iterations");
setAttr -e -keyable true ($name + "root_ctrl.stretch");
setAttr -e -keyable true ($name + "root_ctrl.dyn_gravity");


connectAttr ($name + "root_ctrl.dynamic") ($dynElements[2] + ".blend");

string $shape[] = `listRelatives -typ shape $dynElements[0]`;

connectAttr ($name + "root_ctrl.dyn_stiffness") ($shape[0] +  ".stiffness");
connectAttr ($name + "root_ctrl.dyn_iterations") ($shape[0] +  ".iterations");
connectAttr ($name + "root_ctrl.dyn_mid_stiffness") ($shape[0] +  ".stiffnessScale[1].stiffnessScale_Position");
connectAttr ($name + "root_ctrl.dyn_tip_stiffness") ($shape[0] +  ".stiffnessScale[1].stiffnessScale_FloatValue");
connectAttr ($name + "root_ctrl.dyn_gravity") ($shape[0] + ".gravity");
connectAttr ($name + "root_ctrl.dyn_damp") ($shape[0] + ".damp");
connectAttr ($name + "root_ctrl.stretch") ($shape[0] + ".lengthFlex");


select $dynElements[2] ($name + "upv_CRV");
$wire1 = $dynElements[2];

}
else
{
select ($name + "CRV") ($name + "upv_CRV");
$wire1 = ($name + "CRV");
}

/*
select ($name + "root_ctrl") ($name + "end_ctrl");
$memberCage[0] = `memberCage $name 0.5 1`;
*/


//int $jntNum;
/*
if(`gmatch $name "*5*"` == 1)
{
$jntNum = 10;
}
else
{
    if(`gmatch $name "*6*"` == 1)
    {
    $jntNum = 10;
    }
    else
    {
   
        if(`gmatch $name "*7*"` == 1)
        {
        $jntNum = 10;
        }
        else
        {
        $jntNum = 30;
        }
    }
}

*/

////print ("\nthe name is " + $name + "\n");
////print ("\nthe number is " + $jntNum + "\n");


string $neckLocs[] = `joints_on_path_upv_fin $name $jntNum`;
string $listJntNames[] = $neckLocs;

    //=== cages
   
    for($p = 1; $p < $jntNum; $p++)
    {
        if($p == $jntNum)
        {
        string $jointChild[] = `listRelatives -typ joint $neckLocs[$jntNum
-1]`;
        rename $jointChild[0] ($listJntNames[$jntNum -1] + "_JNT");
        select ($listJntNames[$jntNum -1] + "_JNT")  ($listJntNames[$jntNum
-2] + "_JNT");
        pullCage $listJntNames[$jntNum -1] 3 1;
        }
        else
        {
        string $jointCd[] = `listRelatives -typ joint ($neckLocs[$p -1] +  "_jnt_LOC")`;
        rename $jointCd[0] ($listJntNames[$p -1] + "_JNT");
        string $jointCd2[] = `listRelatives -typ joint ($neckLocs[$p] +  "_jnt_LOC")`;
        rename $jointCd2[0] ($listJntNames[$p] + "_JNT");

        select ($listJntNames[$p -1] + "_JNT") ($listJntNames[$p] + "_JNT");
        pullCage $listJntNames[$p -1] 3 1;
        }
    }



    //=== end cages



//select $neckLocs;
string $tmp[];
for($i = 0; $i < size($neckLocs); $i++)
{
$tmp[size($tmp)] = ($neckLocs[$i] + "_jnt_LOC");
}

$neckLocs = $tmp;

return {$wire1, $wire2, $memberCage[0]};
select -cl;
//print "\nTENTACLE RIG DONE\n";
}
else
{
return {$wire1, $wire2, $memberCage[0]};
select -cl;
//print "\nTENTACLE RIG DONE\n";
}

}

}

//=== end fin rig

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//=== tail rig



    global proc string[] tail_rig(string $name, int $constraint, int $dyn)

    {

    select -cl;
//==== global variables

global string $FsRigPrefix;
global string $FsRigName;

//=== names

global string $rig_pref;
global string $rig_name;
global string $rig_prefix;
global string $prefixL;
global string $prefixR;

//=== modules

global int $hires;
global int $normal_spines;
global int $long_spines;
global int $long_necks;
global int $short_necks;
global int $heads;
global int $human_arms;
global int $human_legs;
global int $quadr_legs;
global int $human_feet;;
global int $one_finger_hands;
global int $two_finger_hands;
global int $three_finger_hands;
global int $four_finger_hands;
global int $five_finger_hands;
global int $bird_wings;
global int $bat_wings;
global int $tentacles;
global int $tails;
global int $fins;
global int $flippers;
global int $rig_type;
global int $quad_rig_type;
global int $bird_rig_type;
global int $rept_rig_type;
global int $hires;
global int $normal_spines;
global int $long_spines;
global int $long_necks;
global int $short_necks;
global int $heads;
global int $human_arms;
global int $human_legs;
global int $quadr_legs;
global int $human_feet;
global int $one_finger_hands;
global int $two_finger_hands;
global int $three_finger_hands;
global int $four_finger_hands;
global int $five_finger_hands;
global int $bird_wings;
global int $bat_wings;
global int $tentacles;
global int $tails;
global int $fins;
global int $flippers;
global int $doStretch;
global int $doToes;
getGlobVar;
//getGlobSet;

select ($name + "GRP");
string $listGrps[] = `ls -sl`;
select -cl;
string $tail;
string $tailNames[];
string $neckLocs[];
string $memberCage[];


for($t = 0; $t < size($listGrps); $t++)
{
select $listGrps[$t];
string $tailName[] = `strip_suffix 0`;
$tailNames[`size($tailNames)`] = $tailName[0];

select ($tailNames[$t] + "_*_LOC");
select -d ($tailNames[$t] + "_*_upv_LOC");
string $listLocs[] = `ls -sl`;

//=== fix root and end in the right order;

string $nnn[];

for($i = 0; $i < size($listLocs); $i++)
{

    if($i > 0)
    {
    $nnn[size($nnn)] = $listLocs[$i-1];
    }
    else
    {
    $nnn[size($nnn)] = $listLocs[size($listLocs) - 1];
    }
   
}   


//=== end fix


$listLocs = $nnn;
select $listLocs;


string $listNames[] = `strip_suffix 0`;



select -cl;
string $conSel[];

//=== get ctls scale

select $listLocs[0] $listLocs[size($listLocs) -1];
float $tentLength = `get_distance`;
float $ctrl_scale = ($tentLength / 100);
float $scale = 0.1;
float $incr = 1;

select -cl;

//=== end get ctls scale

    for($i = 0; $i < size($listLocs); $i++)
    {
               

                    //=== import controls
                   
                    file -import -type "mayaAscii" -rpr ($listNames[$i]) -options
"v=0" "/hosts/guildford/user_data/ARCHIVE/FELIX/RIG/CNTRLS/tail_cntrl.ma";
                   
                    if($i%2)
                    {
                    setAttr ctrl.sec 1;
                    setAttr rot_ctrl.sec 1;
                    }
                   
                   
                    spaceLocator -name ctrl_xtra_LOC;
                    select ctrl_xtra_LOC;
                    sets -add SEL;
                    parent ctrl_xtra_LOC ctrl_LOC;
                    setAttr ctrl_xtra_LOC.t 0 0 0;
                    setAttr ctrl_xtra_LOC.r 0 0 0;
                    setAttr ctrl_xtra_LOC.s 1 1 1;
                    parent ctrl ctrl_xtra_LOC;
                    setAttr ctrl_xtra_LOCShape.v 0;
                                       
                    select SEL;
                    string $list[] = `ls -sl`;
                    sets -rm SEL;
                    delete SEL;
                    select -cl;
                    string $item;
                    for($item in $list)
                    {
                    rename $item ($listNames[$i] + "_" + $item);
                    }
                   
                   
                    setAttr ($listNames[$i] + "_ctrl_LOC.s") ($ctrl_scale * $incr)
($ctrl_scale * $incr) ($ctrl_scale * $incr);
                    $incr -= $scale;
                    makeIdentity -a 1 -s 1 ($listNames[$i] + "_ctrl_LOC");
                    select $listLocs[$i] ($listNames[$i] + "_ctrl_LOC");
                    $n = `orientConstraint`;
                    delete `orientConstraint`;
                    select $listLocs[$i] ($listNames[$i] + "_ctrl_LOC");
                    $n = `pointConstraint`;
                    delete `pointConstraint`;
                   
                   

                select ($listNames[$i] + "_ctrl_LOC");
                //rotate -r -os -90 0 -90;
                    //parent ($listNames[$i] + "_upv_LOC") ($listNames[$i] +  "_rot_ctrl");
                    select -cl;
                    delete ($listNames[$i] + "_rot_ctrl_UPV");
                   
                    if(`objExists ($listNames[$i] + "_cls_POC")`)
                    {
                    delete ($listNames[$i] + "_cls_POC");
                    }
                   
                   
                    if(`objExists ($listNames[$i] + "_CLH")`)
                    {
                    ////print ("\ndeleting " + $listNames[$i] + "_PIV");
                    parent -w ($listNames[$i] + "_CLS");
                    delete ($listNames[$i] + "_PIV");
                    parent ($listNames[$i] + "_CLH") ($listNames[$i] + "_rot_ctrl");
                    }
                    else
                    {
                    ////print ("\ndeleting " + $listNames[$i] + "_PIV");
                    parent -w ($listNames[$i] + "_CLS");
                    delete ($listNames[$i] + "_PIV");
                    ////print ("\nconstraining " + $listNames[$i] + "_CLS to " +  $listNames[$i] + "_rot_ctrl\n");
                    parent ($listNames[$i] + "_CLS") ($listNames[$i] + "_rot_ctrl");
                    }
                   
                   
                    select -cl;

                    shadingNode -asUtility plusMinusAverage -name ($listNames[$i] +  "_x_ADD");
                    shadingNode -asUtility plusMinusAverage -name ($listNames[$i] +  "_y_ADD");
                    shadingNode -asUtility plusMinusAverage -name ($listNames[$i] +  "_z_ADD");
                   
                    if($i == 0)
                    {
                    $conSel[size($conSel)] = ($listNames[$i] + "_ctrl");
                    }
                    else
                    {
                        if($i == (size($listLocs)-1))
                        {
                        $conSel[size($conSel)] = ($listNames[$i] + "_ctrl");
                        }
                        else
                        {
                        $conSel[size($conSel)] = ($listNames[$i] + "_ctrl_LOC");
                        }
                    }

                    if($i > 0)
                    {
                    parent ($listNames[$i] + "_ctrl_LOC") ($listNames[$i -1] +  "_rot_ctrl");
                    addAttr -ln curlx -at double ($listNames[$i-1] + "_ctrl");
                    setAttr -e -keyable true ($listNames[$i-1] + "_ctrl.curlx");
                    addAttr -ln curly -at double ($listNames[$i-1] + "_ctrl");
                    setAttr -e -keyable true ($listNames[$i-1] + "_ctrl.curly");
                    addAttr -ln curlz -at double ($listNames[$i-1] + "_ctrl");
                    setAttr -e -keyable true ($listNames[$i-1] + "_ctrl.curlz");
                    //connectAttr ($listNames[$i] + "_ctrl.rot_axes") ($listNames[$i] +  "_ctrl_LOC.rx");
                    }
                    else
                    {
                    connectAttr ($listNames[$i] + "_ctrl.rot_axes") ($listNames[$i] +  "_ctrl_xtra_LOC.rx");
                    }
                   
                    select -cl;
    }


//=== connect curls


if($constraint == 1)
{
select ($name + "*ctrl_LOC");
string $sel[] = `ls -sl`;
select -d ($name + "*root_ctrl_LOC") ($name + "*rot_ctrl_LOC");
parent -w;

select $sel;
makeIdentity -a 1 -s 1 -t 1 -r 1;

select $conSel;
averagePointConstraint;
}

    select $listLocs;
    string $lista[] = `ls -sl`;
        for($n = 0; $n < (size($lista)); $n++)
        {
            for($i = 0; $i < $n; $i ++)
            {
            connectAttr -f ($listNames[$i] + "_ctrl.curlx") ($listNames[$n] +  "_x_ADD.input1D[" + ($i) + "]");
            connectAttr -f ($listNames[$i] + "_ctrl.curly") ($listNames[$n] +  "_y_ADD.input1D[" + ($i) + "]");
            connectAttr -f ($listNames[$i] + "_ctrl.curlz") ($listNames[$n] +  "_z_ADD.input1D[" + ($i) + "]");
           
                                    }
                if($n > 0)
                {
                connectAttr -f ($listNames[$n] + "_x_ADD.output1D") ($listNames[$n]
+ "_ctrl_xtra_LOC.rx");
                connectAttr -f ($listNames[$n] + "_y_ADD.output1D") ($listNames[$n]
+ "_ctrl_xtra_LOC.ry");
                connectAttr -f ($listNames[$n] + "_z_ADD.output1D") ($listNames[$n]
+ "_ctrl_xtra_LOC.rz");
                }
        }


string $wire1;
string $wire2 = ($name + "upv_CRV");;


if(`objExists ($name + "*CRV")`)
{
int $num = size($lista);
//select ($name + "CRV") ($name + "upv_CRV");
$wire1 = ($name + "CRV");

if($dyn == 1)
{
select ($name + "CRV");
string $dynElements[] = `makeCurveDyn`;


addAttr -ln stretch -at double  -min 0 -max 1 -dv 0 ($name +  "root_ctrl");
addAttr -ln dynamic -at double -min 0 -max 1 -dv 0 ($name +  "root_ctrl");
addAttr -ln dyn_stiffness -at double  -min 0 -max 1 -dv 1 ($name +  "root_ctrl");
addAttr -ln dyn_iterations -at double  -min 0 -max 100 -dv 10 ($name +  "root_ctrl");
addAttr -ln dyn_tip_stiffness -at double -min 0 -max 1 -dv 0 ($name +  "root_ctrl");
addAttr -ln dyn_mid_stiffness -at double  -min 0 -max 1 -dv 0 ($name +  "root_ctrl");
addAttr -ln dyn_gravity -at double  -min 0 -max 1 -dv 1 ($name +  "root_ctrl");
addAttr -ln dyn_damp -at double  -min 0 -max 100 -dv 80 ($name +  "root_ctrl");


setAttr -e -keyable true ($name + "root_ctrl.dynamic");
setAttr -e -keyable true ($name + "root_ctrl.dyn_iterations");
setAttr -e -keyable true ($name + "root_ctrl.stretch");
setAttr -e -keyable true ($name + "root_ctrl.dyn_gravity");


connectAttr ($name + "root_ctrl.dynamic") ($dynElements[2] + ".blend");
connectAttr ($name + "root_ctrl.dyn_stiffness") ($dynElements[0] +  "Shape.stiffness");
connectAttr ($name + "root_ctrl.dyn_iterations") ($dynElements[0] +  "Shape.iterations");
connectAttr ($name + "root_ctrl.dyn_mid_stiffness") ($dynElements[0] +  "Shape.stiffnessScale[1].stiffnessScale_Position");
connectAttr ($name + "root_ctrl.dyn_tip_stiffness") ($dynElements[0] +  "Shape.stiffnessScale[1].stiffnessScale_FloatValue");
connectAttr ($name + "root_ctrl.dyn_gravity") ($dynElements[0] +  "Shape.gravity");
connectAttr ($name + "root_ctrl.dyn_damp") ($dynElements[0] +  "Shape.damp");
connectAttr ($name + "root_ctrl.stretch") ($dynElements[0] +  "Shape.lengthFlex");

select $dynElements[2] ($name + "upv_CRV");
$wire1 = $dynElements[2];

}

/*
select ($name + "root_ctrl") ($name + "end_ctrl");
$memberCage[0] = `memberCage $name 0.5 1`;
*/



int $jntNum = 32;

////print ("\nthe name is " + $name + "\n");
////print ("\nthe number is " + $jntNum + "\n");


string $neckLocs[] = `joints_on_path_upv $name $jntNum`;
string $listJntNames[] = $neckLocs;
connectAttr ($name + "root_ctrl.stretch") ($name + "fin_CRV.stretch");
rebuildCurve -name ($name + "fin_crv_RBC")-ch 0 -rpo 1 -rt 0 -end 1 -kr
0 -kcp 0 -kep 1 -kt 0 -s 30 -d 3 -tol 1e-06 ($name + "fin_CRV");

    //=== cages
   
    for($p = 1; $p < $jntNum; $p++)
    {
        if($p == $jntNum)
        {
        string $jointChild[] = `listRelatives -typ joint $neckLocs[$jntNum
-1]`;
        rename $jointChild[0] ($listJntNames[$jntNum -1] + "_JNT");
        select ($listJntNames[$jntNum -1] + "_JNT")  ($listJntNames[$jntNum
-2] + "_JNT");
        pullCage $listJntNames[$jntNum -1] 3 1;
        }
        else
        {
        string $jointCd[] = `listRelatives -typ joint ($neckLocs[$p -1] +  "_jnt_LOC")`;
        rename $jointCd[0] ($listJntNames[$p -1] + "_JNT");
        string $jointCd2[] = `listRelatives -typ joint ($neckLocs[$p] +  "_jnt_LOC")`;
        rename $jointCd2[0] ($listJntNames[$p] + "_JNT");

        select ($listJntNames[$p -1] + "_JNT") ($listJntNames[$p] + "_JNT");
        pullCage $listJntNames[$p -1] 3 1;
        }
    }



    //=== end cages


//=== cleanup

parent ($name + "jnts_GRP") ($name + "upvs_GRP") ($name +  "no_trans_GRP");


//select $neckLocs;
string $tmp[];
for($i = 0; $i < size($neckLocs); $i++)
{
$tmp[size($tmp)] = ($neckLocs[$i] + "_jnt_LOC");
}

$neckLocs = $tmp;

return {$wire1, $wire2, $memberCage[0]};
select -cl;
//print "\nTAIL RIG DONE\n";
}
else
{
return {$wire1, $wire2, $memberCage[0]};
select -cl;
//print "\nTAIL RIG DONE\n";
}

}

}

//=== end tail rig

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//=== rope rig

    global proc string[] rope_rig(string $name, int $constraint, int $dyn,
int $hires)
    {
//==== global variables

global string $FsRigPrefix;
global string $FsRigName;

//=== names

global string $rig_pref;
global string $rig_name;
global string $rig_prefix;
global string $prefixL;
global string $prefixR;

//=== modules

global int $hires;
global int $normal_spines;
global int $long_spines;
global int $long_necks;
global int $short_necks;
global int $heads;
global int $human_arms;
global int $human_legs;
global int $quadr_legs;
global int $human_feet;;
global int $one_finger_hands;
global int $two_finger_hands;
global int $three_finger_hands;
global int $four_finger_hands;
global int $five_finger_hands;
global int $bird_wings;
global int $bat_wings;
global int $ropes;
global int $tails;
global int $fins;
global int $flippers;
global int $rig_type;
global int $quad_rig_type;
global int $bird_rig_type;
global int $rept_rig_type;
global int $hires;
global int $normal_spines;
global int $long_spines;
global int $long_necks;
global int $short_necks;
global int $heads;
global int $human_arms;
global int $human_legs;
global int $quadr_legs;
global int $human_feet;
global int $one_finger_hands;
global int $two_finger_hands;
global int $three_finger_hands;
global int $four_finger_hands;
global int $five_finger_hands;
global int $bird_wings;
global int $bat_wings;
global int $ropes;
global int $tails;
global int $fins;
global int $flippers;
global int $doStretch;
global int $doToes;
getGlobVar;

    select -cl;

select ($name + "GRP");
string $listGrps[] = `ls -sl`;
select -cl;
string $rope;
string $ropeNames[];
string $neckLocs[];
string $memberCage[];


for($t = 0; $t < size($listGrps); $t++)
{
select $listGrps[$t];
string $ropeName[] = `strip_suffix 0`;
$ropeNames[`size($ropeNames)`] = $ropeName[0];

select ($ropeNames[$t] + "_*_LOC");
select -d ($ropeNames[$t] + "_*_upv_LOC");
string $listLocs[] = `ls -sl`;

//=== fix root and end in the right order;

string $nnn[];

for($i = 0; $i < size($listLocs); $i++)
{

    if($i > 0)
    {
    $nnn[size($nnn)] = $listLocs[$i-1];
    }
    else
    {
    $nnn[size($nnn)] = $listLocs[size($listLocs) - 1];
    }
   
}   


//=== end fix


$listLocs = $nnn;
select $listLocs;


string $listNames[] = `strip_suffix 0`;



select -cl;
string $conSel[];

//=== get ctls scale

select $listLocs[0] $listLocs[size($listLocs) -1];
float $tentLength = `get_distance`;
float $ctrl_scale = ($tentLength / 100);
float $scale = 0.1;
float $incr = 1;

select -cl;

//=== end get ctls scale

    for($i = 0; $i < size($listLocs); $i++)
    {
               

                    //=== import controls
                   
                    if($i == 0)
                    {
                    file -import -type "mayaAscii" -rpr ($listNames[$i]) -options
"v=0" "/hosts/guildford/user_data/ARCHIVE/FELIX/RIG/CNTRLS/tent_cntrl.ma";
                    }
                    else
                    {
                    file -import -type "mayaAscii" -rpr ($listNames[$i]) -options
"v=0" "/hosts/guildford/user_data/ARCHIVE/FELIX/RIG/CNTRLS/cntrl.ma";
                    }
                   
                    if($i%2)
                    {
                    setAttr ctrl.sec 1;
                    setAttr rot_ctrl.sec 1;
                    }
                   
                   
                    spaceLocator -name ctrl_xtra_LOC;
                    select ctrl_xtra_LOC;
                    sets -add SEL;
                    parent ctrl_xtra_LOC ctrl_LOC;
                    setAttr ctrl_xtra_LOC.t 0 0 0;
                    setAttr ctrl_xtra_LOC.r 0 0 0;
                    setAttr ctrl_xtra_LOC.s 1 1 1;
                    parent ctrl ctrl_xtra_LOC;
                    setAttr ctrl_xtra_LOCShape.v 0;
                                       
                    select SEL;
                    string $list[] = `ls -sl`;
                    sets -rm SEL;
                    delete SEL;
                    select -cl;
                    string $item;
                    for($item in $list)
                    {
                    rename $item ($listNames[$i] + "_" + $item);
                    }
                   
                   
                    setAttr ($listNames[$i] + "_ctrl_LOC.s") ($ctrl_scale * $incr)
($ctrl_scale * $incr) ($ctrl_scale * $incr);
                    $incr -= $scale;
                    makeIdentity -a 1 -s 1 ($listNames[$i] + "_ctrl_LOC");
                    select $listLocs[$i] ($listNames[$i] + "_ctrl_LOC");
                    $n = `orientConstraint`;
                    delete `orientConstraint`;
                    select $listLocs[$i] ($listNames[$i] + "_ctrl_LOC");
                    $n = `pointConstraint`;
                    delete `pointConstraint`;
                   
                   

                select ($listNames[$i] + "_ctrl_LOC");
                //rotate -r -os -90 0 -90;
                    //parent ($listNames[$i] + "_upv_LOC") ($listNames[$i] +  "_rot_ctrl");
                    select -cl;
                    delete ($listNames[$i] + "_rot_ctrl_UPV");
                   
                    if(`objExists ($listNames[$i] + "_cls_POC")`)
                    {
                    delete ($listNames[$i] + "_cls_POC");
                    }
                   
                   
                    if(`objExists ($listNames[$i] + "_CLH")`)
                    {
                    parent -w ($listNames[$i] + "_CLS");
                    delete ($listNames[$i] + "_PIV");
                    parent ($listNames[$i] + "_CLH") ($listNames[$i] + "_rot_ctrl");
                    }
                    else
                    {
                    parent -w ($listNames[$i] + "_CLS");
                    delete ($listNames[$i] + "_PIV");
                    parent ($listNames[$i] + "_CLS") ($listNames[$i] + "_rot_ctrl");
                    }
                   
                   
                    select -cl;

                    shadingNode -asUtility plusMinusAverage -name ($listNames[$i] +  "_x_ADD");
                    shadingNode -asUtility plusMinusAverage -name ($listNames[$i] +  "_y_ADD");
                    shadingNode -asUtility plusMinusAverage -name ($listNames[$i] +  "_z_ADD");
                   
                    if($i == 0)
                    {
                    $conSel[size($conSel)] = ($listNames[$i] + "_ctrl");
                    }
                    else
                    {
                        if($i == (size($listLocs)-1))
                        {
                        $conSel[size($conSel)] = ($listNames[$i] + "_ctrl");
                        }
                        else
                        {
                        $conSel[size($conSel)] = ($listNames[$i] + "_ctrl_LOC");
                        }
                    }

                    if($i > 0)
                    {
                    parent ($listNames[$i] + "_ctrl_LOC") ($listNames[$i -1] +  "_rot_ctrl");
                    addAttr -ln curlx -at double ($listNames[$i-1] + "_ctrl");
                    setAttr -e -keyable true ($listNames[$i-1] + "_ctrl.curlx");
                    addAttr -ln curly -at double ($listNames[$i-1] + "_ctrl");
                    setAttr -e -keyable true ($listNames[$i-1] + "_ctrl.curly");
                    addAttr -ln curlz -at double ($listNames[$i-1] + "_ctrl");
                    setAttr -e -keyable true ($listNames[$i-1] + "_ctrl.curlz");
                    }
                    else
                    {
                    connectAttr ($listNames[$i] + "_ctrl.rot_axes") ($listNames[$i] +  "_ctrl_xtra_LOC.rx");
                    }
                   
                    select -cl;
    }


//=== connect curls


if($constraint == 1)
{
select ($name + "*ctrl_LOC");
string $sel[] = `ls -sl`;
select -d ($name + "*root_ctrl_LOC") ($name + "*rot_ctrl_LOC");
parent -w;

select $sel;
makeIdentity -a 1 -s 1 -t 1 -r 1;

select $conSel;
averagePointConstraint;
}

    select $listLocs;
    string $lista[] = `ls -sl`;
        for($n = 0; $n < (size($lista)); $n++)
        {
            for($i = 0; $i < $n; $i ++)
            {
            connectAttr -f ($listNames[$i] + "_ctrl.curlx") ($listNames[$n] +  "_x_ADD.input1D[" + ($i) + "]");
            connectAttr -f ($listNames[$i] + "_ctrl.curly") ($listNames[$n] +  "_y_ADD.input1D[" + ($i) + "]");
            connectAttr -f ($listNames[$i] + "_ctrl.curlz") ($listNames[$n] +  "_z_ADD.input1D[" + ($i) + "]");
           
                                    }
                if($n > 0)
                {
                connectAttr -f ($listNames[$n] + "_x_ADD.output1D") ($listNames[$n]
+ "_ctrl_xtra_LOC.rx");
                connectAttr -f ($listNames[$n] + "_y_ADD.output1D") ($listNames[$n]
+ "_ctrl_xtra_LOC.ry");
                connectAttr -f ($listNames[$n] + "_z_ADD.output1D") ($listNames[$n]
+ "_ctrl_xtra_LOC.rz");
                }
        }


string $wire1;
string $wire2 = ($name + "upv_CRV");;


if(`objExists ($name + "*CRV")`)
{
int $num = size($lista);
//select ($name + "CRV") ($name + "upv_CRV");
$wire1 = ($name + "CRV");

if($dyn == 1)
{
select ($name + "CRV");
string $dynElements[] = `makeCurveDyn`;


addAttr -ln stretch -at double  -min 0 -max 1 -dv 0 ($name +  "root_ctrl");
addAttr -ln dynamic -at double -min 0 -max 1 -dv 1 ($name +  "root_ctrl");
addAttr -ln dyn_stiffness -at double  -min 0 -max 1 -dv 1 ($name +  "root_ctrl");
addAttr -ln dyn_iterations -at double  -min 0 -max 100 -dv 10 ($name +  "root_ctrl");
addAttr -ln dyn_tip_stiffness -at double -min 0 -max 1 -dv 0 ($name +  "root_ctrl");
addAttr -ln dyn_mid_stiffness -at double  -min 0 -max 1 -dv 0 ($name +  "root_ctrl");
addAttr -ln dyn_gravity -at double  -min 0 -max 1 -dv 0.1 ($name +  "root_ctrl");
addAttr -ln dyn_damp -at double  -min 0 -max 100 -dv 80 ($name +  "root_ctrl");


setAttr -e -keyable true ($name + "root_ctrl.dynamic");
setAttr -e -keyable true ($name + "root_ctrl.dyn_iterations");
setAttr -e -keyable true ($name + "root_ctrl.stretch");
setAttr -e -keyable true ($name + "root_ctrl.dyn_gravity");
setAttr -e -keyable true ($name + "root_ctrl.sx");
setAttr -e -keyable true ($name + "root_ctrl.sy");
setAttr -e -keyable true ($name + "root_ctrl.sz");


connectAttr ($name + "root_ctrl.dynamic") ($dynElements[2] + ".blend");

string $shape[] = `listRelatives -typ shape $dynElements[0]`;

connectAttr ($name + "root_ctrl.dyn_stiffness") ($shape[0] +  ".stiffness");
connectAttr ($name + "root_ctrl.dyn_iterations") ($shape[0] +  ".iterations");
connectAttr ($name + "root_ctrl.dyn_mid_stiffness") ($shape[0] +  ".stiffnessScale[1].stiffnessScale_Position");
connectAttr ($name + "root_ctrl.dyn_tip_stiffness") ($shape[0] +  ".stiffnessScale[1].stiffnessScale_FloatValue");
connectAttr ($name + "root_ctrl.dyn_gravity") ($shape[0] + ".gravity");
connectAttr ($name + "root_ctrl.dyn_damp") ($shape[0] + ".damp");
connectAttr ($name + "root_ctrl.stretch") ($shape[0] + ".lengthFlex");


select $dynElements[2] ($name + "upv_CRV");
$wire1 = $dynElements[2];

}
else
{
select ($name + "CRV") ($name + "upv_CRV");
$wire1 = ($name + "CRV");
}

/*
select ($name + "root_ctrl") ($name + "end_ctrl");
$memberCage[0] = `memberCage $name 0.5 1`;
*/


int $jntNum;


if(`gmatch $name "*5*"` == 1)
{
$jntNum = 10;
}
else
{
    if(`gmatch $name "*6*"` == 1)
    {
    $jntNum = 10;
    }
    else
    {
   
        if(`gmatch $name "*7*"` == 1)
        {
        $jntNum = 10;
        }
        else
        {
            if($hires == 1)
            {
            $jntNum = 30;
            }
            else
            {
            $jntNum = 10;
            }
        }
    }

}





////print ("\nthe name is " + $name + "\n");
////print ("\nthe number is " + $jntNum + "\n");


//=== grindylow specific

string $comm;

if(`gmatch $name "*[5-7]*"` == 1)
{
$comm = ("joints_on_path_upv " + $name + " " + $jntNum);
}
else
{
$comm = ("joints_on_path_upv2 " + $name + " " + $jntNum);
}


string $neckLocs[] = eval($comm);

//=== end grindylow specific

//string $neckLocs[] = `joints_on_path_upv $name $jntNum`;
string $listJntNames[] = $neckLocs;





    //=== cages
   
    for($p = 1; $p < $jntNum; $p++)
    {
        if($p == $jntNum)
        {
        string $jointChild[] = `listRelatives -typ joint $neckLocs[$jntNum
-1]`;
        rename $jointChild[0] ($listJntNames[$jntNum -1] + "_JNT");
        select ($listJntNames[$jntNum -1] + "_JNT")  ($listJntNames[$jntNum
-2] + "_JNT");
        pullCage $listJntNames[$jntNum -1] 3 1;
        }
        else
        {
        string $jointCd[] = `listRelatives -typ joint ($neckLocs[$p -1] +  "_jnt_LOC")`;
        rename $jointCd[0] ($listJntNames[$p -1] + "_JNT");
        string $jointCd2[] = `listRelatives -typ joint ($neckLocs[$p] +  "_jnt_LOC")`;
        rename $jointCd2[0] ($listJntNames[$p] + "_JNT");

        select ($listJntNames[$p -1] + "_JNT") ($listJntNames[$p] + "_JNT");
        pullCage $listJntNames[$p -1] 3 1;
        }
    }




    //=== end cages
   
//=== new stretch

if(`objExists ($name + "fin_CRV.stretch")`)
{
connectAttr ($name + "root_ctrl.stretch") ($name + "fin_CRV.stretch");
}

//=== end new stretch

parent ($name + "jnts_GRP") ($name + "upvs_GRP") ($name +  "no_trans_GRP");


//=== scale rig

if(`objExists ($rig_prefix + $rig_name + ".scale_rig")`)
{

select ($name + "*_jnt_LOC");
string $list[] = `ls -sl`;
string $item;
select -cl;
    for($item in $list)
    {
    connectAttr ($rig_prefix + $rig_name + ".scale_rig") ($item + ".sx");
    connectAttr ($rig_prefix + $rig_name + ".scale_rig") ($item + ".sy");
    connectAttr ($rig_prefix + $rig_name + ".scale_rig") ($item + ".sz");

    setAttr -keyable false ($item + ".sx");
    setAttr -keyable false ($item + ".sy");
    setAttr -keyable false ($item + ".sz");
    }
}

//=== end scale rig


string $tmp[];
for($i = 0; $i < size($neckLocs); $i++)
{
$tmp[size($tmp)] = ($neckLocs[$i] + "_jnt_LOC");
}

$neckLocs = $tmp;

return {$wire1, $wire2, $memberCage[0]};


select -cl;
//print "\nTENTACLE RIG DONE\n";
}
else
{
return {$wire1, $wire2, $memberCage[0]};
select -cl;
//print "\nTENTACLE RIG DONE\n";
}

}

}

//=== end rope rig

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

global proc fxSkinSmooth(int $times)
{
    string $trans[] = `ls -sl`;
    string $skinC = `findRelatedSkinCluster $trans[0]`;
    string $joints[] = `skinCluster -q -influence $skinC`;

    for ($x=0;$x<$times;$x++)
    {
        for ($joint in $joints){
            setSmoothSkinInfluence $joint;
            artAttrCtx -e -clear `currentCtx`;
            }
    }

}


//===============================================================
//===============================================================
//===============================================================


global proc string[] averageParentConstraint()
{

string $list[] = `ls -sl`;
$quantity = `size($list)`;
$end = $quantity - 1;
$half = $quantity / 2;
int $i;
string $item;

string $cons[];

if($quantity < 4)
{
    for( $i = 1; $i < $end; $i++ )
        {
            $item = $list[$i];
            select $list[0] $list[$end] $item;
            parentConstraint -mo -name ($item + "_PAC");
            $cons[size($cons)] = ($item + "_PAC");
        }

}
else
{

    for( $i = 1; $i < $end; $i++ )
        {
            $item = $list[$i];
            select $list[0] $list[$end] $item;
            parentConstraint -mo -name ($item + "_PAC");
            $cons[size($cons)] = ($item + "_PAC");
            float $first = ((1.00 / $end) * $i);
            setAttr ($item + "_PAC." + $list[0] + "W0") (1 - $first);
            setAttr ($item + "_PAC." + $list[$end] + "W1") $first;

        }

}


select -cl;
return $cons;

}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//=== usage: select any number of joints and any number of points: every point will be assigned the skin cluster's value for each joint
//=== wrote it just to clean up selection of points from a series of joints without the usual maya "booolsheet" compensations


global proc skinValue(float $value)
{
string $joints[] = `ls -sl -type joint -type transform`;
string $points[] = `ls -sl -type float3 -fl`;

if(size($joints)==0)
{
//print "SELECT AT LEAST A JOINT AND A VERTEX";
}
else
{

    if(size($points)==0)
    {
    //print "SELECT AT LEAST A JOINT AND A VERTEX";
    }
    else
    {

    string $buff[];
    tokenize $points[0] "." $buff;
    string $skinCluster = findRelatedSkinCluster($buff[0]);

        for($item in $joints)
        {   
        skinPercent -tv $item $value $skinCluster $points;
        }
    }
}

}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


//=== usage: select two nodes and:

global proc string distance_DST(string $name)
{

string $newName;
int $num = (`size($name)`-1);
if(`gmatch $name "*_"`)
{
$newName = `substring $name 1 $num`;
$name = $newName;
}

string $list[] = `ls -sl`;
string $dst = `distanceDimension  -sp 0 10000000 0 -ep 0 100000000 0`;

rename $dst ($name+"_shape_DST");
string $parent[] = `listRelatives -ap ($name+"_shape_DST")`;
rename $parent[0] ($name+"_DST");

string $loc1[] = `listConnections ($name+"_DST.startPoint")`;
string $loc2[] = `listConnections ($name+"_DST.endPoint")`;

parent $loc1[0] $list[0];
parent $loc2[0] $list[1];

setAttr ($loc1[0]+".t") 0 0 0;
setAttr ($loc2[0]+".t") 0 0 0;

parent ($name+"_DST") $list[0];

rename $loc1[0] ($name+"_dist_root_LOC");
rename $loc2[0] ($name+"_dist_end_LOC");

select $list;
return ($name+"_shape_DST");

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

global proc reverseAim(string $aimCon[])
{

string $upv[];
string $aim[];

float $aimAxes[];
float $upvAxes[];


for($i=0;$i<size($aimCon);$i++)
{

//=== find nodes and axes

$upv = `listConnections ($aimCon[$i]+".worldUpMatrix")`;
$aim = `listConnections ($aimCon[$i]+".target[0].targetParentMatrix")`;
$aimAxes = `getAttr ($aimCon[$i]+".aimVector")`;
$upvAxes = `getAttr ($aimCon[$i]+".upVector")`;

//=== loop


//=== connect old upv as new aim

connectAttr -f ($upv[0]+".t") ($aimCon[$i]+".target[0].targetTranslate");
connectAttr -f ($upv[0]+".rotatePivot") ($aimCon[$i]+".target[0].targetRotatePivot");
connectAttr -f ($upv[0]+".rotatePivotTranslate") ($aimCon[$i]+".target[0].targetRotateTranslate");
connectAttr -f ($upv[0]+".parentMatrix") ($aimCon[$i]+".target[0].targetParentMatrix");

//=== connect old AIM as new UPV

connectAttr -f ($aim[0]+".worldMatrix") ($aimCon[$i]+".worldUpMatrix");

//=== invert axes

setAttr ($aimCon[$i]+".aimVector") $upvAxes[0] $upvAxes[1] $upvAxes[2];
setAttr ($aimCon[$i]+".upVector") $aimAxes[0] $aimAxes[1] $aimAxes[2];

}



//==== end
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

global proc string[] getPose2(string $attr )
{
string $lista[];
string $list[] = `ls -sl`;
string $item;
string $print[];
int $nb = size($print);

    for($item in $list)
    {
   
    if(size($attr) == 0)
    {
    $lista = `listAttr -v -k -u -s $item`;
    }
    else
    {   
        if(`gmatch $attr "r"`)
        {
        $lista = {"rx", "ry", "rz"};
        }
    }
   
    string $type[];
       
//=== check if fcEnv node

        if(size($type) > 0)
        {
        $lista[size($lista)] = "excfl";
       
            if(`getAttr ($item + ".weightMult")` == 0)
            {
            string $par[] = `listRelatives -p $item`;
            string $line = (" catchQuiet(`setAttr " + $par[0] + ".v 0`);");
            $print[$nb++] = $line;
            }
        }

        string $itema;
       
        string $wrd[] = `ls -type wire $item`;   
       
        if(size($wrd) > 0)
        {
            $lista = {
            "envelope",
            "crossingEffect",
            "tension",
            "localInfluence",
            "rotation",
            "dropoffDistance[0]",
            "scale[0]"
            };   
        }
       
       
        for($itema in $lista)
        {
       
            if(`gmatch $itema "excfl"` == 1)
            {
            int $p[] = `getAttr ($item + "." + $itema)`;
            string $value = `fxArrayToString $p`;
            $num = size($p);
                       
            string $line = (" catchQuiet(`setAttr -typ Int32Array " + $item + "." + $itema + " " + $num + " " + $value + "`);");
            $print[$nb++] = $line;
            }
            else
            {
                if(`gmatch $itema "*visibility"` == 1)
                {
                }
                else
                {
                float $pip = `getAttr ($item + "." + $itema)`;
                string $line = (" catchQuiet(`setAttr " + $item + "." + $itema + " " + $pip + "`);");
                $print[$nb++] = $line;
                }
            }
        }
    }

return $print;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


global proc mySculpt(string $name, string $parent)
{
string $list[] = `ls -sl`;
string $geo = $list[0];
string $patate[] = `sculpt -mode flip -insideMode even -maxDisplacement 0.2 -dropoffType linear -dropoffDistance 0.1 -groupWithLocator 1 -objectCentered 0 $geo`;

string $grp[] = `listRelatives -ap $patate[1]`;

rename $grp[0] ($name+"_sculpt_GRP");
rename $patate[0] ($name+"_sculpt");
rename $patate[1] ($name+"_sculptor");
rename $patate[2] ($name+"_sculptOrigin");

if(`size($parent)`>0)
{
parent ($name+"_sculpt_GRP") $parent;
zeroT ($name+"_sculpt_GRP");
}


}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

global proc string printCon(string $node)
{

    string $command;

    string $POC[];
    string $PAC[];
    string $ORC[];
    string $SCC[];
   
    if(`objExists ($node+".tx")`)
    $POC = `listConnections -type pointConstraint ($node+".tx")`;
    if(`objExists ($node+".tx")`)
    $PAC = `listConnections -type parentConstraint ($node+".tx")`;
    if(`objExists ($node+".rx")`)
    $ORC = `listConnections -type orientConstraint ($node+".rx")`;
    if(`objExists ($node+".sx")`)
    $SCC = `listConnections -type scaleConstraint ($node+".sx")`;
   
    string $constraint;
    int $offset = 0;
    float $offsetValue[];
   
    string $CONS1[] = stringArrayCatenate($POC, $PAC);
    string $CONS2[] = stringArrayCatenate($ORC, $SCC);
    string $allCons[] = stringArrayCatenate($CONS1, $CONS2);
    float $weightValue;
    string $trans;
   
   
    for($con in $allCons)
    {
   
    $command += ("\nselect ");
    string $typeOfConstraint[] = `ls -st $con`;
    $constraint = $typeOfConstraint[1];
   
    if(`gmatch $constraint "scaleConstraint"`)
    $trans = "Scale";
    if(`gmatch $constraint "pointConstraint"`)
    $trans = "RotateTranslate";
    if(`gmatch $constraint "orientConstraint"`)
    $trans = "Rotate";
    if(`gmatch $constraint "parentConstraint"`)
    $trans = "Rotate";
   
       
        if(`getAttr ($con+".offsetX")`!=0)
        $offset = 1;
        if(`getAttr ($con+".offsetY")`!=0)
        $offset = 1;
        if(`getAttr ($con+".offsetZ")`!=0)
        $offset = 1;
   
    $offsetValue = `getAttr ($con+".offset")`;
    string $targets[] = `listConnections -type transform ($con+".target["+"*"+"].target"+$trans)`;
   
        for($item in $targets)
        {
        $command += ($item+" ");
        }
       
    $command += ($node+";\n"+$constraint);
   
        if($offset >0)
        {
        $command += (" -mo;\nsetAttr "+$con+".offset "+ $offsetValue[0]+" "+$offsetValue[1]+" "+$offsetValue[2]);
        }

    $command += (";\n");
   
   
    //=== weights
   
    string $attrs[] = `listAttr -ud $con`;
   
    for($at in $attrs)
    {
    $weightValue = `getAttr ($con+"."+$at)`;
    $command += ("setAttr "+$con+"."+$at+" "+$weightValue+" ;\n");
    }
   
   
    }

return $command;

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
/*
global proc string[] fxGetPose(int $mirror)
{
string $parent[];
select -d `ls -type skinCluster -sl`;
select -d `ls -type groupId -sl`;
select -d `ls -type groupParts -sl`;

string $list[] = `ls -sl`;

string $item;
string $print[];
int $nb = size($print);
string $firstLine;
string $preLine;
string $type[];
string $line;
string $itema;

float $neg = 1;
if($mirror == 1)
$neg = "-1";

    for($item in $list)
    {
    string $lista[] = `listAttr -c -v -k -u -s $item`;
    string $shapeNode[] = `listRelatives -c -s $item`;
    string $shapeType[] = `ls -st $shapeNode[0]`;
   
    int $clusterAwarenessProgram = 0;
   
        if(`gmatch $shapeType[1] "clusterHandle"`)
        {
        $clusterAwarenessProgram = 1;
        }
   
    string $noSculpt[] = `ls -st $item`;
   
   
        if(!`gmatch $noSculpt[1] "sculpt"`)
        {
        $parent = `listRelatives -ap $item`;
        $preLine = ("string $papa[] = `listRelatives -ap "+$item+"`;\nif(!`gmatch $papa[0] \""+$parent[0]+"\"`)\n");
        $firstLine = $preLine;
        $firstLine += ("parent " + $item + " " + $parent[0] + ";");
       
            if(size($parent)==0)
            {
            $preLine = ("string $papa[] = `listRelatives -ap "+$item+"`;\nif(size($papa))\n");
            $firstLine = $preLine;
            $firstLine += ("parent -w " + $item + ";");
            }
        }
   
        if(`gmatch $noSculpt[1] "motionPath"`)
        $lista = {"fractionMode", "uValue"};
       
        if(`gmatch $noSculpt[1] "wmMuscle"`)
        {
        $lista = {"topTiltMode", "botTiltMode", "baseInterp", "normInterp", "guideInterp", "guideOffset"};
        }

        if(`objExists ($item+".msl")`)
        {
        clear $lista;
        string $allAttrs[] = `listAttr -ud $item`;
       
            for($a in $allAttrs)
                if(`gmatch $a "*MSL"`)
                $lista[size($lista)] = $a;
       
        }
       
    if(`gmatch $item "*Shape*"`)
    {
    }
    else
    {
    $print[$nb++] = $firstLine;
    }
   
    $type = `ls -st $item`;

    if(`gmatch $type[1] "wmSmooth"`)
    $lista[size($lista)] = "smoothMode";

    if(`gmatch $type[1] "wmBulge"`)
    $lista[size($lista)] = "bulgeMode";

    if($type[1] == "compound")
    {
    $lista = `listAttr $item`;
   
        for($itema in $lista)
        {
        //print "\n";
        string $pluto[];
        tokenize($item,".", $pluto);
        string $node = $pluto[0];
       
            if(`gmatch $itema "*X"`||`gmatch $itema "*Y"`||`gmatch $itema "*Z"`||$clusterAwarenessProgram==1)
            {
            $pip = `getAttr ($node + "." + $itema)`;
            $preLine = ("string $con[] = `listConnections -s 1 -d 0 "+$node + "." + $itema+ "`;\nif(!size($con))\nif(!`getAttr -lock "+$node + "." + $itema+"`)\n");
           
            $line = $preLine;
            $line += ("setAttr " + $node + "." + $itema + " " + $pip + ";");
            //print (" catchQuiet(`setAttr " + $node + "." + $itema + " " + $pip + "`);");
            $print[$nb++] = $line;
            }
        //print "\n";
        }
    }
       
        if($clusterAwarenessProgram==1)
        {
        //=== trans
        string $command = ("xform -q -a -ws -t "+$item);
        float $patate[] = eval($command);
        $line = (" catchQuiet(`xform -a -ws -t " + $patate[0] + " " + ($patate[1]*$neg) + " " +$patate[2] + " " + $item + "`);");
        $print[$nb++] = $line;
        //===
        //=== rot
        string $command = ("xform -q -a -ro "+$item);
        float $patate[] = eval($command);
        $line = (" catchQuiet(`xform -ro " + $patate[0] + " " + ($patate[1]*$neg) + " " +($patate[2]*$neg) + " " + $item + "`);");
        $print[$nb++] = $line;
        //===
        //=== trans
        string $command = ("xform -q -r -s "+$item);
        float $patate[] = eval($command);
        $line = (" catchQuiet(`xform -r -s " + $patate[0] + " " + $patate[1] + " " +$patate[2] + " " + $item + "`);");
        $print[$nb++] = $line;
        //===
        }
        else
        {
            for($itema in $lista)
            {
                if(`gmatch $itema "*visibility"`||`gmatch $itema "*.*"`||`gmatch $itema "*[*"`||`gmatch $itema "weight"`)
                {
                }
                else
                {
                    if(`gmatch $itema "trans*"`)
                    {
                    float $trans[] = `xform -q -a -ws -t $item`;
                    $preLine = ("string $con[] = `listConnections -s 1 -d 0 "+$item + "." + $itema+ "`;\nif(!size($con))\nif(!`getAttr -lock "+$item + "." + $itema+"`)\n");
                    $line = $preLine;
                    $line += ("xform -a -ws -t "+($trans[0]*$neg)+" "+$trans[1]+" "+$trans[2]+" "+$item+";");
                    }
                    else
                    {
                        if(`gmatch $itema "*rotat*"`)
                        {
                        float $rot[] = `xform -q -ro $item`;
                        $preLine = ("string $con[] = `listConnections -s 1 -d 0 "+$item + "." + $itema+ "`;\nif(!size($con))\nif(!`getAttr -lock "+$item + "." + $itema+"`)\n");
                        $line = $preLine;
                        $line += ("xform -ro "+$rot[0]+" "+($rot[1]*$neg)+" "+($rot[2]*$neg)+" "+$item+";");
                        }
                        else
                        {
                        $pip = `getAttr ($item + "." + $itema)`;
                        $preLine = ("string $con[] = `listConnections -s 1 -d 0 "+$item + "." + $itema+ "`;\nif(!size($con))\nif(!`getAttr -lock "+$item + "." + $itema+"`)\n");
                        $line = $preLine;
                        $line += ("setAttr " + $item + "." + $itema + " " + $pip + ";");
                        }
                    }
                $print[$nb++] = $line;
                }
            }
        }
    }
//print $print;
return $print;
}

*/

global proc string[] fxGetPose(int $mirror)
{
string $parent[];
select -d `ls -type skinCluster -sl`;
select -d `ls -type groupId -sl`;
select -d `ls -type groupParts -sl`;

string $list[] = `ls -sl`;

string $item;
string $print[];
int $nb = size($print);
string $firstLine;
string $preLine;
string $type[];
string $line;
string $attribute;

float $neg = 1;
if($mirror == 1)
$neg = "-1";

    for($item in $list)
    {
    string $lista[] = `listAttr -c -v -k -u -s $item`;
    string $shapeNode[] = `listRelatives -c -s $item`;
    string $shapeType[] = `ls -st $shapeNode[0]`;
   
    int $clusterAwarenessProgram = 0;
   
        if(`gmatch $shapeType[1] "clusterHandle"`)
        {
        $clusterAwarenessProgram = 1;
        }
   
    string $noSculpt[] = `ls -st $item`;
   
   
        if(!`gmatch $noSculpt[1] "sculpt"`)
        {
        $parent = `listRelatives -ap $item`;
        $preLine = ("string $papa[] = `listRelatives -ap "+$item+"`;\nif(!`gmatch $papa[0] \""+$parent[0]+"\"`)\n");
        $firstLine = $preLine;
        $firstLine += ("parent " + $item + " " + $parent[0] + ";");
       
            if(size($parent)==0)
            {
            $preLine = ("string $papa[] = `listRelatives -ap "+$item+"`;\nif(size($papa))\n");
            $firstLine = $preLine;
            $firstLine += ("parent -w " + $item + ";");
            }
        }
   
        if(`gmatch $noSculpt[1] "motionPath"`)
        $lista = {"fractionMode", "uValue"};
       
        if(`gmatch $noSculpt[1] "wmMuscle"`)
        {
        $lista = {"topTiltMode", "botTiltMode", "baseInterp", "normInterp", "guideInterp", "guideOffset"};
        }

        if(`objExists ($item+".msl")`)
        {
        clear $lista;
        string $allAttrs[] = `listAttr -ud $item`;
       
            for($a in $allAttrs)
                if(`gmatch $a "*MSL"`)
                $lista[size($lista)] = $a;
       
        }
       
    if(`gmatch $item "*Shape*"`)
    {
    }
    else
    {
    $print[$nb++] = $firstLine;
    }
   
    $type = `ls -st $item`;

    if(`gmatch $type[1] "wmSmooth"`)
    $lista[size($lista)] = "smoothMode";

    if(`gmatch $type[1] "wmBulge"`)
    $lista[size($lista)] = "bulgeMode";

    if($type[1] == "compound")
    {
    $lista = `listAttr $item`;
    //print ("\n"+$item+" has compounds\n");
        for($attribute in $lista)
        {
        //print "\n";
        string $pluto[];
        tokenize($item,".", $pluto);
        string $compoundNode = $pluto[0];

            if(`gmatch $compoundNode "*MSLShape*"`)
            {
            string $tokens[];
            tokenize($item,".", $tokens);
            $item = $tokens[0];
                   
            string $transform[] = {
            "translateX",
            "translateY",
            "translateZ",
            "rotateX",
            "rotateY",
            "rotateZ",
            "scaleX",
            "scaleY",
            "scaleZ"
            };
                   
            string $flip[] = {
            "rotateX"
            };
                       
                for($at in $transform)
                {
                    if(`gmatch $attribute ("*"+$at)`)
                    {
                        for($f in $flip)
                        {
                            if(`gmatch $at  ("*"+$f)`)
                            {
                            print ("\nMIRRORING : "+$item+"."+$attribute);
                            $pip = `getAttr ($item+"." + $attribute)`;
                            $preLine = ("string $con[] = `listConnections -s 1 -d 0 "+$item + "." + $attribute+ "`;\nif(!size($con))\nif(!`getAttr -lock "+$item + "." + $attribute+"`)\n");
                            $line = $preLine;
                            float $value = ($pip*$neg);
                            //print ("\nvalue is now: "+$value);
                            $line += ("setAttr " + $item + "." + $attribute + " " + $value + ";");
                            }   
                            else
                            {
                            $pip = `getAttr ($item+"." + $attribute)`;
                            $preLine = ("string $con[] = `listConnections -s 1 -d 0 "+$item + "." + $attribute+ "`;\nif(!size($con))\nif(!`getAttr -lock "+$item + "." + $attribute+"`)\n");
                            $line = $preLine;
                            float $value = ($pip*$neg);
                            //print ("\nvalue is now: "+$value);
                            $line += ("setAttr " + $item + "." + $attribute + " " + $pip + ";");
                            }
                        }
                    }
                }
            }
            else
            {
           
                if(!`gmatch $compoundNode "*MSL*"`)
                {
                    if(`gmatch $attribute "*X"`||`gmatch $attribute "*Y"`||`gmatch $attribute "*Z"`||$clusterAwarenessProgram==1)
                    {
                    $pip = `getAttr ($item + "." + $attribute)`;
                    $preLine = ("string $con[] = `listConnections -s 1 -d 0 "+$item + "." + $attribute+ "`;\nif(!size($con))\nif(!`getAttr -lock "+$item + "." + $attribute+"`)\n");
           
                    $line = $preLine;
                    $line += ("setAttr " + $item + "." + $attribute + " " + $pip + ";");
                    //print (" catchQuiet(`setAttr " + $item + "." + $attribute + " " + $pip + "`);");
                    }
                }
            }
        $print[$nb++] = $line;
        //print "\n";
        }
    }

//======
//print ("\nnode is: "+$item +" and the attributes I'm storing are:\n");
//print $lista;
//print ("\n");

        if($clusterAwarenessProgram==1)
        {
        print ("\n"+$item+" appears to be a cluster\n");
            //=== trans
            string $command = ("xform -q -a -ws -t "+$item);
            float $patate[] = eval($command);
            $line = (" catchQuiet(`xform -a -ws -t " + $patate[0] + " " + ($patate[1]*$neg) + " " +$patate[2] + " " + $item + "`);");
            $print[$nb++] = $line;
            //===
            //=== rot
            string $command = ("xform -q -a -ro "+$item);
            float $patate[] = eval($command);
            $line = (" catchQuiet(`xform -ro " + $patate[0] + " " + ($patate[1]*$neg) + " " +($patate[2]*$neg) + " " + $item + "`);");
            $print[$nb++] = $line;
            //===
            //=== trans
            string $command = ("xform -q -r -s "+$item);
            float $patate[] = eval($command);
            $line = (" catchQuiet(`xform -r -s " + $patate[0] + " " + $patate[1] + " " +$patate[2] + " " + $item + "`);");
            $print[$nb++] = $line;
            //===
        }
        else
        {
        //print ("\n"+$item+" appears NOT to be a cluster\n");
            for($attribute in $lista)
            {
                if(`gmatch $attribute "*visibility"`||`gmatch $attribute "*.*"`||`gmatch $attribute "*[*"`||`gmatch $attribute "weight"`)
                {
                //print ("\nnot saving visibility for "+$item+"\n");
                }
                else
                {
                    if(`gmatch $item "*MSLShape.state[0]*"`)
                    {
                    }
                    else
                    {
                        if(`gmatch $attribute "trans*"`)
                        {
                        float $trans[] = `xform -q -a -ws -t $item`;
                        $preLine = ("string $con[] = `listConnections -s 1 -d 0 "+$item + "." + $attribute+ "`;\nif(!size($con))\nif(!`getAttr -lock "+$item + "." + $attribute+"`)\n");
                        $line = $preLine;
                        $line += ("xform -a -ws -t "+($trans[0]*$neg)+" "+$trans[1]+" "+$trans[2]+" "+$item+";");
                        }
                        else
                        {
                            if(`gmatch $attribute "*rotat*"`)
                            {
                            float $rot[] = `xform -q -ro $item`;
                            $preLine = ("string $con[] = `listConnections -s 1 -d 0 "+$item + "." + $attribute+ "`;\nif(!size($con))\nif(!`getAttr -lock "+$item + "." + $attribute+"`)\n");
                            $line = $preLine;
                            $line += ("xform -ro "+$rot[0]+" "+($rot[1]*$neg)+" "+($rot[2]*$neg)+" "+$item+";");
                            }
                            else
                            {
                            $pip = `getAttr ($item + "." + $attribute)`;
                            $preLine = ("string $con[] = `listConnections -s 1 -d 0 "+$item + "." + $attribute+ "`;\nif(!size($con))\nif(!`getAttr -lock "+$item + "." + $attribute+"`)\n");
                            $line = $preLine;
                            $line += ("setAttr " + $item + "." + $attribute + " " + $pip + ";");
                            }
                        }
                    }
                $print[$nb++] = $line;
                }
            }
        }
    }
//print $print;
return $print;
}


//===========================================================================================
//===========================================================================================
//===========================================================================================
//===========================================================================================


global proc string exportPose(string $fileName, int $mirror)
{
string $sel[] = `ls -sl`;


    string $pose[];
    string $return;
    string $stringAttr;
    $fileId = `fopen $fileName "w"`;
   
    $pose = `fxGetPose $mirror`;
   
    for($item in $sel)
    $pose[size($pose)] =  `printCon $item`;
   
    for($i = 0; $i < size($pose);$i++)
    {
    fprint $fileId ($pose[$i] + "\n");
    $return+=($pose[$i] + "\n");
    }
   
    fclose $fileId;

return $return;

}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//=== save all types of nodes based on suffix

global proc saveAll(string $suff, string $path)
{

if(size($path)==0)
$path = "/usr/tmp/";

string $list[] = `ls -sl`;
string $msl_groups_list[];

for($item in $list)
{
    if(`gmatch $item ("*"+$suff)`)
    $msl_groups_list[size($msl_groups_list)] = $item;
}

int $num = size($suff)+1;
string $names[];


for($item in $msl_groups_list)
{
$names[size($names)] = substring($item, 1, (size($item)-$num));
}

for($item in $names)
{
select `ls ($item+"*")`; select -d `ls -type double3 -sl`;
exportPose ($path+$item) 0;
}

print "saveAll DONE";

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

global proc frameAnim()
{
string $list[] = `ls -sl`;
string $node = $list[0];
string $curves[] = `listConnections -type animCurve $node`;

int $start = 0;
int $end = 0;

for($i=0;$i<size($curves);$i++)
{
string $comm = ("getAttr "+ $curves[$i]+".keyTimeValue[0]");
float $thisStart[] = eval($comm);
if($thisStart[0] < $start)
$start = $thisStart[0];

string $comm = ("getAttr "+ $curves[$i]+".keyTimeValue[\"*\"]");
float $allEnds[] = eval($comm);
float $thisEnd = $allEnds[size($allEnds)-2];
if($thisEnd > $end)
$end = $thisEnd;

}


playbackOptions -e -min $start -max $end;

}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


global proc renameJoints(string $name)
{
string $tmp[] = `ls -sl`;
string $list[];
string $baseName;

    if(size($tmp)<2)
    {
    select -hi `ls -sl`;
    $list = `ls -sl`;
    }
    else
    {
    $list = `ls -sl`;
    }

for($i=0;$i<size($list);$i++)
{
$baseName = ($name+"_"+($i)+"_JNT");

if($i==0)
$baseName = ($name+"_root_JNT");

if($i==(size($list)-1))
$baseName = ($name+"_end_JNT");

rename $list[$i] $baseName;

}


}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

global proc string skinMuscle(string $name, string $links[])
{

int $num = size($links);
int $sections;

string $start = "";
string $mid = "";
string $end = "";

float $startTrans[] = {0, 0, 0};
float $midTrans[] = {0, 0, 0};
float $endTrans[] = {0, 0, 0};
string $circlesGRPS[];
string $circles[];
string $joints[];

if($num==0)
{
print "USAGE: skinMuscle NameOfMuscle ListOfAttachments";

return 0;
}
else
{

    if($num>3)
    {
    print "max 3 attachments!!";
    return 0;
    }
    else
   
        if($num==3)
        {
        $sections = 5;
        $start = $links[0];
        $mid = $links[1];
        $end = $links[2];
        }
       
        if($num==2)
        {
        $sections = 3;
        $start = $links[0];
        $end = $links[1];
        }

        if($num==1)
        {
        $sections = 0;
        }

//================================= make muscle ===============================//
//================================= make muscle ===============================//
//================================= make muscle ===============================//

//==== if only one transform selected, make a sphere and fuck it

        if($sections == 0)
        {
        sphere -name ($name+"_MSL") -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 8 -nsp 4 -ch 0;
        parent ($name+"_MSL") $start;
        }
        else
        {

//=============================== LOOP ===============================//
//=============================== LOOP ===============================//
//=============================== LOOP ===============================//

            for($s=1;$s<($sections+1);$s++)
            {
            circle -name ($name+"_"+$s+"_msl_CRV") -c 0 0 0 -nr 1 0 0 -sw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 8 -ch 0;
            group -em -name ($name+"_"+$s+"_msl_rest_REF");
            group -em -name ($name+"_"+$s+"_msl_flex_REF");
            group -em -name ($name+"_"+$s+"_msl_crv_GRP");
           
            select -cl;
            joint -name ($name+"_"+$s+"_msl_JNT");
            $joints[size($joints)] = ($name+"_"+$s+"_msl_JNT");
            parent ($name+"_"+$s+"_msl_JNT") ($name+"_"+$s+"_msl_CRV");
            setAttr ($name+"_"+$s+"_msl_JNT.v") 0;
            setAttr -l 1 -k 0 ($name+"_"+$s+"_msl_JNT.v");
           
            setAttr ($name+"_"+$s+"_msl_rest_REF.v") 0;
            setAttr -l 1 -k 0 ($name+"_"+$s+"_msl_rest_REF.v");
           
           
            setAttr ($name+"_"+$s+"_msl_crv_GRP.displayHandle") 1;
            setAttr ($name+"_"+$s+"_msl_crv_GRP.selectHandleY") 2;
            setAttr ($name+"_"+$s+"_msl_crv_GRP.overrideEnabled") 1;
            setAttr ($name+"_"+$s+"_msl_crv_GRP.overrideColor") 14;
           
            setAttr ($name+"_"+$s+"_msl_rest_REF.displayHandle") 0;
            setAttr -l 1 ($name+"_"+$s+"_msl_rest_REF.displayHandle");
           
            setAttr ($name+"_"+$s+"_msl_rest_REF.selectHandleZ") -2;
            setAttr ($name+"_"+$s+"_msl_rest_REF.overrideEnabled") 1;
            setAttr ($name+"_"+$s+"_msl_rest_REF.overrideColor") 20;
           
           
            setAttr ($name+"_"+$s+"_msl_flex_REF.displayHandle") 1;
            setAttr ($name+"_"+$s+"_msl_flex_REF.selectHandleZ") 2;
            setAttr ($name+"_"+$s+"_msl_flex_REF.overrideEnabled") 1;
            setAttr ($name+"_"+$s+"_msl_flex_REF.overrideColor") 13;
           
           
            //parent ($name+"_"+$s+"_msl_CRV") ($name+"_"+$s+"_msl_rest_REF") ($name+"_"+$s+"_msl_flex_REF") ($name+"_"+$s+"_msl_crv_GRP");
            parent ($name+"_"+$s+"_msl_rest_REF") ($name+"_"+$s+"_msl_flex_REF") ($name+"_"+$s+"_msl_crv_GRP");
                       
            //=== flex state
           
            addAttr -ln "flex" -k 1 -minValue 0 -maxValue 1 -defaultValue 0 ($name+"_"+$s+"_msl_crv_GRP");
           
            select ($name+"_"+$s+"_msl_rest_REF") ($name+"_"+$s+"_msl_flex_REF") ($name+"_"+$s+"_msl_CRV");
            orientConstraint -name ($name+"_"+$s+"_msl_state_ORC");
            pointConstraint -name ($name+"_"+$s+"_msl_state_POC");
            scaleConstraint -name ($name+"_"+$s+"_msl_state_SCC");
           
            connectAttr ($name+"_"+$s+"_msl_crv_GRP.flex") ($name+"_"+$s+"_msl_state_ORC."+$name+"_"+$s+"_msl_flex_REFW1");
            connectAttr ($name+"_"+$s+"_msl_crv_GRP.flex") ($name+"_"+$s+"_msl_state_POC."+$name+"_"+$s+"_msl_flex_REFW1");
            connectAttr ($name+"_"+$s+"_msl_crv_GRP.flex") ($name+"_"+$s+"_msl_state_SCC."+$name+"_"+$s+"_msl_flex_REFW1");
            invConnect  ($name+"_"+$s+"_msl_state_ORC."+$name+"_"+$s+"_msl_flex_REFW1") ($name+"_"+$s+"_msl_state_ORC."+$name+"_"+$s+"_msl_rest_REFW0");
            invConnect  ($name+"_"+$s+"_msl_state_ORC."+$name+"_"+$s+"_msl_flex_REFW1") ($name+"_"+$s+"_msl_state_POC."+$name+"_"+$s+"_msl_rest_REFW0");
            invConnect  ($name+"_"+$s+"_msl_state_ORC."+$name+"_"+$s+"_msl_flex_REFW1") ($name+"_"+$s+"_msl_state_SCC."+$name+"_"+$s+"_msl_rest_REFW0");
           
            $circlesGRPS[size($circlesGRPS)] = ($name+"_"+$s+"_msl_crv_GRP");
            $circles[size($circles)] = ($name+"_"+$s+"_msl_CRV");
            }

        loft -name ($name+"_loft_NRB") -ch 1 -u 1 -c 0 -ar 1 -d 3 -ss 3 -rn 0 -po 0 -rsn true $circles;
        duplicate -name ($name+"_MSL") ($name+"_loft_NRB");
        connectAttr -f ($name+"_loft_NRBShape.worldSpace[0]") ($name+"_MSL.create");
        setAttr ($name+"_loft_NRB.v") 0;
        setAttr -l 1 ($name+"_loft_NRB.v");
   
       
        setAttr ($name+"_MSL.overrideEnabled") 1;
        setAttr ($name+"_MSL.overrideColor") 13;
        setAttr ($name+"_MSL.overrideShading") 0;
       
       
       
        group -em -name ($name+"_msl_GRP");
       
        for($i=0;$i<size($links);$i++)
        {
        addAttr -ln ("att_"+($i+1)) -dt "string" -k 1 ($name+"_msl_GRP");
        setAttr -type "string" -k 1 ($name+"_msl_GRP.att_"+($i+1)) $links[$i];
        }
       
        select $start ($name+"_msl_GRP"); delete `parentConstraint`;
        makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 ($name+"_msl_GRP");
        select ($name+"_MSL") ($name+"_loft_NRB");
        group -name ($name+"_msl_notrans_GRP");
        parent $circlesGRPS ($name+"_msl_notrans_GRP") ($name+"_msl_GRP");

        parent $circlesGRPS ($name+"*_msl_CRV") $start;
        zeroT $circlesGRPS[0];
        select $end $circlesGRPS[size($circlesGRPS)-1]; delete `parentConstraint`;

            if($num==3)
            {
            select $mid $circlesGRPS[2]; delete `parentConstraint`;
            select $circlesGRPS[0] $circlesGRPS[2] $circlesGRPS[1]; delete `pointConstraint`; delete `orientConstraint`;
            select $circlesGRPS[2] $circlesGRPS[4] $circlesGRPS[3]; delete `pointConstraint`; delete `orientConstraint`;
            }

            if($num==2)
            {
            select $circlesGRPS[0] $circlesGRPS[2] $circlesGRPS[1]; delete `pointConstraint`; delete `orientConstraint`;
            }

        sets -name ($name+"_msl_SEL") `ls ($name+"_msl_GRP") $circlesGRPS ($name+"_*_msl_rest_REF") ($name+"_*_msl_flex_REF") `;
        }


    setAttr -l 1 -k 0 ($name+"_msl_GRP.tx");
    setAttr -l 1 -k 0 ($name+"_msl_GRP.ty");
    setAttr -l 1 -k 0 ($name+"_msl_GRP.tz");
    setAttr -l 1 -k 0 ($name+"_msl_GRP.rx");
    setAttr -l 1 -k 0 ($name+"_msl_GRP.ry");
    setAttr -l 1 -k 0 ($name+"_msl_GRP.rz");
    setAttr -l 1 -k 0 ($name+"_msl_GRP.sx");
    setAttr -l 1 -k 0 ($name+"_msl_GRP.sy");
    setAttr -l 1 -k 0 ($name+"_msl_GRP.sz");
   
    addAttr -ln flex -k 1 -minValue 0 -maxValue 1 -defaultValue 0 ($name+"_msl_GRP");
   
    for($i in `ls ($name+"_*_msl_crv_GRP.flex") ($name+"_*_msl_flex_REF.displayHandle")`)
    {
     catchQuiet(`connectAttr -f ($name+"_msl_GRP.flex") $i`);
    }
   
    for($i in `ls ($name+"_*_msl_crv_GRP.displayHandle")`)
    {
    invConnect ($name+"_msl_GRP.flex") $i;
    }

    select `ls -type transform ($name+"*")`; select -d ($name+"_msl_GRP") ($name+"*_JNT") ($name+"*_rest_REF");
   
    for($item in `ls -sl`)
    {
     catchQuiet(`connectAttr ($name+"_msl_GRP.v") ($item+".v")`);
     catchQuiet(`connectAttr ($name+"_msl_GRP.overrideVisibility") ($item+".overrideVisibility")`);
     catchQuiet(`connectAttr ($name+"_msl_GRP.overrideEnabled") ($item+".overrideEnabled")`);
    print "";
    }
   

//=================== END

    float $X[];
    float $Y[];
    float $Z[];
    string $makeCurve;
   
   
    if(size($circlesGRPS)<4)
    {
    $makeCurve = ("curve -name "+$name+"_curva_TEMP -d 2 -p 0 0 0 ");
    }
    else
    {
    $makeCurve = ("curve -name "+$name+"_curva_TEMP -d 2 ");
    }
   
   
    for($n=0;$n<size($circlesGRPS);$n++)
    {
    float $TMP[] = `xform -q -ws -t $circlesGRPS[$n]`;
    $makeCurve+= ("-p "+$TMP[0]+" "+$TMP[1]+" "+$TMP[2]);
    }

    eval($makeCurve);
   
    string $stuff[] = {($name+"_curva_TEMP")};

    $stuff = {($name+"_planar_TEMP"), ($name+"_curva_TEMP")};
    closeCurve -ch 0 -ps 1 -rpo 1 -bb 0.5 -bki 0 -p 0.1 ($name+"_curva_TEMP");
    planarSrf -name ($name+"_planar_TEMP") -ch 0 -d 3 -ko 0 -tol 0.01 -rn 0 -po 0 ($name+"_curva_TEMP");
    select ($name+"_planar_TEMP"); CenterPivot;
    setAttr ($name+"_planar_TEMP.s") 1.1 1.1 1.1;
   
        for($n=0;$n<size($circlesGRPS);$n++)
        {
   
            if($n>0)
            {
            select ($name+"_planar_TEMP") $circlesGRPS[$n];
            delete `normalConstraint -aimVector 0 0 1 -upVector -1 0 0 -worldUpType "object" -worldUpObject $circlesGRPS[$n-1]`;
            }
            else
            {
            select ($name+"_planar_TEMP") $circlesGRPS[$n];
            delete `normalConstraint -aimVector 0 0 1 -upVector 1 0 0 -worldUpType "object" -worldUpObject $circlesGRPS[$n+1]`;
            }
        }

//=== second iteration

   
        for($n=0;$n<size($circlesGRPS);$n++)
        {
        select ($name+"_curva_TEMP") $circlesGRPS[$n];
        delete `tangentConstraint  -aimVector 1 0 0 -upVector 0 0 1 -worldUpType "objectrotation" -worldUpVector 0 0 1 -worldUpObject $circlesGRPS[$n]`;
       
            if($n==(size($circlesGRPS)-1))
            {
            select $circlesGRPS[$n-1] $circlesGRPS[$n]; delete `orientConstraint`;
            }
       
        }
       
       
        if(size($circlesGRPS)<4)
        {
            for($n=0;$n<size($circlesGRPS);$n++)
            {
                if($n==(size($circlesGRPS)-1))
                {
                select $circlesGRPS[1] $circlesGRPS[0]; delete `orientConstraint`;
                }
            }
        }
       
       
   
    delete $stuff;

    select ($name+"_MSL");
    //DeleteHistory;
    //select $joints ($name+"_MSL");
    //skinCluster -name ($name+"_SKC") -tsb;
    clear $joints $circles $circlesGRPS;
   
    select $start $end; distance_DST $name;
    addAttr -ln "distance" -k 1 ($name+"_msl_GRP");
    connectAttr ($name+"_shape_DST.distance") ($name+"_msl_GRP.distance");
    setAttr ($name+"_shape_DST.v") 0;
    setAttr -k 0 -l 1 ($name+"_shape_DST.v") 0;
   
   
    return ($name+"_MSL");
    }

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

global proc cleanSelection(int $iter)
{


for($i=0;$i<$iter;$i++)
{
GrowPolygonSelectionRegion;
}
for($i=0;$i<$iter;$i++)
{
GrowPolygonSelectionRegion;
}

for($i=0;$i<$iter;$i++)
{
ShrinkPolygonSelectionRegion;
}
for($i=0;$i<$iter;$i++)
{
ShrinkPolygonSelectionRegion;
}

for($i=0;$i<$iter;$i++)
{
GrowPolygonSelectionRegion;
}

for($i=0;$i<$iter;$i++)
{
ShrinkPolygonSelectionRegion;
}

for($i=0;$i<$iter;$i++)
{
ShrinkPolygonSelectionRegion;
}

for($i=0;$i<$iter;$i++)
{
GrowPolygonSelectionRegion;
}


}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

global proc string[] autoVolumeCages(string $joint, float $ratio, float $length)
{

string $list[] = `ls -sl`;
string $children[] = `listRelatives -type joint -ad $joint`;
string $return[];

//=== find mesh

string $skinCluster[] = `listConnections -type skinCluster -s 0 $joint`;
string $listSet[] = `sets -q -no ($skinCluster[0]+"Set")`;
string $nodes[];
string $mesh;



if(`gmatch $listSet[0] "*Shape*"`)
{
select $listSet[0];
$nodes = `pickWalk -d up`;
$mesh = $nodes[0];
}
else
{
$mesh = $listSet[0];
}

//=== loop

string $first;
string $last;

if(size($children)>0)
{
    for($i=0;$i<size($children);$i++)
    {
        if($i==0)
        {
        string $furtherChildren[] = `listRelatives -type joint -c $joint`;
        $first = $joint;
        $last = $furtherChildren[0];
        }
        else
        {
        string $furtherChildren[] = `listRelatives -type joint -c $children[$i]`;
        $first = $children[$i];
        $last = $furtherChildren[0];
        }
               
    select $first $last;
    pullCage $first $ratio $length;
    parent -w ($first+"_PUL"); delete ($first+"_ENV");

    $return[size($return)] = ($first+"_PUL");
       
    }
}

select $list;
return $return;

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// with an arbitrary number of meshes with the same name as the joints + "_PUL", it will
// "convert" the volume described by the mesh into skin weights assigned to the corresponding joint
// it needs an existing skinCluster obvously.

global proc cageSkinWeights(string $mesh, int $smoothIterations)
{

string $list[] = `ls -sl`;

string $pullNodes[] = `ls "*_PUL"`;
string $skinCluster = `findRelatedSkinCluster $mesh`;
string $skinJoints[] = `listConnections -type joint ($skinCluster+".lockWeights")`;
string $jointSets[];
string $delete[];

//=== find corresponding joints and cages

string $cages[];
string $joints[];

string $TMPcages[];
string $TMPjoints[];

    for($i=0;$i<size($skinJoints);$i++)
    {
    $TMPcages[size($TMPcages)] = ($skinJoints[$i]+"_PUL");
    }


    for($i=0;$i<size($TMPcages);$i++)
    {
        if(`objExists $TMPcages[$i]`)
        {
        $cages[size($cages)] = $TMPcages[$i];
        $joints[size($joints)] = $skinJoints[$i];
        }
    }

//=== creating the point selection sets for the joints


    for($i=0;$i<size($cages);$i++)
    {
    select `wmVolumeSelect -m $mesh -am $cages[$i]`;
    cleanSelection 3;
    sets -name ($joints[$i]+"_SEL");
    $jointSets[size($jointSets)] = ($joints[$i]+"_SEL");
    $delete[size($delete)] = ($joints[$i]+"_SEL");
    }

select -cl;

//=== finding out the overlapping points

    for($i=0;$i<size($jointSets);$i++)
    {
    select -tgl $jointSets[$i];
    }

select -tgl ($mesh+".vtx["+"*"+"]");
sets -name "overlap_SEL";
$delete[size($delete)] = "overlap_SEL";
select -cl;

//=== assign weights per joint

    for($i=0;$i<size($joints);$i++)
    {
    select $joints[$i] ($joints[$i]+"_SEL") ;
    select -d overlap_SEL;
    GrowPolygonSelectionRegion;
    skinValue .5;
    ShrinkPolygonSelectionRegion;
    skinValue 1;
    }

//=== smooth overlapping areas

select overlap_SEL;

for($i=0; $i<$smoothIterations;$i++)
{
wmAvgWeights -a 1;
}

GrowPolygonSelectionRegion;

for($i=0; $i<$smoothIterations;$i++)
{
wmAvgWeights -a 1;
}

GrowPolygonSelectionRegion;

for($i=0; $i<$smoothIterations;$i++)
{
wmAvgWeights -a 1;
}

GrowPolygonSelectionRegion;

for($i=0; $i<$smoothIterations;$i++)
{
wmAvgWeights -a 1;
}

//=== end

select $list;
delete $delete;

}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

global proc saveCages(string $cages[], string $file)
{
string $list[] = `ls -sl`;
select $cages;
file -f -op "v=0" -typ "mayaAscii" -pr -es $file;
select $list;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


global proc loadCages(string $file)
{
string $list[] = `ls -sl`;

string $currentCages[] = `ls "*PUL"`;
string $oldCages[];
string $origCages[];
string $delete[];

if(size($currentCages)>0)
{
    for($item in $currentCages)
    {
    rename $item ("TMP_"+$item);
    $oldCages[size($oldCages)] = ("TMP_"+$item);
    $origCages[size($origCages)] = $item;
    }
}

file -import -type "mayaAscii" -rpr "pippo" -options "v=0" $file;
select "*PUL"; select -d "TMP_*PUL";
string $newCages[] = `ls -sl`;

if(size($currentCages)>0)
{
    for($i=0;$i<size($newCages);$i++)
    {
        for($o=0;$o<size($oldCages); $o++)
        {
            if(`gmatch $oldCages[$o] ("TMP_"+$newCages[$i])`==1)
            {
            $delete[size($delete)] = $oldCages[$o];
            }
            //else
            //{
            //rename $oldCages[$o] $origCages[$o];
            //}
        }
    }
}
delete $delete;
select -cl; fcSearchReplace "TMP_" "";
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

global proc string[] build_multipleIk_joints(string $baseName, int $ikh)
{
   
    int $num;
    string $joints[];
    string $pref;
    string $suff;
    string $list[] = `ls -sl`;
    string $item;
    string $ikhs[];
    select -cl;

    if(size($list) == 0)
    {
    print "\nselect objects to match in order\n";
    }
    else
    {
   
        for($i=0;$i<size($list);$i++)
        {
        string $name = ($baseName+"_"+($i+1));
        string $jnt;

            if(size($joints) == 0)
            {
            float $pos[] = `xform -q -ws -t $list[$i]`;
            float $rot[] = `xform -q -ws -ro $list[$i]`;
            $jnt = `joint -p $pos[0] $pos[1] $pos[2] -sc false -name ($name +  "_JNT")`;
            setAttr ($jnt + ".jointOrient") 0 0 0;
            $joints[`size $joints`] = $jnt;
            select $jnt;
            }
            else
            {
            float $pos[] = `xform -q -ws -t $list[$i]`;
            float $rot[] = `xform -q -ws -ro $list[$i]`;
            $jnt = `joint -p $pos[0] $pos[1] $pos[2] -sc off -name ($name +  "_JNT")`;
            joint -e -zso -oj zyx $joints[(size($joints)-1)];
            $joints[`size $joints`] = $jnt;
            select $jnt;
            }
        }
    }
   

    if($ikh>0)
    {
        for($i=1;$i<size($joints);$i++)
        {
        //print ("\nselect "+$joints[$i-1]+" "+$joints[$i]);
        select $joints[$i-1] $joints[$i];
        string $nodes[] = `ikHandle -s sticky`;
        rename $nodes[0] ($baseName+"_"+$i+"_IKH");
        $ikhs[`size $ikhs`] = ($baseName+"_"+$i+"_IKH");
        }
    }

    select $joints;
    joint -e -spa;

    select -cl;
   
    string $return[] = stringArrayCatenate($joints, $ikhs);
    return $return;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

global proc string[] returnChildren(string $root, string $type)
{
string $lista[] = `ls -sl`;
string $nodes[];

select -hi $root;
string $list[] = `ls -type $type -sl`;;

for($item in $list)
{

string $current[] = `ls $item`;

    if(!`gmatch $current[0] $root`)
    $nodes[size($nodes)] = $current[0];

}


return $nodes;
select $lista;

}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


global  proc string buildCurve(string $name, int $degrees)
{

string $nodes[] = `ls -sl`;
float $coord[];
string $return[] = {$name};   
string $command = ("curve -name "+$name+" -d " + $degrees+" ");

    for($i = 0;$i<size($nodes);$i++)
    {
    float $coord[] = `xform -q -ws -t $nodes[$i]`;
    string $point = (" -p " + $coord[0] + " " + $coord[1] + " " +  $coord[2] + " ");
    $command += $point;
    }

eval($command);

select $nodes;
return $name;

}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


global proc lockTrans(string $obj, int $min, int $max, int $X, int $Y, int $Z)
{
int $switches[] = {$X,$Y,$Z};
string $axes[] = {"x","y","z"};

    for($i=0;$i<3;$i++)
    {
    string $comm = ("transformLimits -t"+$axes[$i]+" (`getAttr "+$obj+".t"+$axes[$i]+"`) (`getAttr "+$obj+".t"+$axes[$i]+"`) -et"+$axes[$i]+" "+$min+" "+ $max+" "+$obj+";");
        if($switches[$i]>0)
        eval($comm);
    }
}

global proc lockRot(string $obj, int $min, int $max, int $X, int $Y, int $Z)
{
int $switches[] = {$X,$Y,$Z};
string $axes[] = {"x","y","z"};

    for($i=0;$i<3;$i++)
    {
    string $comm = ("transformLimits -r"+$axes[$i]+" (`getAttr "+$obj+".r"+$axes[$i]+"`) (`getAttr "+$obj+".r"+$axes[$i]+"`) -er"+$axes[$i]+" "+$min+" "+ $max+" "+$obj+";");
        if($switches[$i]>0)
        eval($comm);
    }
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

global proc poseNormals(string $mesh, int $deleteHistory)
{


select $mesh;
float $prima = `computePolysetVolume`;
float $primaPos = ($prima*$prima);

string $points[] =  `ls -fl ($mesh+".vtx[*]")`;

for($i = 0;$i<10;$i++)
{
moveVertexAlongDirection -n 0.1 $points[$i];
}

select $mesh;
float $dopo = `computePolysetVolume`;
float $dopoPos = ($dopo*$dopo);

if($primaPos>$dopoPos)
{
select $mesh;
ReversePolygonNormals;
}

if($deleteHistory == 1)
{
select $mesh;
DeleteHistory;
}

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//=== needs wmVolumeSelect

global proc wireCleanSet(string $wire, float $radius)
{

string $curves[] = `listConnections ($wire+".deformedWire[0]")`;
string $sets[] = `listConnections ($wire+".message")`;
string $meshs[] = `listConnections ($wire+".outputGeometry")`;

string $curve = $curves[0];
string $mesh = $meshs[0];
string $set = $sets[0];

circle -name ($wire+"_circle") -c 0 0 0 -nr 0 1 0 -sw 360 -r $radius -d 3 -ut 0 -tol 0.01 -s 8 -ch 1;

extrude -name ($wire+"_nurb_VOL") -ch true -rn false -po 0 -et 2 -ucp 1 -fpt 1 -upn 1 -rotation 0 -scale 1 -rsp 1 ($wire+"_circle") $curve ;
string $patate[] = `nurbsToPoly -mnd 1  -ch 1 -f 1 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 1 -un 3 -vt 1 -vn 3 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 ($wire+"_nurb_VOL")`;
rename $patate[0] ($wire+"_VOL");
poseNormals ($wire+"_VOL") 1;

sets -name ($wire+"_all_SEL") `ls ($mesh+".vtx[*]")`;

select `wmVolumeSelect -m $mesh -am ($wire+"_VOL")`;
sets -rm ($wire+"_all_SEL");

select ($wire+"_all_SEL");
sets -rm $set;

delete ($wire+"_all_SEL") ($wire+"_circle") ($wire+"_nurb_VOL")($wire+"_VOL");

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//=== needs wmVolumeSelect and wmSmooth

global proc  selectDiff(string $mesh, string $selectingMesh)
{
select $selectingMesh;
string $smooth = `wmSmooth`;
string $points[] = `wmVolumeSelect -m $mesh -am $selectingMesh`;
delete $smooth;
select $points;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

global proc sculptCleanSet(string $sculpt , string $mesh)
{

string $sets[] = `listConnections ($sculpt+".message")`;

spaceLocator -name ($sculpt+"_REF");
string $orig[] = `listConnections ($sculpt+".startPosition")`;
select $orig[0] ($sculpt+"_REF"); pointConstraint;
select $mesh ($sculpt+"_REF"); geometryConstraint;

select $orig[0] ($sculpt+"_REF");
float $dist = `get_distance`;
float $center[] = `xform -q -ws -t $orig[0]`;

sets -name ($sculpt+"_all_SEL") `ls -fl ($mesh+".vtx[*]")`;


select `wmVolumeSelect -m $mesh -center $center[0] $center[1] $center[2] -r ($dist*1.2)`;
GrowPolygonSelectionRegion; GrowPolygonSelectionRegion; GrowPolygonSelectionRegion;

sets -rm ($sculpt+"_all_SEL");

select ($sculpt+"_all_SEL");
sets -rm $sets[0];

delete ($sculpt+"_all_SEL") ($sculpt+"_REF");

}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

global proc mirror_sculpts(string $geo)
{

string $list[] = `ls -sl`;
string $names[];

for($item in $list)
{
string $pippo = substring($item, 1, (size($item)-7));
$names[size($names)] = $pippo;
}


    for($name in $names)
    {
    string $neutralName = substring($name,2,size($name));
    string $rName = ("r"+$neutralName);

    string $orig[] = `listConnections ($name+"_sculpt.startPosition")`;
    string $sculptGeo[] = `listConnections ($name+"_sculpt.sculptObjectGeometry")`;
    string $group[] = `listRelatives -ap $sculptGeo[0]`;
    string $parent[] = `listRelatives -ap $group[0]`;

print "\n";
print "orig is: ";
print $orig[0];
print "\n";
print "sculpt geo is: ";
print $sculptGeo[0];
print "\n";
print "parent is: ";
print $parent[0];
print "\n";


    string $neutralOrig = substring($orig[0],2,size($orig[0]));
    string $neutralSculptGeo = substring($sculptGeo[0],2,size($sculptGeo[0]));
    string $neutralGroup = substring($group[0],2,size($group[0]));
    string $neutralParent = substring($parent[0],2,size($parent[0]));

    string $rOrig = ("r"+$neutralOrig);
    string $rSculptGeo = ("r"+$neutralSculptGeo);
    string $rGroup = ("r"+$neutralGroup);
    string $rParent = ("r"+$neutralParent);
   
    //===== sculpt attributes
   
    float $envelope = `getAttr ($name+"_sculpt.envelope")`;
    float $disp = `getAttr ($name+"_sculpt.maximumDisplacement")`;
    float $dist = `getAttr ($name+"_sculpt.dropoffDistance")`;
   
    spaceLocator -name ($name+"_grp_TMP");
    select $group[0] ($name+"_grp_TMP"); delete `parentConstraint`; delete `scaleConstraint`;
    spaceLocator -name ($name+"_orig_TMP");
    select $orig[0] ($name+"_orig_TMP"); delete `parentConstraint`; delete `scaleConstraint`;
    spaceLocator -name ($name+"_sculptgeo_TMP");
    select $sculptGeo[0] ($name+"_sculptgeo_TMP"); delete `parentConstraint`; delete `scaleConstraint`;
   
    parent ($name+"_sculptgeo_TMP") ($name+"_orig_TMP") ($name+"_grp_TMP");
    select ($name+"_grp_TMP");
    group -name ($name+"_pippo_TMP"); xform -os -piv 0 0 0;
    setAttr ($name+"_pippo_TMP.sx") -1;

   
    //==== create sculpt
   
    select $geo;
    string $command = ("mySculpt "+$rName+" "+$rParent);
    eval($command);

    parent -w ($name+"_grp_TMP");


    select ($name+"_grp_TMP") $rGroup; delete `parentConstraint`; delete `scaleConstraint`;
    select ($name+"_orig_TMP") $rOrig; delete `parentConstraint`; delete `scaleConstraint`;
    select ($name+"_sculptgeo_TMP") $rSculptGeo; delete `parentConstraint`; delete `scaleConstraint`;

    float $scale[] = `getAttr ($group[0]+".s")`;
    setAttr ($rGroup+".s") $scale[0]  $scale[1]  $scale[2];
   
    float $scale[] = `getAttr ($sculptGeo[0]+".s")`;
    setAttr ($rSculptGeo+".s") $scale[0]  $scale[1]  $scale[2];

    setAttr ($rName+"_sculpt.envelope") $envelope;
    setAttr ($rName+"_sculpt.maximumDisplacement") $disp;
    setAttr ($rName+"_sculpt.dropoffDistance") $dist;
   
    delete ($name+"_*_TMP");

//=== replicate connections

    string $POC[] = `listConnections -type pointConstraint ($group[0]+".tx")`;
    string $PAC[] = `listConnections -type parentConstraint ($group[0]+".tx")`;
    string $ORC[] = `listConnections -type orientConstraint ($group[0]+".rx")`;
    string $SCC[] = `listConnections -type pointConstraint ($group[0]+".sx")`;
   
    string $conCommand;
   
    if(size($ORC)>0)
    {
   
    int $offset = 0;
   
        if(`getAttr ($ORC[0]+".offsetX")`!=0)
        $offset = 1;
        if(`getAttr ($ORC[0]+".offsetY")`!=0)
        $offset = 1;
        if(`getAttr ($ORC[0]+".offsetZ")`!=0)
        $offset = 1;
   
    string $targets[] = `listConnections -type transform ($ORC[0]+".target["+"*"+"].targetRotate")`;
    string $rTargets[];
   
        for($item in $targets)
        {
        string $pippo = substring($item,2,size($item));
        $rTargets[size($rTargets)] = ("r"+$pippo);
        }
   
        if($offset >0)
        $conCommand = ("orientConstraint -mo;");
        else
        $conCommand = ("orientConstraint;");
   
    select $rTargets $rGroup;
    eval($conCommand);
    }


    }

}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

global proc fxRenameSuff(string $suff)
{

string $list[] = `ls -sl`;

if(!`gmatch $list[1] ($list[0]+"_"+$suff)`)
{
    if(!`objExists ($list[0]+"_"+$suff)`)
    rename $list[1] ($list[0]+"_"+$suff);
    else
    {
    duplicate ($list[0]+"_"+$suff);
    delete ($list[0]+"_"+$suff);
    rename $list[1] ($list[0]+"_"+$suff);
    }
}

string $papa[] = `listRelatives -ap ($list[0]+"_"+$suff)`;

parent ($list[0]+"_"+$suff) $list[0];
makeIdentity -apply true -t 1 -r 1 -s 1 -n 0;ResetTransformations;

if(size($papa))
parent ($list[0]+"_"+$suff) $papa[0];

}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



global proc string paramVOC()
{
//=== select an object and a curve

string $nodes[] = `ls -sl`;
string $curve = $nodes[1];
string $node = $nodes[0];
int $spans = `getAttr ($curve+".spans")`;
float $minMax[] = `getAttr ($curve+".minMaxValue")`;

select $curve $node;
delete `geometryConstraint`;

select -cl;
spaceLocator -name tmp;
select $node tmp;delete `pointConstraint`;

$mpath = `createNode motionPath`;
setAttr ($mpath + ".fractionMode") (!true);
connectAttr ($curve + ".worldSpace[0]") ($mpath + ".geometryPath");
connectAttr -f ($mpath + ".allCoordinates") tmp.translate;
rename $mpath tmp_mpa;
CBdeleteConnection tmp_mpa.u;




$dist = `distanceDimension -sp 100 100 100 -ep 200 200 200`;
string $dispensable[] =  `listConnections $dist`;

if(`objExists ($node + ".worldPosition")`)
{
connectAttr -f ($node + ".worldPosition") ($dist + ".startPoint");
}
else
{
spaceLocator -name pippo;
select $node pippo;delete `pointConstraint`;
connectAttr -f pippo.worldPosition ($dist + ".startPoint");
}

connectAttr -f tmpShape.worldPosition ($dist + ".endPoint");
delete $dispensable;

float $i;
float $distances[];
float $Uvalue;
float $Uvalues[];
float $incr = ((1.00/100)*$minMax[1]);
float $roof = (1.00*$minMax[1]);

for($i = $minMax[0]; $i < $minMax[1];$i+=$incr)
{
//print ("\ntesting "+$i+" with "+$spans+" spans and "+$roof+" roof with "+$incr+" increment\n");
setAttr tmp_mpa.u $i;
float $distanza = `getAttr ($dist + ".distance")`;
$distances[size($distances)] = $distanza;
$Uvalues[size($Uvalues)] = $i;
//print ("\n for value " + $i + " distance is " + $distanza + "\n");
}

float $sorted[] = `sort $distances`;
float $smallest = $sorted[0];

for($n = 0; $n < size($distances);$n++)
{
if($distances[$n] == $smallest)
$Uvalue = $Uvalues[$n];
}

//print ("\n VALUE is " + $Uvalue + " \n");

delete tmp;

$mpath = `createNode motionPath`;
setAttr ($mpath + ".fractionMode") (!true);
connectAttr ($curve + ".worldSpace[0]") ($mpath + ".geometryPath");
connectAttr -f ($mpath + ".allCoordinates") ($node+".translate");
rename $mpath ($node + "_mpa");
setAttr ($node + "_mpa.u") $Uvalue;

if(`objExists pippo`)
{
delete pippo;
}

select -cl;
return ($node + "_mpa");
}

//================================================================================
//================================================================================
//================================================================================


global proc uv2param(string $mpa)
{
string $curve[] = `listConnections -type nurbsCurve $mpa`;
float $mnMx[] = `getAttr ($curve[0]+".minMaxValue")`;
float $uval = `getAttr ($mpa+".uValue")`;
setAttr ($mpa + ".fractionMode") (!true);
 catchQuiet(`setAttr ($mpa+".uValue") ($uval*$mnMx[1])`);
}

//================================================================================
//================================================================================
//================================================================================

global proc select_asfJoints()
{

string $joints[] = `ls -type joint`;
string $asf[];

for($item in $joints)
{
string $attrs[] = `listAttr -ud $item`;

for($a in $attrs)
if(`gmatch $a "asfId"`)
$asf[size($asf)] = $item;

}

select $asf;

}

//================================================================================
//================================================================================
//================================================================================

global proc string[]  reverseString(string $list[])
{

string $lista[];

for($i=(size($list));$i>-1;$i--)
{
$lista[size($lista)] = $list[$i];
}

return $lista;

}

//================================================================================
//================================================================================
//================================================================================


global proc lockTrans(string $obj, int $min, int $max, int $X, int $Y, int $Z)
{
int $switches[] = {$X,$Y,$Z};
string $axes[] = {"x","y","z"};

    for($i=0;$i<3;$i++)
    {
    string $comm = ("transformLimits -t"+$axes[$i]+" (`getAttr "+$obj+".t"+$axes[$i]+"`) (`getAttr "+$obj+".t"+$axes[$i]+"`) -et"+$axes[$i]+" "+$min+" "+ $max+" "+$obj+";");
        if($switches[$i]>0)
        eval($comm);
    }
}


//================================================================================
//================================================================================
//================================================================================

global proc string[] fxGetConstraintPose()
{
string $list[] = `ls -sl`;
string $lista[];
string $line;
string $DA;
int $pippo[];
float $pluto;
float $topolino[];
int $paperino;
string $print[];

for($def in $list)
{
//$lista = `listAttr -c -v -k -u -s $def`;
$lista = `listAttr -v -k $def`;
for($item in $lista)
    {
    string $type = `getAttr -type ($def+"."+$item)`;
    print "\n";
    print $item;
    print "\n";
   
        if(`gmatch $type "*double*"`)
        {
        $pluto = `getAttr ($def + "." + $item)`;
        $line = (" catchQuiet(`setAttr " + $def + "." + $item + " " + $pluto + "`);");
        $print[size($print)] = $line;
        }
        if(`gmatch $type "*bool*"`)
        {             
        $paperino = `getAttr ($def + "." + $item)`;
        $line = (" catchQuiet(`setAttr " + $def + "." + $item + " " + $paperino + "`);");
        $print[size($print)] = $line;
        }
        if(`gmatch $type "*long*"`)
        {             
        $pluto = `getAttr ($def + "." + $item)`;
        $line = (" catchQuiet(`setAttr " + $def + "." + $item + " " + $pluto + "`);");
        $print[size($print)] = $line;
        }
        if(`gmatch $type "*TdataCompound*"`)
        {             
        $topolino = `getAttr ($def + "." + $item)`;
        for($i=0;$i<size($topolino);$i++)
        {
        $line = "";
        $line += (" catchQuiet(`setAttr " + $def + "." + $item + "["+$i+"] " + $topolino[$i] + "`);");
        }
       
        $print[size($print)] = $line;
        }

    }
}

return $print;

}




//===========================================================================================
//===========================================================================================
//===========================================================================================
//===========================================================================================


global proc string exportConstraintPose(string $fileName)
{
string $sel[] = `ls -sl`;


    string $pose[];
    string $return;
    string $stringAttr;
    $fileId = `fopen $fileName "w"`;
   
    $pose = `fxGetConstraintPose`;
   
    for($item in $sel)
    $pose[size($pose)] =  `printCon $item`;
   
    for($i = 0; $i < size($pose);$i++)
    {
    fprint $fileId ($pose[$i] + "\n");
    $return+=($pose[$i] + "\n");
    }
   
    fclose $fileId;

return $return;

}



//string $list[] = `ls l_hand_1 l_up_fing_1 l_mid_fing_1 l_low_fing_1`;
//rigFinger $list;

//============================

global proc string[] findMeatPoints(string $root, string $end, string $dir, int $pos, int $ratio)
{

string $return[];

string $list[] = `ls -sl`;
select $root $end;
float $dist = `get_distance`;

string $loc[] = `spaceLocator`;
string $rootLoc = $loc[0];
string $loc[] = `spaceLocator`;
string $rootREF = $loc[0];
string $loc[] = `spaceLocator`;
string $midLoc = $loc[0];
string $loc[] = `spaceLocator`;
string $endLoc = $loc[0];



select $root $end $midLoc;
delete `pointConstraint`;
parent $rootLoc $rootREF $midLoc $endLoc $root;
setAttr ($midLoc+".r") 0 0 0;

if($pos!=0)
setAttr ($midLoc+".t"+$dir) (1.2*($dist/$ratio));
else
setAttr ($midLoc+".t"+$dir) (-1.2*($dist/$ratio));


select $root $rootLoc; delete `parentConstraint`;
select $end $endLoc; delete `parentConstraint`;
select $rootLoc $rootREF; delete `parentConstraint`;

if($pos!=0)
setAttr ($rootREF+".t"+$dir) ($dist/$ratio);
else
setAttr ($rootREF+".t"+$dir) (-1*($dist/$ratio));


$return[size($return)] = $rootLoc;
$return[size($return)] = $midLoc;
$return[size($return)] = $endLoc;
$return[size($return)] = $rootREF;

select $list;
return $return;
}

//=================================

global proc string bridgeChain(string $name, string $dir, int $pos, int $ratio)
{

string $joints[] = `ls -sl`;
//=== variables

string $locators[];
string $chainPoints[];
string $refChainPoints[];
string $prevPoints[];
string $thisPoints[];
string $meatJoints[];
string $crvPoints[];
string $refLocs[];
string $root = $joints[0];

int $min = 0;
int $max =0;
int $x=0;
int $y=0;
int $z=0;

if($dir == "x")
$x = 1;
$y = 0;
$z = 0;
if($dir == "y")
$x = 0;
$y = 1;
$z = 0;
if($dir == "z")
$x = 0;
$y = 0;
$z = 1;

if($pos == 1)
{
$min = 1;
$max = 0;
}
else
{
$min = 0;
$max = 1;
}
//==== loop


    for($i=1;$i<(size($joints));$i++)
    {
   
   
        //=== create temporary reference locators for PREVIOUS node
       
        if($i==1)
        $prevPoints = `findMeatPoints $joints[$i-1] $joints[$i] $dir $pos $ratio`;
        else
        $prevPoints = $thisPoints;
       
        //=== create temporary reference locators for THIS node
       
        if(`objExists $joints[$i+1]`)
        {
        $thisPoints = `findMeatPoints $joints[$i] $joints[$i+1] $dir $pos $ratio`;
        }

       
        //=== ref for main chain
       
        if(!`objExists $joints[$i+1]`)
        $chainPoints = {$prevPoints[3], $thisPoints[1], $thisPoints[2]};
        else
        $chainPoints = {$prevPoints[3], $prevPoints[1], $thisPoints[3]};

        //=== keep in mind points for curve

        $refLocs[size($refLocs)] = $chainPoints[0];
        $crvPoints[size($crvPoints)] = $chainPoints[0];
       
        if($i==(size($joints)-1))
        $crvPoints[size($crvPoints)] = $chainPoints[2];

        //=== create chains using the reference locators
       
        select $chainPoints;
        $meatJoints = `build_joints ($joints[$i-1]+"_"+$name) 1`;
       
        if(`objExists $joints[$i-1]`)
        parent $meatJoints[0] $joints[$i-1];
       
        //=== create xtra chain for hand finger
       
        if($i==2)
        {
        select -cl;
        joint -name ($joints[$i-2]+"_"+$name+"_3q_JNT");
        parent ($joints[$i-2]+"_"+$name+"_3q_JNT")($joints[$i-2]);

        setAttr ($joints[$i-2]+"_"+$name+"_3q_JNT.r") 0 0 0;
        setAttr ($joints[$i-2]+"_"+$name+"_3q_JNT.t") 0 0 0;
        setAttr ($joints[$i-2]+"_"+$name+"_3q_JNT.jointOrient") 0 0 0;
       
        select $joints[1] ($joints[$i-2]) ($joints[$i-2]+"_"+$name+"_3q_JNT");
        orientConstraint;
       
        select -cl;
        joint -name ($joints[$i-1]+"_"+$name+"_rev_chain_root_JNT");
        joint -name ($joints[$i-1]+"_"+$name+"_rev_chain_end_JNT");
        select ($joints[$i-1]+"_"+$name+"_2_JNT") ($joints[$i-1]+"_"+$name+"_rev_chain_root_JNT"); delete `parentConstraint`;
        parent ($joints[$i-1]+"_"+$name+"_rev_chain_root_JNT") ($joints[$i-1]+"_"+$name+"_2_JNT");
        select ($joints[$i-2]+"_"+$name+"_2_JNT") ($joints[$i-1]+"_"+$name+"_rev_chain_end_JNT");delete `parentConstraint`;
        select ($joints[$i-1]+"_"+$name+"_rev_chain_root_JNT") ($joints[$i-1]+"_"+$name+"_rev_chain_end_JNT");
        string $pippo[] = `ikHandle -s sticky`;
        rename $pippo[0] ($joints[$i-1]+"_"+$name+"_rev_chain_IKH");
        parent ($joints[$i-1]+"_"+$name+"_rev_chain_IKH") ($joints[$i-2]+"_"+$name+"_2_JNT");
        select $joints[1] ($joints[$i-1]+"_"+$name+"_rev_chain_IKH"); delete `pointConstraint`;
        select $root $joints[1] ($joints[$i-1]+"_"+$name+"_rev_chain_IKH"); parentConstraint -mo;
        select ($joints[$i-1]+"_"+$name+"_rev_chain_end_JNT") ($joints[$i-2]+"_"+$name+"_3q_JNT"); pointConstraint;
       
       
       
        if($dir == "x")
        {
        lockTrans ($joints[$i-2]+"_"+$name+"_3q_JNT") 1 1 0 1 0;
        lockTrans ($joints[$i-2]+"_"+$name+"_3q_JNT") $min $max 1 0 0;
        lockTrans ($joints[$i-2]+"_"+$name+"_3q_JNT") $min $max 0 0 1;
        }
        select -cl;
        }
     
       
        //=== create mid joint for weights
       
        select -cl;
        joint -name ($joints[$i-1]+"_"+$name+"_mid_JNT");
        parent ($joints[$i-1]+"_"+$name+"_mid_JNT") ($chainPoints[1]);
        select $meatJoints[1] ($joints[$i-1]+"_"+$name+"_mid_JNT"); pointConstraint;
        setAttr ($joints[$i-1]+"_"+$name+"_mid_JNT.r") 0 0 0;
        setAttr ($joints[$i-1]+"_"+$name+"_mid_JNT.jointOrient") 0 0 0;
        lockTrans ($joints[$i-1]+"_"+$name+"_mid_JNT") $min $max $x $y $z;
   
    //========================================
    //=== for deleting later   
    $locators[size($locators)] = $prevPoints[0];
    $locators[size($locators)] = $prevPoints[1];
    $locators[size($locators)] = $prevPoints[2];
    $locators[size($locators)] = $thisPoints[0];
    $locators[size($locators)] = $thisPoints[1];
    $locators[size($locators)] = $thisPoints[2];
   
   
        //=== parenting
        parent $meatJoints[0] $chainPoints[0];
        parent $meatJoints[3] $chainPoints[2];
       
    }
   
//=== build curve

string $crv = ($root+"_"+$name+"_CRV");
string $command = ("curve -d 2 -name " + $crv + " ");

    for($i = 0; $i<size($crvPoints);$i++)
    {
    float $p[] = `xform -q -a -ws -t $crvPoints[$i]`;
    string $point = (" -p " + $p[0] + " " + $p[1] + " " + $p[2]);
    $command += $point;
    }

eval $command;

select -cl;
for($item in $joints)
{
if(`objExists $item`)
select -add $item;
}
select -add  $crv;
skinCluster -name ($root+"_"+$crv+"_SKC") -tsb -mi 5 -dr 4 -rui true;

//=== motionPath ref locators


    for($i=0;($i<size($refLocs)-1);$i++)
    {

    string $crvREF = ($joints[$i]+"_"+$name+"_crv_REF");
    string $posREF = ($joints[$i]+"_"+$name+"_pos_REF");
   
    spaceLocator -name $crvREF;
    string $papa[] = `listRelatives -ap $refLocs[$i]`;
    parent $crvREF $papa[0];
    select $refLocs[$i] $crvREF; delete `parentConstraint`;
   
    select $crvREF $crv; closestValueOnCurve 0;
    setAttr ($crvREF+".inheritsTransform") 0;


    spaceLocator -name $posREF;
    string $papa[] = `listRelatives -ap $refLocs[$i]`;

    if($i>0)
    parent $posREF $joints[$i-1];
    else
    parent $posREF $papa[0];

    select $refLocs[$i] $posREF; delete `parentConstraint`;
   
   
    if(!`objExists ($crvREF+"_POC")`)
    {
    //print ("\n"+$crvREF+"_POC doesn't exist\n");
    //print ("\nselect "+" "+$crvREF+" "+ $posREF+" "+$refLocs[$i]);
    select $crvREF $posREF $refLocs[$i];
    //print ("\npointConstraint -name "+$crvREF+"_POC");
    pointConstraint -name ($crvREF+"_POC");
    //print ("\ninvConnect "+$crvREF+"_POC."+$crvREF+"W0 "+$crvREF+"_POC."+$posREF+"W1\n");
    invConnect ($crvREF+"_POC."+$crvREF+"W0") ($crvREF+"_POC."+$posREF+"W1");
    //setAttr ($crvREF+"_POC."+$crvREF+"W0") ($i/(size($refLocs)-1));
    //print ("\nsetAttr "+$crvREF+"_POC."+$crvREF+"W0 .5\n");
    setAttr ($crvREF+"_POC."+$crvREF+"W0") .5;
    }

    }

return $crv;

//=== end
}




















global proc copyTransform()
{

string $list[] = `ls -type transform -sl`;
string $first = $list[0];
string $copies[];
float $trans[] = `getAttr ($first+".t")`;
float $rot[] = `getAttr ($first+".r")`;
float $scale[] = `getAttr ($first+".s")`;


    for($i=1;$i<size($list);$i++)
    {
    setAttr ($list[$i]+".t") $trans[0] $trans[1] $trans[2];
    setAttr ($list[$i]+".r") $rot[0] $rot[1] $rot[2];
    setAttr ($list[$i]+".s") $scale[0] $scale[1] $scale[2];
    }

}



// source "/proj/avatar/dev/GEN/base/cre/work/felix/scripts/fxUtil.mel";
// source "/usr/home/fbalbas/maya/scripts/fx_utilities.mel";


//=== copyWrapGeo

global proc copyWrapGeo(string $source[], string $destination[])
{

file -f -new;
string $sourceGeo;
string $destinationGeo;
string $showDir = "/proj/avatar/dev/";
string $sourceAllGeo[];
string $sourceWrapGeo[];
string $sourceWrapChunk[];
string $handAndFeetGeo[];
string $destinationHeroGeo;

//=== mocapGeo
//=== source

string $source_dir = ($showDir+$source[0] +"/"+$source[1]+"/cre/");
string $source_mocapGeo = ($source_dir+"mocapGeo/");
string $latest_version = `mostRecent $source_mocapGeo`;
string $sourceMocapGeoGeo_path = ($source_mocapGeo+$latest_version+"/");
string $sourceMocapGeoGeo = `mostRecent $sourceMocapGeoGeo_path`;
string $sourceMocapGeoGeoFile = ($sourceMocapGeoGeo_path+"/"+$sourceMocapGeoGeo);

string $sourceMocapGeoGeoNodes[] = `importSceneForFuckSake $sourceMocapGeoGeoFile`;

$sourceGeo = $sourceMocapGeoGeoNodes[0];

//=== mocapGeo
//=== destination

string $destination_dir = ($showDir+$destination[0] +"/"+$destination[1]+"/cre/");
string $destination_mocapGeo = ($destination_dir+"mocapGeo/");
string $latest_version = `mostRecent $destination_mocapGeo`;
string $destinationMocapGeoGeo_path = ($destination_mocapGeo+$latest_version+"/");
string $destinationMocapGeoGeo = `mostRecent $destinationMocapGeoGeo_path`;
string $destinationMocapGeoGeoFile = ($destinationMocapGeoGeo_path+"/"+$destinationMocapGeoGeo);

string $destinationMocapGeoGeoNodes[] = `importSceneForFuckSake $destinationMocapGeoGeoFile`;

$destinationGeo = $destinationMocapGeoGeoNodes[0];

//===================== blend the two mocapGeos

select $sourceGeo $destinationGeo;
string $command = ("blendShapeDeleteTarget \"blendShape -name "+$destinationGeo+"_SHP\"");

eval($command);
setAttr ($destinationGeo+"_SHP."+$sourceGeo) 1;

//==============================================================================================
//=== wrap geometry
//=== source

string $wrapGeoDir = ($showDir+$source[0] +"/"+$source[1]+"/cre/scripts/creatureRigScripts/data/wrapGeo/");
string $wrapGeoScenes[] = `listFiles $wrapGeoDir "mb"`;


for($mb in $wrapGeoScenes)
{
string $temp[] = `importSceneForFuckSake ($wrapGeoDir+$mb)`;

    for($item in $temp)
    {
        if(`gmatch $item "*hand*"`||`gmatch $item "*foot*"`||`gmatch $item "*tail*"`||`gmatch $item "*Tail*"`)
        $handAndFeetGeo[size($handAndFeetGeo)] = $item;

        if(`gmatch $item "*Wrap*"`||`gmatch $item "*wrap*"`)
        $sourceWrapGeo[size($sourceWrapGeo)] = $item;


        if(`gmatch $item "*Chunk"`||`gmatch $item "*hero*"`||`gmatch $item "*Hero*"`)
        $sourceWrapChunk[size($sourceWrapChunk)] = $item;

    $sourceAllGeo[size($sourceAllGeo)] = $item;

    }

}

    for($geo in $sourceWrapGeo)
    {

    string $shape = ("setAttr "+$destinationGeo+"_SHP."+$sourceGeo+" 1");
    eval($shape);
   
    string $wrapBefore[] = `ls -type wrap`;
    select $geo $destinationGeo;
    eval("CreateWrap");

    string $wrapAfter[] = `ls -type wrap`;
    string $wrap[] = stringArrayRemove($wrapBefore, $wrapAfter);

    setAttr ($wrap[0]+".maxDistance") 0;

    string $shape = ("setAttr "+$destinationGeo+"_SHP."+$sourceGeo+" 0");
    eval($shape);

    refresh;
    select $geo;
    string $command = ("file -f -op \"v=0\" -typ \"WOBJ\" -es \"/tmp/"+$geo+"\"");
    eval($command);
    }

    for($geo in $sourceWrapChunk)
    {
    select $geo;
    string $command = ("file -f -op \"v=0\" -typ \"WOBJ\" -es \"/tmp/"+$geo+"\"");
    eval($command);
    }




    for($geo in $handAndFeetGeo)
    {
//=== tmp
    string $shape = ("setAttr "+$destinationGeo+"_SHP."+$sourceGeo+" 1");
    eval($shape);

    string $wrapBefore[] = `ls -type wrap`;
    select $geo $destinationGeo;
    eval("CreateWrap");
    string $wrapAfter[] = `ls -type wrap`;
    string $wrap[] = stringArrayRemove($wrapBefore, $wrapAfter);

    setAttr ($wrap[0]+".maxDistance") 0;
    string $shape = ("setAttr "+$destinationGeo+"_SHP."+$sourceGeo+" 0");
    eval($shape);

/*
if(`gmatch $geo "*foot*"`)
{

//=== real thing
print "THIS FOOT STINKS\n";
    select $destinationGeo $geo;
    string $command = "wmVertCopy -bind -uv";
    eval($command);
    refresh; dgdirty -a;
    updateGeo $geo;
    DeleteHistory $geo;
//=== real thing
}
*/
    refresh;
    select $geo;
    string $command = ("file -f -op \"v=0\" -typ \"WOBJ\" -es \"/tmp/"+$geo+"\"");
    eval($command);
    }

select $sourceAllGeo; select -d `ls -type transform "*arm*hero*" "*arm*Hero*" "*orso*hero*" "*orso*Hero*" "*hero*orso*" "*Hero*orso*" `;
string $import[] = `ls -sl`;
file -f -new;



    for($geo in $import)
    {
    string $command = ("file -import -type \"WOBJ\" -rpr \""+$geo+"\" -pr -loadReferenceDepth \"all\" \"/tmp/"+$geo+".obj\"");
    print ("\n"+$command);
    eval($command);
    }

    //for($geo in $handAndFeetGeo)
    //{
    //string $command = ("file -import -type \"WOBJ\" -rpr \""+$geo+"\" -pr -loadReferenceDepth \"all\" \"/tmp/"+$geo+".obj\"");
    //eval($command);
    //}

//=== heroGeo
//=== destination

string $destination_dir = ($showDir+$destination[0] +"/"+$destination[1]+"/model/hero/");

string $destinationHeroGeoGeo = `mostRecentType $destination_dir $destination[0] ".ma"`;
string $destinationHeroGeoGeoFile = ($destination_dir+"/"+$destinationHeroGeoGeo);

string $destinationHeroGeoGeoNodes[] = `importSceneForFuckSake $destinationHeroGeoGeoFile`;

string $children[] = `listRelatives -type transform -c $destinationHeroGeoGeoNodes[0]`;

string $temp[]; clear $temp;

for($child in $children)
{
    if(`gmatch  $child ($destination[0]+"*")`)
    $temp[size($temp)] = $child;
}


$destinationHeroGeo = $temp[0];

//========== cut hero geo;

string $chunkName;
string $nodes[];
string $scene;
string $wrapGeoDir = ($showDir+$destination[0] +"/"+$destination[1]+"/cre/scripts/creatureRigScripts/data/wrapGeo/");

if(!`file -q -ex $wrapGeoDir`)
{
string $sysCMD = ("mkdir "+$wrapGeoDir);
system($sysCMD);
}

string $sceneName;
int $doHeroChunk;

for($geo in $import)
{

//==== figure out the stupid names

if(`gmatch $geo "*Torso*"`)
{
$chunkName = "torsoHeroChunk";
$sceneName = "torsoGeo.mb";
$doHeroChunk = 1;
}

if(`gmatch $geo "*owerTorso*"`)
{
$chunkName = "lowerTorsoHeroChunk";
$sceneName = "lowerTorsoGeo.mb";
$doHeroChunk = 1;
}

if(`gmatch $geo "l_arm*"`)
{
$chunkName = "l_armHero";
$sceneName = "l_armGeo.mb";
$doHeroChunk = 1;
}

if(`gmatch $geo "r_arm*"`)
{
$chunkName = "r_armHero";
$sceneName = "r_armGeo.mb";
$doHeroChunk = 1;
}

if(`gmatch $geo "tail*"`)
{
$chunkName = "tailHeroChunk";
$sceneName = "tailGeo.mb";
$doHeroChunk = 0;
}

if(`gmatch $geo "l_foot*"`)
{
$chunkName = "l_footHeroChunk";
$sceneName = "l_footGeo.mb";
$doHeroChunk = 0;
}

if(`gmatch $geo "r_foot*"`)
{
$chunkName = "r_footHeroChunk";
$sceneName = "r_footGeo.mb";
$doHeroChunk = 0;
}

if(`gmatch $geo "l_hand*"`)
{
$chunkName = "l_handHero";
$sceneName = "l_handGeo.mb";
$doHeroChunk = 0;
}

if(`gmatch $geo "r_hand*"`)
{
$chunkName = "r_handHero";
$sceneName = "r_handGeo.mb";
$doHeroChunk = 0;
}


    if($doHeroChunk>0)
    {
    duplicate -n "TMPhero" $destinationHeroGeo;
    duplicate -n "TMPgeo" $geo;
    string $list[] = `ls -fl TMPgeo.vtx["*"]`;

        for($item in $list)
        {
        moveVertexAlongDirection -n 2 $item;
        }

    select `wmVolumeSelect -m TMPhero -am TMPgeo`;
    ConvertSelectionToFaces;
    GrowPolygonSelectionRegion;
    GrowPolygonSelectionRegion;
    GrowPolygonSelectionRegion;
    ShrinkPolygonSelectionRegion;
    ShrinkPolygonSelectionRegion;
    ShrinkPolygonSelectionRegion;
    ShrinkPolygonSelectionRegion;
    ShrinkPolygonSelectionRegion;
    ShrinkPolygonSelectionRegion;
    ShrinkPolygonSelectionRegion;
    ShrinkPolygonSelectionRegion;
    ShrinkPolygonSelectionRegion;
    GrowPolygonSelectionRegion;
    GrowPolygonSelectionRegion;
    GrowPolygonSelectionRegion;
    GrowPolygonSelectionRegion;
    GrowPolygonSelectionRegion;
    GrowPolygonSelectionRegion;
    string $sel[] = `ls -fl -sl`;
    string $allSel[] = `ls -fl TMPhero.f["*"]`;
    select $allSel; select -d $sel;
    doDelete;
    rename TMPhero $chunkName;
    delete TMPgeo;
    select $geo $chunkName;
    }
    else
    {
    select $chunkName;
    }
string $pippo[] = `ls -sl`;
group -name patatefritte;
parent -w `listRelatives -type transform patatefritte`;
delete patatefritte;
select $pippo;

if(`file -q -ex ($wrapGeoDir+$sceneName)`)
system ("cp "+ $wrapGeoDir+$sceneName +" "+ $wrapGeoDir+"previous_versions/"+$sceneName);

string $command = ("file -f -op \"v=0\" -typ \"mayaBinary\" -es \""+$wrapGeoDir+$sceneName+"\"");
print ("\n"+$command);
eval($command);
}


//========== copy weights

string $list[] = `ls -type transform "|*"`;
select $list; select -d persp top front side ($destination[0]+"*");
string $modules[] = `ls -sl`;

string $source_dir = ($showDir+$source[0] +"/"+$source[1]+"/cre/scripts/creatureRigScripts/data/skinWeights/");
string $destination_dir = ($showDir+$destination[0] +"/"+$destination[1]+"/cre/scripts/creatureRigScripts/data/skinWeights/");


for($item in $modules)
{
string $command = ("cp "+ $source_dir + $item + ".mel "+$destination_dir);
system($command);
}

}



// source "/usr/home/fbalbas/maya/scripts/fx_utilities.mel";
// source "/proj/avatar/dev/GEN/base/cre/work/felix/scripts/wmFxSaveMaps.mel";

global proc string[] wmFxGetDeformersPose()
{

//=== find mesh

string $current[] = `ls -sl`;
string $mesh = $current[0];

string $history[] = `listHistory $mesh`;

string $ls[];
string $list[];
string $alldefs[] = `ls -type wmSmooth -type wmBulge -type wmUnSmooth -type wire $history`;
string $type[];

$list = $alldefs;

print $ls;
$list = `reverseString $alldefs`;
print "\n";
print $list;


string $parent[];
string $item;
string $print[];
int $nb = size($print);
string $firstLine;
float $pip;
float $pippo[];
string $line;
string $wireLine;
string $DA;
string $aType;




    for($item in $list)
    {
    string $lista[];
   
        if(`objExists $item`)
        {
        //$lista = `listAttr -c -v -k -u -s $item`;
        $lista = `listAttr -k -se -v $item`;

           
        string $itema;
        $type = `ls -st $item`;

            if(`gmatch $type[1] "wmSmooth"`)
            {
            $firstLine = ("\n// wmSmooth ===== \n\nif(!`objExists "+$item+"`)\n{\nselect "+$mesh+";\nrename `wmSmooth` "+$item+";\n}\n");
            $lista[size($lista)] = "difMesh";
            $lista[size($lista)] = "volMesh";
            //$lista[size($lista)] = "curvatureControl[0].curvatureControl_FloatValue";
            //$lista[size($lista)] = "curvatureControl[1].curvatureControl_FloatValue";
            //    $print[$nb++] = $firstLine;
            }
   
            if(`gmatch $type[1] "wmUnSmooth"`)
            {
            $firstLine = ("\n// wmUnSmooth ===== \n\nif(!`objExists "+$item+"`)\n{\nselect "+$mesh+";\nrename `wmUnSmooth` "+$item+";\n}\n");
            //$lista[size($lista)] = "curvatureControl[0].curvatureControl_Position";
            //$lista[size($lista)] = "curvatureControl[1].curvatureControl_Position";
            $lista[size($lista)] = "UnSmoothMap";
            $lista[size($lista)] = "smoothMap";
            //    $print[$nb++] = $firstLine;
            }
   
            if(`gmatch $type[1] "wmBulge"`)
            {
            $firstLine = ("\n// wmBulge ===== \n\nif(!`objExists "+$item+"`)\n{\nselect "+$mesh+";\nrename `wmBulge` "+$item+";\n}\n");
            $lista[size($lista)] = "bulgeMode";
            $lista[size($lista)] = "bulgeMap";
            //$lista[size($lista)] = "curvatureControl[0].curvatureControl_FloatValue";
            //$lista[size($lista)] = "curvatureControl[1].curvatureControl_FloatValue";
            //    $print[$nb++] = $firstLine;
            }
   
            if(`gmatch $type[1] "wire"`)
            {
            $firstLine =("\n// wire ===== \n");
            //$lista[size($lista)] = "weightList[0].weights";
            }

        $print[$nb++] = $firstLine;
               
            if(`gmatch $type[1] "wire"`)
            {
                for($itema in $lista)
                {
           
                    if(`objExists ($item + "." + $itema)`)
                    {
                        print ("\ngetAttr -type "+$item + "." + $itema+";\n");
                        $aType = `getAttr -type ($item + "." + $itema)`;
                        //print "\nFOUND\n";
                        //print ($item + "." + $itema);
                        //print "\n";
           
                            if(`gmatch $aType "*doubleArray*"`||`gmatch $aType "*TdataCompound*"`)
                            {
                            print "\nDOUBLE ARRAY\n";
                            //print $itema;
                            //print "\n";
                   
                            $pippo = `getAttr ($item + "." + $itema)`;
                            $DA = (size($pippo)+" ");
           
                            print "\n";
                            print $DA;
                            print "\n";
           
                                for($value in $pippo)
                                {
                                float $rounded = `wmRoundoff $value 2`;
                                $DA += ($rounded+" ");
                                }
                       
                                    if(`gmatch $aType "doubleArray"`)
                                    {
                                    $line = (" catchQuiet(`setAttr -type doubleArray " + $item + "." + $itema + " " + $DA + "`);\n");
                                    }
                                    else
                                    {
                                        if(`gmatch $aType "*TdataCompound*"`)
                                        {
                                            for($u=0;$u<size($pippo);$u++)
                                            $line += (" catchQuiet(`setAttr " + $item + "." + $itema +"["+ $u+ "] " + $pippo[$u] + "`);\n");
                                        }
                                        else
                                        {
                                        $line = (" catchQuiet(`setAttr " + $item + "." + $itema + " " + $DA + "`);\n");
                                        }
                                    }
                            $DA = "";
                            }
                            else
                            {
                            //print "\nSTRAIGHT\n";
                            //print $itema;
                            //print "\n";
                            $pip = `getAttr ($item + "." + $itema)`;
                            $line = (" catchQuiet(`setAttr " + $item + "." + $itema + " " + $pip + "`);\n");
                            }
                    }
                $print[$nb++] = $line;
                }
           
            $wireLine = `wmFxSaveWireMap $item`;
            $print[$nb++] = $wireLine;
           
            }
            else
            {
                for($itema in $lista)
                {
                    if(`objExists ($item + "." + $itema)`)
                    {
                   
                        if(`gmatch $itema "*difMesh*"`||`gmatch $itema "*volMesh*"`)
                        {
                        print ("\nlistConnections -p 1 "+$item + "." + $itema+";\n");
                        string $command = ("listConnections -p 1 "+$item + "." + $itema+";\n");
                        string $conn[] = eval($command);
                        if(`size($conn)`)
                        $line = (" catchQuiet(`connectAttr -f " +$conn[0] +" "+ $item + "." + $itema + "`);\n");
                        clear $conn;
                        }
                        else
                        {
                        print ("\ngetAttr -type "+$item + "." + $itema+";\n");
                        $aType = `getAttr -type ($item + "." + $itema)`;
                        //print "\nFOUND\n";
                        //print ($item + "." + $itema);
                        //print "\n";
           
                            if(`gmatch $aType "*doubleArray*"`||`gmatch $aType "*TdataCompound*"`)
                            {
                            print "\nDOUBLE ARRAY\n";
                            //print $itema;
                            //print "\n";
                   
                            $pippo = `getAttr ($item + "." + $itema)`;
                            $DA = (size($pippo)+" ");
           
                            print "\n";
                            print $DA;
                            print "\n";
           
                                for($value in $pippo)
                                {
                                float $rounded = `wmRoundoff $value 2`;
                                $DA += ($rounded+" ");
                                }
                       
                                    if(`gmatch $aType "doubleArray"`)
                                    {
                                    $line = (" catchQuiet(`setAttr -type doubleArray " + $item + "." + $itema + " " + $DA + "`);");
                                    }
                                    else
                                    {
                                    $line = (" catchQuiet(`setAttr " + $item + "." + $itema + " " + $DA + "`);");
                                    }
                            $DA = "";
                            }
                            else
                            {
                            //print "\nSTRAIGHT\n";
                            //print $itema;
                            //print "\n";
                            $pip = `getAttr ($item + "." + $itema)`;
                            $line = (" catchQuiet(`setAttr " + $item + "." + $itema + " " + $pip + "`);");
                            }
                        }
                    }
                $print[$nb++] = $line;
                }
            }
        }
    }

return $print;
}



global proc wmFxExportDef(string $fileName)
{

    string $pose[];
    string $stringAttr;
    $fileId = `fopen $fileName "w"`;
   
    $pose = `wmFxGetDeformersPose`;
       
    for($i = 0; $i < size($pose);$i++)
    {
    fprint $fileId ($pose[$i] + "\n");
    }
   
    fclose $fileId;

}




global proc string[] fingerTendon(string $mesh, int $num)
{


string $axes = "x"; //axes to offset the tendon in
int $axesDir; //positive 1, negative -1
float $value = 2;

string $side;


if(`gmatch $mesh "l_*"`)
{
$axesDir = "-1";
$side = "l_";
}

if(`gmatch $mesh "r_*"`)
{
$axesDir = "1";
$side = "r_";
}

float $offset = (0.1*$num)*$axesDir;

string $name = ($side + "fing_"+$num+"_tendon");


string $curve = ($name+"_CRV");
string $baseCurve = ($name+"_base_CRV");
string $wire = ($name+"_WRD");

string $lo_arm = ($side+"low_arm_twist");
string $wrist = ($side+"hand");
string $hand = ($side+"hand_"+$num);
string $up_fing = ($side+"up_fing_"+$num);
string $mid_fing = ($side+"mid_fing_"+$num);
string $low_fing = ($side+"low_fing_"+$num);
string $low_fing_end = ($side+"low_fing_"+$num+"_end");



//string $finger[] = {$lo_arm, $wrist, $hand, $up_fing, $mid_fing, $low_fing, $low_fing_end};
string $finger[];

if($num>1)
$finger = {$lo_arm, $wrist, $wrist, $up_fing, $mid_fing, $low_fing, $low_fing_end};
else
$finger = {$lo_arm, $wrist, $up_fing, $mid_fing, $low_fing, $low_fing_end};

//=== build reference locators

string $locs[];
string $geoCON[];

for($i=0;$i<size($finger);$i++)
{
    if(!`objExists ($finger[$i]+"_"+($i+1)+"_LOC")`)
    spaceLocator -name ($finger[$i]+"_"+($i+1)+"_LOC");

 catchQuiet(`parent ($finger[$i]+"_"+($i+1)+"_LOC") $finger[$i]`);
setAttr ($finger[$i]+"_"+($i+1)+"_LOC"+".t") 0 0 0;
setAttr ($finger[$i]+"_"+($i+1)+"_LOC"+".r") 0 0 0;
setAttr ($finger[$i]+"_"+($i+1)+"_LOC"+".s") 1 1 1;
setAttr ($finger[$i]+"_"+($i+1)+"_LOC"+".t"+$axes) ($value*$axesDir);

if($i>0)
{
select $mesh ($finger[$i]+"_"+($i+1)+"_LOC");
$geoCON = `geometryConstraint`;
}

getAttr ($finger[$i]+"_"+($i+1)+"_LOC"+".t");
$locs[size($locs)] = ($finger[$i]+"_"+($i+1)+"_LOC");

if(`objExists $geoCON[0]`)
delete $geoCON[0];

if($num >1)
{
if($i==1||$i==2)
setAttr ($finger[$i]+"_"+($i+1)+"_LOC"+".t"+$axes) (`getAttr ($finger[$i]+"_"+($i+1)+"_LOC"+".t"+$axes)`-(2*$offset));
}

if($i==1)
{
setAttr ($finger[$i-1]+"_"+$i+"_LOC"+".t"+$axes) (`getAttr ($finger[$i]+"_"+($i+1)+"_LOC"+".t"+$axes)`-$offset);
}
else
{
setAttr ($finger[$i]+"_"+($i+1)+"_LOC"+".t"+$axes) (`getAttr ($finger[$i]+"_"+($i+1)+"_LOC"+".t"+$axes)`-$offset);
}

}

string $baseLocs[];

for($i=0;$i<size($finger);$i++)
{

    if(!`objExists ($finger[$i]+"_baseLoc_"+($i+1)+"_LOC")`)
    spaceLocator -name ($finger[$i]+"_baseLoc_"+($i+1)+"_LOC");

 catchQuiet(`parent ($finger[$i]+"_baseLoc_"+($i+1)+"_LOC") ($finger[$i]+"_"+($i+1)+"_LOC")`);
setAttr ($finger[$i]+"_baseLoc_"+($i+1)+"_LOC"+".t") 0 0 0;
setAttr ($finger[$i]+"_baseLoc_"+($i+1)+"_LOC"+".r") 0 0 0;
setAttr ($finger[$i]+"_baseLoc_"+($i+1)+"_LOC"+".s") 1 1 1;
setAttr ($finger[$i]+"_baseLoc_"+($i+1)+"_LOC"+".t"+$axes) ((-.2*$axesDir));

$baseLocs[size($baseLocs)] = ($finger[$i]+"_baseLoc_"+($i+1)+"_LOC");
}

//=== build wire curve

string $command = ("curve -name "+$curve+" -d 2 ");

for($item in $locs)
{
parent -w $item;
float $trans[] = `getAttr ($item+".t")`;
$command += ("-p "+$trans[0]+" "+$trans[1]+" "+$trans[2]+" ");
}

eval($command);

//=== build base curve shape

string $command = ("curve -name "+$baseCurve+" -d 2 ");

for($item in $baseLocs)
{
parent -w $item;
float $trans[] = `getAttr ($item+".t")`;
$command += ("-p "+$trans[0]+" "+$trans[1]+" "+$trans[2]+" ");
}

eval($command);


//=== wire

string $elem[] = `wire -gw true -ce 0.1 -w $curve $mesh`;
rename $elem[0] $wire;

connectAttr -f ($baseCurve+".worldSpace[0]") ($curve+"BaseWire.create");

select $baseCurve $finger; skinCluster -tsb -name ($name+"_tendon_baseWire_SKC");
select $finger $curve; skinCluster -tsb -name ($name+"_tendon_wire_SKC");


//=== cleaup

//wireCleanSet $wire 2.5;
delete $locs $baseLocs;


//=== end

return `ls ($curve+"Group") $baseCurve`;

}





// utilities weta/felix 2008

// listFiles
// mostRecent
// mostRecentType
// importSceneForFuckSake
// setDittoSrcWeights
// floodDittoSrcWeights
// fadeDittoSrcWeights
// save_r1_skin (saves skinWeight files for the given creature)
// make_r1 (creates initial skinWeight files and r1 rig for the given creature)
// make_r2 (creates chopped geo and r2 rig for the given creature)
// loadAllSculpts (creates and sets the transforms of sculpt deformers based on previously saved files)
// commentFromTo (comments the lines of a file from a string to a string and creates a new file
// importAnim
// fxSaveAllWmSmooth
// fxSaveAllWmBulge
// fxLoadAllWmSmooth
// fxLoadAllWmBulge
// fxLoadAllWires
// fxSaveAllWires
// fxSaveAllSculpts
// fxSaveAll
// fxSaveJakeHands
// mirror_sculpts
// mirrorHandDMap
// mirrorAllHandDMaps
// fxBindPose
// fxSaveNeytiriHands
// wmFxSprintJointRig

//================================================================================================================
//================================================================================================================
//================================================================================================================
//================================================================================================================
//================================================================================================================
//================================================================================================================
//================================================================================================================
//================================================================================================================

//wmSource("wmExportImportTmpAnim");
//wmSource("wmPose");
//wmPose();


//================================================================================================================
//================================================================================================================
// ==== this returns the most recent file in a directory

global proc string[] listFiles(string $dir, string $suff)
{
string $list[]; clear $list;
string $systemCMD = ("ls "+$dir+"*"+$suff);
string $patate = `system ($systemCMD)`;
string $carote[];
tokenize($patate, "\n", $carote);

for($item in $carote)
{
string $tmp[];
clear $tmp;
tokenize($item, "/", $tmp);
$list[size($list)] = $tmp[size($tmp)-1];
}

return $list;

}

//================================================================================================================
//================================================================================================================
// ==== this returns the most recent file in a directory

global proc string mostRecent(string $dir)
{
string $systemCMD = "ls -ltr "+$dir+" | awk '{print $9}'";
string $patate = `system ($systemCMD)`;
string $carote[];
tokenize($patate, "\n", $carote);

return $carote[size($carote)-1];

}

//================================================================================================================
//================================================================================================================
// ==== this returns the most recent file in a directory, with spcific prefix and suffix


global proc string mostRecentType(string $dir, string $pref, string $suff)
{
string $systemCMD = "ls -ltr "+$dir+$pref+"*"+$suff+" | awk '{print $9}'";
string $patate = `system ($systemCMD)`;
string $carote[];
tokenize($patate, "\n", $carote);

string $file;

return $carote[size($carote)-1];

}

//================================================================================================================
//================================================================================================================
//=== this is to figure out the type of maya file, it returns the new nodes imported

global proc string[] importSceneForFuckSake(string $name)
{

string $transformsBefore[] = `ls -type transform "|*"`;

string $type = "mayaAscii";

if(`gmatch $name "*.mb"`)
$type = "mayaBinary";

if(`gmatch $name "*.asf"`)
$type = "ASF";

string $peperoni[];
string $pistacchi[];

tokenize($name, "/", $peperoni);
tokenize($peperoni[size($peperoni)-1], ".", $pistacchi);

string $rpr = $pistacchi[0];


file -f -import -type $type -rpr $rpr -options "v=0;p=17" $name;

string $transformsAfter[] = `ls -type transform "|*"`;

string $transform[] = stringArrayRemove($transformsBefore, $transformsAfter);

return $transform;
}


//================================================================================================================
//================================================================================================================
//=== to set dittoSrc map values on selected points

global proc setDittoSrcWeights(string $geo, float $newValue)
{


string $shp[] = `listRelatives -c -s $geo`;
string $shape = $shp[0];
wmDitto -asm $shape;

int $pNum = size(`ls -fl ($shape+".vtx["+"*"+"]")`);
string $pts[] = `ls -fl ($shape+".vtx["+"*"+"]")`;
string $selPts[] = `ls -fl -sl`;
string $command = ("setAttr "+$shape+".wmDittoSrc -type \"doubleArray\" "+$pNum+" ");

float $values[] = `getAttr ($shape+".wmDittoSrc")`;

float $num;

for($i=0;$i<$pNum;$i++)
{
string $PTSnum[];
string $PTS[];
tokenize($pts[$i], "[", $PTSnum);
tokenize($PTSnum[1], "]", $PTS);
string $REF = $PTS[0];
$num = $values[$i];

    for($item in $selPts)
    {

    string $ptsnum[];
    string $pts[];
    tokenize($item, "[", $ptsnum);
    tokenize($ptsnum[1], "]", $pts);
    string $ref = $pts[0];

        if(`gmatch $REF $ref`)
        {
        $num = $newValue;
        }
    }

$command+=($num+" ");
}

eval($command);

}
//================================================================================================================
//================================================================================================================
//=== flood dittoSrc map values on all points

global proc floodDittoSrcWeights(string $geo, float $newValue)
{


string $shp[] = `listRelatives -c -s $geo`;
string $shape = $shp[0];
wmDitto -asm $shape;

int $pNum = size(`ls -fl ($shape+".vtx["+"*"+"]")`);
string $command = ("setAttr "+$shape+".wmDittoSrc -type \"doubleArray\" "+$pNum+" ");

for($i=0;$i<$pNum;$i++)
{
$command+=($newValue+" ");
}

eval($command);

}

//================================================================================================================
//================================================================================================================
//=== sets a default faded map for hero ditto pieces, based on iterations (the number of row of points to fade off the map)


global proc fadeDittoSrcWeights(string $geo, int $iterations)
{

floodDittoSrcWeights $geo 1;

string $selection[] = `ls -sl`;
float $increase = (1.00/$iterations);
float $newValue = 0;

string $delete[];
string $shp[] = `listRelatives -c -s $geo`;
string $shape = $shp[0];

select ($shape+".vtx["+"*"+"]");
ConvertSelectionToShellBorder;

for($i=0;$i<$iterations;$i++)
{
sets -name ("sel"+$i) `ls -sl`;
GrowPolygonSelectionRegion;
$delete[size($delete)] = ("sel"+$i);
}

for($i=0;$i<$iterations;$i++)
{
//print ("\nsetting row "+($i+1)+" to value "+$newValue);
select ("sel"+$i);

if($i>0)
select -d ("sel"+($i-1));

setDittoSrcWeights $geo $newValue;
$newValue+=$increase;
}

delete $delete;

select $selection;
print "\nDONE";
}

//================================================================================================================
//================================================================================================================
//=== save_r1_skin

// saves skin weights, to create r1 later
// usage example:
// I've split the creature name in two to include variants f******* naming convention


global proc string save_r1_skin(string $destination[], int $saveMap)
{

file -f -new;

//========== sex sex sex sex sex yoohoooo sex sex sex!!!

string $sex;
string $name;


if(`gmatch $destination[0] "*vatar*"`)
$name = "avatar";

if(`gmatch $destination[0] "*navi*"`)
$name = "navi";

if(`gmatch $destination[1] "male*"`)
$sex = "male";

if(`gmatch $destination[1] "*Male*"`)
$sex = "male";

if(`gmatch $destination[1] "*Female*"`)
$sex = "female";

if(`gmatch $destination[1] "female*"`)
$sex = "female";

//==== named ones

if(`gmatch $destination[0] "tsutey"`||`gmatch $destination[0] "eytukan"`)
{
$name = "navi";
$sex = "male";
}

if(`gmatch $destination[0] "neytiri"`||`gmatch $destination[0] "moat"`)
{
$name = "navi";
$sex = "female";
}

if(`gmatch $destination[0] "graceAvatar"`)
{
$name = "avatar";
$sex = "female";
}

if(`gmatch $destination[0] "jakeAvatar"`)
{
$name = "avatar";
$sex = "male";
}

//======== sex finished, boohooo!!


//=== asf

string $destination_dir = "/proj/avatar/dev/"+$destination[0] +"/"+$destination[1]+"/cre/";
string $destination_asf = ($destination_dir+"asf/");
string $latest_version = `mostRecent $destination_asf`;
string $asf_path = ($destination_asf+$latest_version+"/");
string $asf = `mostRecent $asf_path`;
string $asfFile = ($asf_path+"/"+$asf);

string $asfNodes[] = `importSceneForFuckSake $asfFile`;

//print "\n";
//print $asfNodes;
//print "\n";

//=== mocapGeo

string $destination_dir = "/proj/avatar/dev/"+$destination[0] +"/"+$destination[1]+"/cre/";
string $destination_mocapGeo = ($destination_dir+"mocapGeo/");
string $latest_version = `mostRecent $destination_mocapGeo`;
string $mocapGeo_path = ($destination_mocapGeo+$latest_version+"/");
string $mocapGeo = `mostRecent $mocapGeo_path`;
string $mocapGeoFile = ($mocapGeo_path+"/"+$mocapGeo);

string $mocapGeoNodes[] = `importSceneForFuckSake $mocapGeoFile`;

//print "\n";
//print $mocapGeoNodes;
//print "\n";

//================================================================================================
//========================== hero geo

string $destination_dir = "/proj/avatar/dev/"+$destination[0] +"/"+$destination[1]+"/model/";
string $destination_hero = ($destination_dir+"hero/");
string $heroFile = `mostRecentType $destination_hero $destination[0] "*.ma"`;


string $heroNodes[] = `importSceneForFuckSake $heroFile`;

//print "\n";
//print $heroNodes;
//print "\n";

//================================================================================================
//========================== default skin weights

string $list[] = `ls -type transform "|*"`;
string $command;

$command = ("source \"/proj/avatar/dev/GEN/base/cre/work/felix/skin_weights/"+$name+$sex+"MocapBodyWeight.mel\"");

select $mocapGeoNodes[0];
eval($command);

//========================== hero geo

string $heroGeoList[] = `listRelatives -ad -type transform $heroNodes[0]`;
string $geo[];

for($item in $heroGeoList)
{
if(`gmatch $item ($destination[0]+"*")`)
$geo[size($geo)] = $item;
}

string $heroGeo = $geo[0];

//print "\nhero geo is: ";
//print $heroGeo;
//print "\n";

//=========================== copy skinCluster

select $mocapGeoNodes[0] $heroGeo;
lkCopyCluster 0;
//print "\nweights copied onto hero";

//=========================== save new skinWeights

if($saveMap > 0)
{
// source "wmSaveSoftSkinWeights.mel";
// source "/usr/home/lkraatz/mayaStuff/mel/skinning/skin_paintUI.mel";

string $file = ("/proj/avatar/dev/"+$destination[0] +"/"+$destination[1]+"/cre/scripts/creatureRigScripts/data/skinWeights/"+$heroGeo);
select $heroGeo;
writeSkinClusterFile $file "mel";
//print ("\nsaved: "+$file+".mel");
}

//=============== end

return $heroNodes[0];

}


//================================================================================================================
//================================================================================================================
// make_r1 {"navi", "male2"} 1 1;
//=== make_r1

global proc make_r1(string $destination[], int $saveMap, int $saveRig)
{

string $creatureName = `save_r1_skin $destination $saveMap`;

file -f -new;

string $current_SCENE = `getenv SCENE`;
string $current_SHOT = `getenv SHOT`;
string $name;

//=== run default script

// turn environment variables to current creature

putenv SCENE $destination[0];
putenv SHOT $destination[1];

//=== copying creature rig mel script over from the generic

string $scriptDir = ("/proj/avatar/dev/"+$destination[0]+"/"+$destination[1]+"/cre/scripts/creatureRigScripts");
string $scriptDirCommand = ("system(\"mkdir "+$scriptDir+"\")");
string $script = ("/proj/avatar/dev/"+$destination[0]+"/"+$destination[1]+"/cre/scripts/creatureRigScripts/"+$creatureName+"_creatureRig.mel");
string $originalScript = ("/proj/avatar/dev/jakeAvatar/base/cre/scripts/creatureRigScripts/jakeAvatar_creatureRig.mel");
string $scriptCommand = ("system(\"cp "+$originalScript+" "+$script+"\")");

string $scriptCopy = ("/proj/avatar/dev/"+$destination[0]+"/"+$destination[1]+"/cre/scripts/creatureRigScripts/"+$creatureName+"_creatureRig_r1.mel");

if(!`file -q -ex $scriptDir`)
eval($scriptDirCommand);

if(!`file -q -ex $script`)
eval($scriptCommand);

//=== making a "r1" copy commenting out the lines not used for r1 creation

commentFromTo $script $scriptCopy "SKINNED MODULES" "Vert Copy (do not comment out)";

string $command = ("source \""+$scriptCopy+"\"");
eval($command);

string $fileName = ("\"/proj/avatar/dev/"+$destination[0]+"/"+$destination[1]+"/cre/creatureRig/r1/"+$creatureName+"_creatureRig.ma\"");


//=== end running default script

//=== saving r1 maya file if requested

string $rigDir = ("/proj/avatar/dev/"+$destination[0]+"/"+$destination[1]+"/cre/creatureRig/r1");
string $rigDirCommand = ("system(\"mkdir "+$rigDir+"\")");

if($saveRig >0)
{

    if(!`file -q -ex $rigDir`)
    eval($rigDirCommand);

string $command = ("file -f -op \"v=0\" -typ \"mayaAscii\" -ea "+$fileName);
eval($command);
}

// turn environment variables back to what they were

putenv SCENE $current_SCENE;
putenv SHOT $current_SHOT;


}


//================================================================================================================
//================================================================================================================
//=== make_r2


global proc make_r2(string $destination[], string $creatureName, int $saveRig)
{

file -f -new;

string $current_SCENE = `getenv SCENE`;
string $current_SHOT = `getenv SHOT`;
string $name;

//======= run default script

putenv SCENE $destination[0];
putenv SHOT $destination[1];

string $command = ("source \"/proj/avatar/dev/"+$destination[0]+"/"+$destination[1]+"/cre/scripts/creatureRigScripts/"+$creatureName+"_creatureRig.mel\"");
eval($command);

putenv SCENE $current_SCENE;
putenv SHOT $current_SHOT;

//=== finished running default script



//=== default dittoSrc maps (runs only if they haven't been saved yet)


for($item in `editDisplayLayerMembers -q  heroChunk_geo`)
{

string $shapes[] = `listRelatives -c -s $item`;
string $shape = $shapes[0];

string $dittoFilename = ("/proj/avatar/dev/"+$destination[0]+"/"+$destination[1]+"/cre/scripts/creatureRigScripts/data/dittoWeights/"+$item+".mel");

if(!`file -q -ex $dittoFilename`)
{
fadeDittoSrcWeights $item 5;
select $item;
exportMapAttr {"dittoSrc"} $dittoFilename;
}

}


if($saveRig >0)
{
string $fileDir = ("/proj/avatar/dev/"+$destination[0]+"/"+$destination[1]+"/cre/creatureRig/r2/");
string $fileName = ($fileDir+$creatureName+"_creatureRig.ma");

if(!`file -q -ex $fileDir`)
system ("mkdir "+$fileDir);

string $command = ("file -f -op \"v=0\" -typ \"mayaAscii\" -ea "+$fileName);
eval($command);


//=== save default test bake files

string $newFileDir = ("/proj/avatar/dev/"+$destination[0]+"/"+$destination[1]+"/cre/creatureRig/wip/");
string $newFileName = ($newFileDir+$creatureName+"_creatureRig.ma");

if(!`file -q -ex $newFileDir`)
system ("mkdir "+$newFileDir);

system ("cp "+$fileName+" "+$newFileName);

string $wsgFileName = "/proj/avatar/dev/"+$destination[0]+"/"+$destination[1]+"/cre/scripts/creatureRigScripts/creatureRigBake.wsg";
string $txt = "bake\n (\n processName => \"" + $creatureName + "Bake\",\n creatureName => \"" + $creatureName + "\",\n creature => \"" + $creatureName +  "\",\n amcFile => \"/proj/avatar/dev/neytiri/base/cre/work/julian/motion/rangeOfMotion.amc\",\n amcStart => \"1\",\n amcEnd => \"500\",\n creatureRig => \"/proj/avatar/dev/" + $destination[0] + "/" + $destination[1] + "/cre/creatureRig/wip/" + $creatureName +  "_creatureRig.ma\",\n );\n";

saveTxtFile $wsgFileName {$txt};

}

//=== end
print "\nbasic R2 ready";

}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


global proc loadAllSculpts(string $path, string $mesh)
{

if(size($path)==0)
$path = "/usr/tmp/";

if(!`gmatch $path "*/"`)
$path = ($path+"/");

string $suff = "sculpt";
string $creation;
string $names[] = `listFiles $path ""`;

for($item in $names)
{
string $command = ("source \""+$path+$item+"\"");

    if(!`objExists ($item+"_"+$suff)`)
    {
    $creation = ("select "+$mesh+"; mySculpt "+$item+" "+"\"\"");
    eval($creation);
    }

eval($command);
//sculptCleanSet ($item+"_sculpt") $mesh;
}

print "DONE";

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


global proc string commentFromTo(string $fileName, string $newFile, string $from, string $to)
{


string $getLines[];
string $matchFrom = ("*"+$from+"*");
string $matchTo = ("*"+$to+"*");
string $command = ("system(\"cp "+$fileName+" "+$newFile+"\")");
string $line;

if(size($newFile)==0)
$newFile = $fileName;
else
eval($command);

$fileId = `fopen $fileName "r"`;
string $nextLine = `fgetline $fileId`;

//====loop
    while(size($nextLine)>0)
    {
   
    //fprint $fileId $nextLine;
    //print ("\n"+$nextLine+"\n");
   
    $getLines[`size $getLines`] =  $nextLine ;
    $nextLine = `fgetline $fileId`;
    }
   
fclose $fileId;


$fileId = `fopen $newFile "w"`;

    for($i = 0; $i < size($getLines);$i++)
    {
        $line = $getLines[$i];
       
        if(`gmatch $getLines[$i] $matchFrom`)
        $line = ("/*"+$getLines[$i]);
       
        if(`gmatch $getLines[$i] $matchTo`)
        $line = ("*/"+$getLines[$i]);
       
    fprint $fileId $line;
    }
   
fclose $fileId;

return $newFile;

}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

global proc importAnim(string $tmpAnimFile)
{
   
    if (!`file -q -exists $tmpAnimFile`)
        error("wmExportImportTmpAnimTr: File doesn't exist: " + $tmpAnimFile);
       
    evalEcho("file -import -type \"WetaAsciiAnim\" \"" + $tmpAnimFile + "\"");
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

global proc fxSaveAllWmSmooth(string $mesh, string $dir)
{
string $wmSmooths[] = `listConnections -type wmSmooth $mesh`;
string $shape[] = `listRelatives -c -s $mesh`;

if(!`gmatch $dir "*/"`)
$dir = ($dir+"/");

for($item in $wmSmooths)
{
select $item;
exportPose ($dir+$item) 0;
wmSaveDMap -f ($dir+$item+".dam") -d "smoothMap" -s $shape[0] -ws;
}

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


global proc fxSaveAllWmBulge(string $mesh, string $dir)
{
string $wmSmooths[] = `listConnections -type wmBulge $mesh`;
string $shape[] = `listRelatives -c -s $mesh`;

if(!`gmatch $dir "*/"`)
$dir = ($dir+"/");

for($item in $wmSmooths)
{
select $item;
exportPose ($dir+$item) 0;
wmSaveDMap -f ($dir+$item+".dam") -d "bulgeMap" -s $shape[0] -ws;
}

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

global proc fxLoadAllWmSmooth(string $path, string $mesh)
{

string $shape[] = `listRelatives -c -s $mesh`;

if(!`gmatch $path "*/"`)
$path = ($path+"/");

string $creation;
string $names[] = `listFiles $path ""`;

for($item in $names)
{

    if(!`objExists $item`)
    {
    $creation = ("select "+$mesh+"; rename `wmSmooth` "+$item+";");
    if(!`gmatch $item "*.dam"`)
    eval($creation);
    }

    string $command = ("source \""+$path+$item+"\";");
    if(!`gmatch $item "*.dam"`)
    eval($command);

    string $command = ("select "+$item+"; wmLoadDMap -f \"" + $path+$item + ".dam\" -d \"smoothMap\" -ws -s "+$shape[0]+";");
    if(!`gmatch $item "*.dam"`)
    eval($command);
}

print "DONE";

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


global proc fxLoadAllWmBulge(string $path, string $mesh)
{

string $shape[] = `listRelatives -c -s $mesh`;


if(!`gmatch $path "*/"`)
$path = ($path+"/");

string $creation;
string $names[] = `listFiles $path ""`;

for($item in $names)
{

    if(!`objExists $item`)
    {
   
    $creation = ("select "+$mesh+"; rename `wmBulge` "+$item+";");
   
    if(!`gmatch $item "*.dam"`)
    eval($creation);
    }


    string $command = ("source \""+$path+$item+"\";");
    if(!`gmatch $item "*.dam"`)
    eval($command);


    string $command = ("select "+$item+"; wmLoadDMap -f \"" + $path+$item + ".dam\" -d \"bulgeMap\" -ws -s "+$shape[0]+";");
    if(!`gmatch $item "*.dam"`)
    eval($command);
}

print "DONE";

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


global proc fxLoadAllWires(string $path, string $mesh)
{

//string $shape[] = `listRelatives -c -s $mesh`;


if(!`gmatch $path "*/"`)
$path = ($path+"/");

string $creation;
string $names[] = `listFiles $path ""`;
print "\n";
print $names;
print "wires found indirectory\n";

for($item in $names)
{
string $name = substring($item, 1, (size($item)-4));

    if(`objExists $name`)
    {
    string $command = ("select "+$name+"; wmLoadMMap -f \"" + $path+$name + ".mam\" -m \"weightList[0].weights\" -s "+$mesh+";");
    eval($command);
    }
}

print "DONE";

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


global proc fxSaveAllWires(string $mesh, string $dir)
{
string $history[] = `listHistory $mesh`;
string $wires[] = `ls -type wire $history`;

if(!`gmatch $dir "*/"`)
$dir = ($dir+"/");

for($item in $wires)
{
string $command = ("select "+$item+"; wmSaveMMap -f \"" + $dir+$item + "\" -m \"weightList[0].weights\" -s "+$mesh+";");
print ("\n"+$command);
eval($command);
}

print "DONE";

}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

global proc fxSaveAllSculpts(string $mesh, string $dir)
{

if(!`gmatch $dir "*/"`)
$dir = ($dir+"/");

string $suff = "sculpt";
string $history[] = `listHistory $mesh`;
string $list[] = `ls -type $suff $history`;
string $sculpt_list[];
int $num = size($suff)+1;
string $names[];


for($item in $list)
{
    if(`gmatch $item ("*"+$suff)`)
    $sculpt_list[size($sculpt_list)] = $item;
}


for($item in $sculpt_list)
{
$names[size($names)] = substring($item, 1, (size($item)-$num));
}


for($item in $names)
{
select `ls ($item+"*")`; select -d `ls -type double3 -sl`;
exportPose ($dir+$item) 0;
}

print "DONE";

}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


global proc fxSaveJakeHands()
{
fxSaveAllSculpts l_handHero "/proj/avatar/dev/jakeAvatar/base/cre/scripts/creatureRigScripts/data/sculptDeformers/l_hand";
fxSaveAllSculpts r_handHero "/proj/avatar/dev/jakeAvatar/base/cre/scripts/creatureRigScripts/data/sculptDeformers/r_hand";
fxSaveAllWires l_handHero "/proj/avatar/dev/jakeAvatar/base/cre/scripts/creatureRigScripts/data/wireDeformers/l_hand";
fxSaveAllWires r_handHero "/proj/avatar/dev/jakeAvatar/base/cre/scripts/creatureRigScripts/data/wireDeformers/r_hand";
fxSaveAllWmBulge l_handHero "/proj/avatar/dev/jakeAvatar/base/cre/scripts/creatureRigScripts/data/wmBulge/l_hand";
fxSaveAllWmBulge r_handHero "/proj/avatar/dev/jakeAvatar/base/cre/scripts/creatureRigScripts/data/wmBulge/r_hand";
fxSaveAllWmSmooth l_handHero "/proj/avatar/dev/jakeAvatar/base/cre/scripts/creatureRigScripts/data/wmSmooth/l_hand";
fxSaveAllWmSmooth r_handHero "/proj/avatar/dev/jakeAvatar/base/cre/scripts/creatureRigScripts/data/wmSmooth/r_hand";
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


global proc mirror_sculpts(string $geo)
{

string $list[] = `ls -sl`;
string $names[];

for($item in $list)
{
string $pippo = substring($item, 1, (size($item)-7));
$names[size($names)] = $pippo;
}


    for($name in $names)
    {
    string $neutralName = substring($name,2,size($name));
    string $rName = ("r"+$neutralName);

    string $orig[] = `listConnections ($name+"_sculpt.startPosition")`;
    string $sculptGeo[] = `listConnections ($name+"_sculpt.sculptObjectGeometry")`;
    string $group[] = `listRelatives -ap $sculptGeo[0]`;
    string $parent[] = `listRelatives -ap $group[0]`;

print "\n";
print "orig is: ";
print $orig[0];
print "\n";
print "sculpt geo is: ";
print $sculptGeo[0];
print "\n";
print "parent is: ";
print $parent[0];
print "\n";


    string $neutralOrig = substring($orig[0],2,size($orig[0]));
    string $neutralSculptGeo = substring($sculptGeo[0],2,size($sculptGeo[0]));
    string $neutralGroup = substring($group[0],2,size($group[0]));
    string $neutralParent = substring($parent[0],2,size($parent[0]));

    string $rOrig = ("r"+$neutralOrig);
    string $rSculptGeo = ("r"+$neutralSculptGeo);
    string $rGroup = ("r"+$neutralGroup);
    string $rParent = ("r"+$neutralParent);
   
    //===== sculpt attributes
   
    float $envelope = `getAttr ($name+"_sculpt.envelope")`;
    float $disp = `getAttr ($name+"_sculpt.maximumDisplacement")`;
    float $dist = `getAttr ($name+"_sculpt.dropoffDistance")`;
   
    spaceLocator -name ($name+"_grp_TMP");
    select $group[0] ($name+"_grp_TMP"); delete `parentConstraint`; delete `scaleConstraint`;
    spaceLocator -name ($name+"_orig_TMP");
    select $orig[0] ($name+"_orig_TMP"); delete `parentConstraint`; delete `scaleConstraint`;
    spaceLocator -name ($name+"_sculptgeo_TMP");
    select $sculptGeo[0] ($name+"_sculptgeo_TMP"); delete `parentConstraint`; delete `scaleConstraint`;
   
    parent ($name+"_sculptgeo_TMP") ($name+"_orig_TMP") ($name+"_grp_TMP");
    select ($name+"_grp_TMP");
    group -name ($name+"_pippo_TMP"); xform -os -piv 0 0 0;
    setAttr ($name+"_pippo_TMP.sx") -1;

   
    //==== create sculpt
   
    select $geo;
    string $command = ("mySculpt "+$rName+" "+$rParent);
    eval($command);

    parent -w ($name+"_grp_TMP");


    select ($name+"_grp_TMP") $rGroup; delete `parentConstraint`; delete `scaleConstraint`;
    select ($name+"_orig_TMP") $rOrig; delete `parentConstraint`; delete `scaleConstraint`;
    select ($name+"_sculptgeo_TMP") $rSculptGeo; delete `parentConstraint`; delete `scaleConstraint`;

    float $scale[] = `getAttr ($group[0]+".s")`;
    setAttr ($rGroup+".s") $scale[0]  $scale[1]  $scale[2];
   
    float $scale[] = `getAttr ($sculptGeo[0]+".s")`;
    setAttr ($rSculptGeo+".s") $scale[0]  $scale[1]  $scale[2];

    setAttr ($rName+"_sculpt.envelope") $envelope;
    setAttr ($rName+"_sculpt.maximumDisplacement") $disp;
    setAttr ($rName+"_sculpt.dropoffDistance") $dist;
   
    delete ($name+"_*_TMP");

//=== replicate connections

    string $POC[] = `listConnections -type pointConstraint ($group[0]+".tx")`;
    string $PAC[] = `listConnections -type parentConstraint ($group[0]+".tx")`;
    string $ORC[] = `listConnections -type orientConstraint ($group[0]+".rx")`;
    string $SCC[] = `listConnections -type pointConstraint ($group[0]+".sx")`;
   
    string $conCommand;
   
    if(size($ORC)>0)
    {
   
    int $offset = 0;
   
        if(`getAttr ($ORC[0]+".offsetX")`!=0)
        $offset = 1;
        if(`getAttr ($ORC[0]+".offsetY")`!=0)
        $offset = 1;
        if(`getAttr ($ORC[0]+".offsetZ")`!=0)
        $offset = 1;
   
    string $targets[] = `listConnections -type transform ($ORC[0]+".target["+"*"+"].targetRotate")`;
    string $rTargets[];
   
        for($item in $targets)
        {
        string $pippo = substring($item,2,size($item));
        $rTargets[size($rTargets)] = ("r"+$pippo);
        }
   
        if($offset >0)
        $conCommand = ("orientConstraint -mo;");
        else
        $conCommand = ("orientConstraint;");
   
    select $rTargets $rGroup;
    eval($conCommand);
    }


    }

}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

global proc mirrorHandDMap(string $name)
{


string $type;
string $pip[] = `ls -st $name`;
string $attrs[];

if(`gmatch $pip[1] "wmSmooth"`)
{
$type = "smooth";
$attrs = {"envelope","smoothMode","iter","quality","qualiTrigger","blur","mult","add","clampLo","clampHi","testVert","volume","volumeBlur"};
}

if(`gmatch $pip[1] "wmBulge"`)
{
$type = "bulge";
$attrs = {"envelope","bulgeMode","blur","multBeforeRemap","multAfterRemap"};
}

//string $poses[] = `ls "*Bindpose"`;
//wmAssumePoseCmd $poses;

string $mirrorSide;


string $orig;
string $copy;
string $neutralName = substring($name, 3, size($name));
string $side = substring($name, 1, 1);

if(`gmatch $side "l"`)
{
$mirrorSide="r";
}
else
{
$mirrorSide="l";
}

$orig = ($side+"_"+$neutralName);
$copy = ($mirrorSide+"_"+$neutralName);
string $mapName = ("/tmp/"+$name+".dam");

select $orig;
wmSaveDMap -f $mapName -d ($type+"Map") -s ($side+"_handHero");
setAttr -lock 0 ($mirrorSide+"_handHero.sx");
setAttr ($mirrorSide+"_handHero.sx") -1;

if(!`objExists $copy`)
{
select ($mirrorSide+"_handHero");
string $command = ("rename `" +$pip[1]+"` "+$copy);
eval($command);
}

select $copy;
wmLoadDMap -f $mapName -d ($type+"Map") -s ($mirrorSide+"_handHero");
setAttr ($copy+".initalize") 1;
setAttr ($mirrorSide+"_handHero.sx") 1;

for($i=0;$i<size($pip);$i++)
{
    for($item in $attrs)
    {
    setAttr ($copy+"."+$item) `getAttr ($orig+"."+$item)`;
    print ("\ncopying attr "+$copy+"."+$item +" to match " + $orig+"."+$item);
    }
}

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

global proc mirrorAllHandDMaps(string $side)
{

string $hand = ($side+"_handHero");
string $list[] = `listHistory $hand`;

string $smooth[] = `ls -type wmSmooth $list`;
string $bulge[] = `ls -type wmBulge $list`;

string $allDef[] = stringArrayCatenate($smooth, $bulge);

for($item in $allDef)
{
mirrorHandDMap $item;
}


}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


global proc fxBindPose()
{
string $poses[] = `ls "*Bindpose"`;
wmAssumePoseCmd $poses;

}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


global proc fxSaveNeytiriHands()
{
//fxSaveAllSculpts l_handHero "/proj/avatar/dev/neytiri/base/cre/scripts/creatureRigScripts/data/sculptDeformers/l_hand";
//fxSaveAllSculpts r_handHero "/proj/avatar/dev/neytiri/base/cre/scripts/creatureRigScripts/data/sculptDeformers/r_hand";
fxSaveAllWires l_handHero "/proj/avatar/dev/neytiri/base/cre/scripts/creatureRigScripts/data/wireDeformers/l_hand";
fxSaveAllWires r_handHero "/proj/avatar/dev/neytiri/base/cre/scripts/creatureRigScripts/data/wireDeformers/r_hand";
fxSaveAllWmBulge l_handHero "/proj/avatar/dev/neytiri/base/cre/scripts/creatureRigScripts/data/wmBulge/l_hand";
fxSaveAllWmBulge r_handHero "/proj/avatar/dev/neytiri/base/cre/scripts/creatureRigScripts/data/wmBulge/r_hand";
fxSaveAllWmSmooth l_handHero "/proj/avatar/dev/neytiri/base/cre/scripts/creatureRigScripts/data/wmSmooth/l_hand";
fxSaveAllWmSmooth r_handHero "/proj/avatar/dev/neytiri/base/cre/scripts/creatureRigScripts/data/wmSmooth/r_hand";
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

global proc wmFxSprintJointRig (string $name)
{
spaceLocator -name ($name+"_spring_1_LOC");
spaceLocator -name ($name+"_spring_2_LOC");
spaceLocator -name ($name+"_spring_3_LOC");
spaceLocator -name ($name+"_spring_4_LOC");
spaceLocator -name ($name+"_spring_LOC");

select ($name+"_spring_1_LOC") ($name+"_spring_2_LOC") ($name+"_spring_3_LOC") ($name+"_spring_4_LOC") ;

group -name ($name+"_spring_GRP");

setAttr ($name+"_spring_1_LOC.t") 0 5 -5;
setAttr ($name+"_spring_2_LOC.t") 0 5 5;
setAttr ($name+"_spring_3_LOC.t") 0 -5 -5;
setAttr ($name+"_spring_4_LOC.t") 0 -5 5;

joint -name ($name+"_spring_JNT");

select ($name+"_spring_1_LOC") ($name+"_spring_2_LOC") ($name+"_spring_3_LOC") ($name+"_spring_4_LOC") ($name+"_spring_LOC");
delete `pointConstraint`;
select ($name+"_spring_1_LOC") ($name+"_spring_2_LOC") ($name+"_spring_3_LOC") ($name+"_spring_4_LOC") ($name+"_spring_LOC");
wmSpringConstraint -name ($name+"_SPC");

select ($name+"_spring_LOC") ($name+"_spring_JNT");
pointConstraint;

setAttr ($name+"_SPCShape.iterations") 10;
setAttr ($name+"_SPCShape.stiffness[0]") 10;
setAttr ($name+"_SPCShape.stiffness[1]") 10;
setAttr ($name+"_SPCShape.stiffness[2]") 10;
setAttr ($name+"_SPCShape.stiffness[3]") 10;
setAttr ($name+"_SPCShape.damping[0]") 1;
setAttr ($name+"_SPCShape.damping[1]") 1;
setAttr ($name+"_SPCShape.damping[2]") 1;
setAttr ($name+"_SPCShape.damping[3]") 1;
setAttr ($name+"_SPCShape.mass") 1;

}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




source "generateChannelMenu.mel" ;
// source "/usr/home/fbalbas/maya/scripts/fx_utilities.mel";

//===============================================================================
//===============================================================================
//===============================================================================
//===============================================================================

global proc fxMakeMslSticky(string $name, string $nurb)
{

//=== figure out stuff

string $shape[] = `listRelatives -c -s ($name+"_MSL")`;
string $locators[] = `listConnections -type transform $shape[0]`;
string $parentLoc;
string $crvLoc;
string $inBetweenLocs[];
string $crv = ($name+"_upv_CRV");
string $newCurve = ($name+"_ref_CRV");

//=== upv curve duplicate stuff

string $shp[] = `listRelatives -f -c -s  $crv`;
string $pip[] = `listConnections -s 1 -d 0 -t "pointConstraint" -et 1 $shp[0]`;
string $wsn[];
string $upvLocs[];
int $spns = `getAttr ($crv+".spans")`;

for($n=0;$n<($spns+2);$n++)
{
string $conn[] = `listConnections ($crv+".controlPoints["+$n+"].xValue")`;
$wsn[size($wsn)] = $conn[0];
}

for($n=1;$n<(size($wsn)-1);$n++)
{
string $conn[] = `listConnections ($wsn[$n]+".target[0].targetTranslate")`;
string $papa[] = `listRelatives -ap $conn[0]`;
$upvLocs[size($upvLocs)] = $papa[0];
}

string $parentThese[];

//=== end upv curve duplicate stuff


    for($item in $locators)
    {
   
        if(`gmatch $item "*crv*"`)
        {
        $crvLoc = $item;
        }
        else
        {
            if(`gmatch $item "*inbetween*"`)
            {
            string $papa[] = `listRelatives -ap $item`;
            $inBetweenLocs[size($inBetweenLocs)] = $papa[0];
            }
            else
            {
            $parentLoc = $item;
            }
        }
    }

string $LOCS[];
$LOCS[0] = $parentLoc;

for($item in $inBetweenLocs)
$LOCS[size($LOCS)] = $item;

$LOCS[size($LOCS)] = $crvLoc;

//==== project reference curve onto nurb geo
//string $projCrv[] = `projectCurve -ch false -rn false -un  true  -tol 0.01 $crv $nurb`;


if(!`objExists $newCurve`)
{
select -cl;
string $papa[] = `listRelatives -ap $crv`;
parent -w $crv;
duplicate -name $newCurve $crv;
parent $crv $papa[0];
//parent $newCurve
select $newCurve $nurb; CreateWrap;
$parentThese[size($parentThese)] = $newCurve;
string $bases[] = `ls -type transform ($nurb+"Base*")`;

    if(size($bases))
    {
        for($item in $bases)
        $parentThese[size($parentThese)] = $item;
    }
}
else
{
print "\nthis muscle is already sticky\n";
}

//==== create reference locators stuck to new curve

if(!`objExists  ($name+"_MSL.sticky")`)
addAttr -k 1 -ln "sticky"  -at double  -min 0 -max 1 -dv 0 ($name+"_MSL");

dgdirty -a;

    for($i=0;$i<size($inBetweenLocs);$i++)
    {
//=== create if it doesn't exist

        if(!`objExists  ($name+"_"+$i+"_sticky_LOC")`)
        {
        duplicate -name ($name+"_"+$i+"_sticky_LOC") $inBetweenLocs[$i];
        setAttr ($name+"_"+$i+"_sticky_LOC.inheritsTransform") 0;
        delete `listRelatives -f -c -type transform ($name+"_"+$i+"_sticky_LOC")`;
        select $inBetweenLocs[$i]; pickWalk -d down;
        string $pip[] = `pickWalk -d left`;
        transformLimits -tz 0 0 -etz 1 1 $pip[0];
        }
//=== check for connections
   
        if(`objExists ($name+"_"+$i+"_sticky_LOC_mpa")`)
        delete ($name+"_"+$i+"_sticky_LOC_mpa");
       
//=== connect to new curve

    select ($name+"_"+$i+"_sticky_LOC") $newCurve;
    closestValueOnCurve 0;

//=== point constraint

   
    string $poc[] = `listConnections -type pointConstraint $inBetweenLocs[$i]`;
    string $pocAttr[] = `listAttr -ud $poc[0]`;
   
        if(size($pocAttr)<2)
        {
        select ($name+"_"+$i+"_sticky_LOC") $inBetweenLocs[$i];
        pointConstraint;
        string $poc[] = `listConnections -type pointConstraint -s 1 -d 0 $inBetweenLocs[$i]`;
        string $pocAttr[] = `listAttr -ud $poc[0]`;
        invConnect ($poc[0]+"."+$pocAttr[1])  ($poc[0]+"."+$pocAttr[0]);
        connectAttr -f ($name+"_MSL.sticky") ($poc[0]+"."+$pocAttr[1]);
//=== upv curve duplicate stuff
        select ($name+"_"+$i+"_sticky_LOC") $upvLocs[$i];
        pointConstraint;
        string $poc[] = `listConnections -type pointConstraint $upvLocs[$i]`;
        string $pocAttr[] = `listAttr -ud $poc[0]`;
        invConnect ($poc[0]+"."+$pocAttr[1])  ($poc[0]+"."+$pocAttr[0]);
        connectAttr -f ($name+"_MSL.sticky") ($poc[0]+"."+$pocAttr[1]);
//=== end upv curve duplicate stuff
        }
   
    }

//=== add attr

string $msl = ($name+"_MSL");
select $msl;
string $mslGroupName = `fxUpdateMsl 0`;
string $grpName = ($mslGroupName+"_GRP");

    if(!`objExists ($grpName+"."+$msl)`)
    {
    addAttr -ln $msl -at double -min 0 -max 1 $grpName;
    }

 catchQuiet(`connectAttr -f ($grpName+"."+$msl) ($msl+".sticky")`);

select ($name+"_MSL");
string $mslName = `fxUpdateMsl 0`;

for($item in $parentThese)
 catchQuiet(`parent $item ($mslName+"_GRP")`);

print ("\n"+$msl+" is now sticky");

}


//============================================================
//============================================================
//============================================================
//============================================================

global proc string[] fxAveragePos()
{

string $list[] = `ls -sl`;
$quantity = `size($list)`;
$end = $quantity - 1;
$half = $quantity / 2;
int $i;
string $item;

string $cons[];

    for( $i = 1; $i < $end; $i++ )
    {
    $item = $list[$i];
    select $list[0] $list[$end] $item;
    pointConstraint -name ($item + "_POC");
    $cons[size($cons)] = ($item + "_POC");
    float $first = ((1.00 / $end) * $i);
    setAttr ($item + "_POC." + $list[0] + "W0") (1 - $first);
    setAttr ($item + "_POC." + $list[$end] + "W1") $first;

    }

select -cl;
return $cons;

}

//============================================================
//============================================================
//============================================================
//============================================================

// usage: select an nurbs isoparm and locators
global proc string iso2locRig(string $name, int $attachments)
{
//cycleCheck -e off;
string $surf_CRV = ($name+"_CRV");
string $groupName = ($name+"_GRP");
string $list[] = `ls -sl`;
string $iso = $list[0];
string $mslSurfaces[];



string $locators[];
string $parents[];
string $tmp[];
tokenize($list[0], ".", $tmp);
string $nurb = $tmp[0];
string $v0 = "v[0]";
string $v1 = "v[1]";
string $u0 = "u[0]";
string $u1 = "u[1]";

if($tmp[1] == $v0)
$iso = ($nurb+".v[0.001]");
if($tmp[1] == $v1)
$iso = ($nurb+".v[0.999]");

if($tmp[1] == $u0)
$iso = ($nurb+".u[0.001]");
if($tmp[1] == $u1)
$iso = ($nurb+".u[0.999]");



string $invisible[];
string $curveLoc;
string $curveParentLoc;
string $tmpLocs[];
string $groupInbetweens[];
string $group[] = {($name+"_CRV")};
string $lockY[];
string $selGroup[];

duplicateCurve -name $surf_CRV -ch 1 -rn 0 -local 0 $iso;

for($l=1;$l<size($list);$l++)
{
$locators[size($locators)] = $list[$l];
}

//=== initial locators pos

string $init;
for($dude in $locators)
{
float $trans[] = `xform -q -a -ws -t $dude`;
$init += ("xform -a -ws -t "+$trans[0]+" "+$trans[1]+" "+$trans[2]+" "+$dude+" ; ");
float $rot[] = `xform -q -ro $dude`;
$init += ("xform -ro "+$rot[0]+" "+$rot[1]+" "+$rot[2]+" "+$dude+" ; ");
}

for($l=0;$l<size($locators);$l++)
{

    duplicate -name ($locators[$l]+"_pos_LOC") $locators[$l];
   
    string $newName = ($name+"_"+$locators[$l]);
    string $crvUpvLoc = ($newName+"_crv_upv_LOC");
    $curveLoc = ($newName+"_crv_LOC");
    $curveParentLoc = ($newName+"_crv_parent_LOC");
    $group[size($group)] = $curveParentLoc;
    $selGroup[size($selGroup)] = $curveParentLoc;
    $groupInbetweens[size($groupInbetweens)] = $crvUpvLoc;
    $invisible[size($invisible)] = $curveLoc;
    $invisible[size($invisible)] = $crvUpvLoc;
    duplicate -name $curveLoc $locators[$l];
    duplicate -name $curveParentLoc $locators[$l];
    duplicate -name $crvUpvLoc $locators[$l];
    parent $curveLoc $curveParentLoc;
    select $curveParentLoc $surf_CRV; closestValueOnCurve 0;
    select $crvUpvLoc $surf_CRV; closestValueOnCurve 0;
    shadingNode -name ($crvUpvLoc + "_ADD") -asUtility plusMinusAverage;
    connectAttr -f ($curveParentLoc+"_mpa.uValue") ($crvUpvLoc+"_ADD.input1D[0]");
    connectAttr -f  ($crvUpvLoc+"_ADD.output1D") ($crvUpvLoc+"_mpa.uValue");
    setAttr ($crvUpvLoc+"_ADD.input1D[1]") 0.05;


    spaceLocator -name ($curveParentLoc+"_upv_crv_LOC");
    select $curveParentLoc ($curveParentLoc+"_upv_crv_LOC"); delete `pointConstraint`;
    select ($curveParentLoc+"_upv_crv_LOC") $surf_CRV; closestValueOnCurve 0;
    connectAttr -f ($curveParentLoc+"_mpa.uValue") ($curveParentLoc+"_upv_crv_LOC_mpa.uValue");
   
    string $inBetweenLocs[];
    string $inBetweenSurfaceLocs[];
    string $inBetweenPosLocs[];
   
    string $inBetweenLocsCRV[];
    string $inBetweenSurfaceLocsCRV[];
    string $inBetweenPosLocsCRV[];

        for($a=0;$a<$attachments;$a++)
        {
        $inBetweenLocs[size($inBetweenLocs)] = ($newName+"_inbetween_"+($a+1)+"_LOC");
        $inBetweenSurfaceLocs[size($inBetweenSurfaceLocs)] = ($newName+"_inbetweenSurface_"+($a+1)+"_LOC");
        $inBetweenPosLocs[size($inBetweenPosLocs)] = ($newName+"_inbetweenPos_"+($a+1)+"_LOC");
        $invisible[size($invisible)] = ($newName+"_inbetween_"+($a+1)+"_LOCShape");
        $invisible[size($invisible)] = ($newName+"_inbetweenSurface_"+($a+1)+"_LOCShape");
        $invisible[size($invisible)] = ($newName+"_inbetweenPos_"+($a+1)+"_LOCShape");
        $groupInbetweens[size($groupInbetweens)] = ($newName+"_inbetween_"+($a+1)+"_LOC");
        $groupInbetweens[size($groupInbetweens)] = ($newName+"_inbetweenSurface_"+($a+1)+"_LOC");
        duplicate -name $inBetweenLocs[$a] $locators[$l];
        duplicate -name $inBetweenSurfaceLocs[$a] $locators[$l];
        duplicate -name $inBetweenPosLocs[$a] $locators[$l];

//=== xtra rig for orient

        $inBetweenLocsCRV[size($inBetweenLocsCRV)] = ($newName+"_inbetween_crv_"+($a+1)+"_LOC");
        $inBetweenSurfaceLocsCRV[size($inBetweenSurfaceLocsCRV)] = ($newName+"_inbetween_crvSurface_"+($a+1)+"_LOC");
        $inBetweenPosLocsCRV[size($inBetweenPosLocsCRV)] = ($newName+"_inbetween_crvPos_"+($a+1)+"_LOC");
        $invisible[size($invisible)] = ($newName+"_inbetween_crv_"+($a+1)+"_LOCShape");
        $invisible[size($invisible)] = ($newName+"_inbetween_crvSurface_"+($a+1)+"_LOCShape");
        $invisible[size($invisible)] = ($newName+"_inbetween_crvPos_"+($a+1)+"_LOCShape");
        $groupInbetweens[size($groupInbetweens)] = ($newName+"_inbetween_crv_"+($a+1)+"_LOC");
        $groupInbetweens[size($groupInbetweens)] = ($newName+"_inbetween_crvSurface_"+($a+1)+"_LOC");
        duplicate -name $inBetweenLocsCRV[$a] $locators[$l];
        duplicate -name $inBetweenSurfaceLocsCRV[$a] $locators[$l];
        duplicate -name $inBetweenPosLocsCRV[$a] $locators[$l];
        }
       
    select $curveParentLoc $inBetweenLocs $locators[$l];
    fxAveragePos;

    select ($curveParentLoc+"_upv_crv_LOC") $inBetweenLocsCRV ($locators[$l]+"_pos_LOC");
    fxAveragePos;
   
    $group[size($group)] = ($curveParentLoc+"_upv_crv_LOC");
   
    string $upvLocs[];
   
        for($a=0;$a<$attachments;$a++)
        {
        select $nurb $inBetweenSurfaceLocs[$a]; geometryConstraint -name ($inBetweenSurfaceLocs[$a]+"_GEC");
        select $nurb $inBetweenSurfaceLocs[$a]; normalConstraint -weight 1 -aimVector 0 1 0 -upVector 1 0 0 -worldUpType "object" -worldUpObject $curveLoc;
        select $inBetweenLocs[$a] $inBetweenSurfaceLocs[$a]; pointConstraint -name ($inBetweenSurfaceLocs[$a]+"_POC");
        parent $inBetweenPosLocs[$a] $inBetweenSurfaceLocs[$a];
        setAttr ($inBetweenPosLocs[$a]+".r") 0 0 0;
        setAttr ($inBetweenPosLocs[$a]+".t") 0 0 0;
        setAttr ($inBetweenPosLocs[$a]+".s") 1 1 1;
        select $inBetweenLocs[$a] $inBetweenPosLocs[$a]; pointConstraint -name ($inBetweenPosLocs[$a]+"_POC");
        transformLimits -ty 0 100 -ety 1 0 $inBetweenPosLocs[$a];
        $lockY[size($lockY)] = ($inBetweenPosLocs[$a]+"_POC.offsetY");
       
//=== new locators for the upv curve
        $upvLocs[size($upvLocs)] = $inBetweenPosLocsCRV[$a];
        select $nurb $inBetweenSurfaceLocsCRV[$a]; geometryConstraint -name ($inBetweenSurfaceLocsCRV[$a]+"_GEC");
        select $nurb $inBetweenSurfaceLocsCRV[$a]; normalConstraint -weight 1 -aimVector 0 1 0 -upVector 1 0 0 -worldUpType "object" -worldUpObject ($curveParentLoc+"_upv_crv_LOC");
        select $inBetweenLocsCRV[$a] $inBetweenSurfaceLocsCRV[$a]; pointConstraint -name ($inBetweenSurfaceLocsCRV[$a]+"_POC");
        parent $inBetweenPosLocsCRV[$a] $inBetweenSurfaceLocsCRV[$a];
        setAttr ($inBetweenPosLocsCRV[$a]+".r") 0 0 0;
        setAttr ($inBetweenPosLocsCRV[$a]+".t") 0 0 0;
        setAttr ($inBetweenPosLocsCRV[$a]+".s") 1 1 1;
        select $inBetweenLocsCRV[$a] $inBetweenPosLocsCRV[$a]; pointConstraint -name ($inBetweenPosLocsCRV[$a]+"_POC");
        transformLimits -ty 0 1 -ety 1 0 $inBetweenPosLocsCRV[$a];
        }

   
   

//==== build muscle primitive (wmMuslce)

    evalDeferred("autoLoadPlugin(\"\", \"wmMuscle\", \"wmMuscle\")");

   
        for($a=0;$a<($attachments+2);$a++)
        {
        $tmpLocs[size($tmpLocs)] =  ("TMP_"+$newName+"_"+$a+"_LOC");
        spaceLocator -name ("TMP_"+$newName+"_"+$a+"_LOC");
        setAttr ("TMP_"+$newName+"_"+$a+"_LOC.tz") (1*($a+1));
        }
       
    select $tmpLocs; rename `wmMuscle -c $attachments` ($newName+"_MSL");
   
    string $lockAttrs[] = {"tx","ty","tz","rx","ry","rz","sx","sy","sz"};

        for($item in $lockAttrs)
        setAttr -lock true -keyable false ($newName + "_MSL."+$item);
        for($item in $lockAttrs)
        setAttr -lock true -keyable false ($newName + "_MSL."+$item);
   
    $mslSurfaces[size($mslSurfaces)] = ($newName+"_MSL");
    $selGroup[size($selGroup)] = ($newName+"_MSL");
    setAttr ($newName+"_MSLShape.guideOffset") 1;
    setAttr ($newName+"_MSLShape.topTiltMode") 0;
    setAttr ($newName+"_MSLShape.botTiltMode") 0;
   
    string $attachLocs[] = {$curveLoc};
   
        for($a=0;$a<size($inBetweenPosLocs);$a++)
        $attachLocs[size($attachLocs)] = $inBetweenPosLocs[$a];
   
    $attachLocs[size($attachLocs)] = $locators[$l];
   
    spaceLocator -name "trash"; select $attachLocs[1] "trash"; delete `orientConstraint`;
    select "trash" $attachLocs[0]; delete `orientConstraint`; delete "trash";
    select $attachLocs[size($attachLocs)-2] $attachLocs[size($attachLocs)-1]; delete `orientConstraint`;
   
   
        for($a=0;$a<size($attachLocs);$a++)
        {
        parent $tmpLocs[$a] $attachLocs[$a];
        setAttr ($tmpLocs[$a]+".r") 0 0 0;
        setAttr ($tmpLocs[$a]+".t") 0 0 0;
        setAttr ($tmpLocs[$a]+".s") 1 1 1;
        string $command = ("connectAttr -f "+ $attachLocs[$a]+".worldMatrix[0] "+$newName+"_MSLShape.attach["+$a+"].attMat");
        eval($command);
        }
       
    delete $tmpLocs;


//=== orient stuff

setAttr ($curveLoc+".r") 0 0 0;
select $curveLoc $locators[$l]; delete `orientConstraint`;
duplicate -name ($name+"_"+$locators[$l]+"_parent_LOC") $locators[$l];
duplicate -name ($name+"_"+$locators[$l]+"_upv_LOC") $locators[$l];
duplicate -name ($name+"_"+$locators[$l]+"_orient_LOC") $locators[$l];
parent ($name+"_"+$locators[$l]+"_upv_LOC") ($name+"_"+$locators[$l]+"_parent_LOC");
setAttr ($name+"_"+$locators[$l]+"_upv_LOC.ty") -2;
select $inBetweenLocs[size($inBetweenLocs)-1] ($name+"_"+$locators[$l]+"_orient_LOC");
delete `aimConstraint -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "object" -worldUpObject ($name+"_"+$locators[$l]+"_upv_LOC")`;
select ($name+"_"+$locators[$l]+"_orient_LOC") ($name+"_"+$locators[$l]+"_parent_LOC"); delete `orientConstraint`;
setAttr ($name+"_"+$locators[$l]+"_upv_LOC.ty") 2;
       
    select ($curveParentLoc+"_upv_crv_LOC");
    for($n=0;$n<size($upvLocs);$n++)
    select -add $upvLocs[$n];
   
    select -add ($locators[$l]+"_pos_LOC");
    $group[size($group)] = `cluster_curve ($newName+"_upv_CRV") 2`;
    $group[size($group)] = ($newName+"_upv_CRV");

    clear $upvLocs;
   
    parent ($locators[$l]+"_pos_LOC") ($name+"_"+$locators[$l]+"_parent_LOC");
       
//========== START AND END ORIENT

    select ($newName+"_upv_CRV") ($name+"_"+$locators[$l]+"_orient_LOC");
    tangentConstraint -aimVector 0 0 -1 -upVector -1 0 0 -worldUpType "object" -worldUpObject ($name+"_"+$locators[$l]+"_upv_LOC");

    select ($newName+"_upv_CRV") $curveLoc;
    tangentConstraint -aimVector 0 0 1 -upVector 1 0 0 -worldUpType "object" -worldUpObject $crvUpvLoc;

//========== START AND END ORIENT


    parent $locators[$l] ($name+"_"+$locators[$l]+"_orient_LOC");
    parent ($name+"_"+$locators[$l]+"_orient_LOC") ($name+"_"+$locators[$l]+"_parent_LOC");
    setAttr ($locators[$l]+".r") 0 0 0;

    string $shape[] = `listRelatives -c -s $locators[$l]`;
    $invisible[size($invisible)] = $shape[0];
    $invisible[size($invisible)] = ($name+"_"+$locators[$l]+"_upv_LOCShape");
    $invisible[size($invisible)] = ($name+"_"+$locators[$l]+"_orient_LOCShape");
    $parents[size($parents)] = ($name+"_"+$locators[$l]+"_parent_LOC");
    $selGroup[size($selGroup)] = ($name+"_"+$locators[$l]+"_parent_LOC");

/*
//======= extra curve



string $xtraCRV =  ($newName + "_xtra_CRV");
curve -name $xtraCRV -d 2 -p 0 0 0 -p 1 0 0 -p 2 0 0;

$groupInbetweens[size($groupInbetweens)] = $xtraCRV;

//=== clusters

select ($xtraCRV+".cv[0]");
string $merdaFritta[] = `cluster`;
rename $merdaFritta[1] ($newName + "_1_CLH");

select ($xtraCRV+".cv[1]");
string $merdaFritta[] = `cluster`;
rename $merdaFritta[1] ($newName + "_2_CLH");

select ($xtraCRV+".cv[2]");
string $merdaFritta[] = `cluster`;
rename $merdaFritta[1] ($newName + "_3_CLH");

//=== clusters position

select  $curveParentLoc ($newName + "_1_CLH");
delete `pointConstraint`;
parent ($newName + "_1_CLH") $curveParentLoc;

select  $locators[$l] ($newName + "_3_CLH");
delete `pointConstraint`;
parent ($newName + "_3_CLH") $locators[$l];

//select $nurb ($newName + "_2_CLH");
//string $gec[] =  `geometryConstraint`;
select ($newName + "_1_CLH") ($newName + "_3_CLH") ($newName + "_2_CLH");
delete  `pointConstraint`;

//select ($newName + "_1_CLH") ($newName + "_3_CLH") ($newName + "_2_CLH");
//parentConstraint -mo -name ($newName + "_2_clh_PAC");
//invConnect ($newName + "_2_clh_PAC."+$newName + "_1_CLHW0") ($newName + "_2_clh_PAC."+$newName + "_3_CLHW1");

parent ($newName + "_2_CLH") ($newName + "_3_CLH");
setAttr ($newName + "_3_CLHShape.v") 0;
setAttr ($newName + "_1_CLHShape.v") 0;

string $lockAttrs[] = {"tx","ty","tz","rx","ry","rz","sx","sy","sz", "v"};

for($item in $lockAttrs)
setAttr -lock true -keyable false ($newName + "_3_CLH."+$item);
for($item in $lockAttrs)
setAttr -lock true -keyable false ($newName + "_1_CLH."+$item);


for($pirla in $inBetweenLocs)
{
//select $xtraCRV $pirla; geometryConstraint -name ($pirla+"_GEC");
//delete `listConnections -type pointConstraint ($pirla+".tx")`;
//delete ($pirla+"_GEC");
//select $pirla $xtraCRV ; closestValueOnCurve 0;
}

*/



//=========================
//=========================

clear $inBetweenLocs;
clear $inBetweenSurfaceLocs;
clear $inBetweenPosLocs;
clear $tmpLocs;
clear $inBetweenLocsCRV;
clear $inBetweenSurfaceLocsCRV;
clear $inBetweenPosLocsCRV;

}


for($item in $invisible)
setAttr ($item+".v") 0;

select -cl;

if(!`objExists $groupName`)
group -name $groupName $group $groupInbetweens $mslSurfaces;
else
parent $group $groupInbetweens $mslSurfaces $groupName;

select -cl;

group -name ($name+"_crv_locs_GRP") `ls ($name+"_*_crv_parent_LOC")`;

/*
///==== cluster curvature contraint

if(!`objExists ($groupName+".curvature")`)
addAttr -k 1 -ln "curvature"  -at double  -min 0 -max 1 $groupName;

string $list[] = `ls ($name +"*_2_clh_PAC")`;
string $attrs[];
for($inter in $list)
{
string $allAttrs[] = `listAttr $inter`;

for($item in $allAttrs)
{
if(`gmatch $item "*CLHW0"`)
$attrs[size($attrs)] = ($inter+"."+$item);
}

}

for($item in $attrs)
connectAttr -f ($groupName+".curvature") $item;

//============ make sticky


for($item in $mslSurfaces)
{
string $stringName = substring($item, 1, (size($item)-4));
fxMakeMslSticky $stringName $nurb;
}

*/
//=== linking nodes

for($item in $mslSurfaces)
connectAttr -f ($groupName+".v") ($item+".v");


//=== create attrs

//fxCopyMsl $name;

string $mirrorSide = "l_";
if(`gmatch $name "l_*"`)
$mirrorSide = "r_";

string $mirrorLocators[];
string $mirrorInit;

for($dude in $locators)
$mirrorLocators[size($mirrorLocators)] = ($mirrorSide+(substring($dude, 3, size($dude))));

for($d=0;$d<size($mirrorLocators);$d++)
{
float $trans[] = `xform -q -a -ws -t $locators[$d]`;
$mirrorInit += ("xform -a -ws -t "+($trans[0]*-1)+" "+$trans[1]+" "+$trans[2]+" "+$mirrorLocators[$d]+" ; ");
float $rot[] = `xform -q -ro $locators[$d]`;
$mirrorInit += ("xform -ro "+$rot[0]+" "+($rot[1]*-1)+" "+($rot[2]*-1)+" "+$mirrorLocators[$d]+" ; ");
}


if(!`objExists ($groupName+".mirrorInit")`)
addAttr -ln "mirrorInit"  -dt "string" $groupName;

setAttr -type "string" ($groupName+".mirrorInit") $mirrorInit;

if(!`objExists ($groupName+".offset")`)
{
addAttr -ln "offset"  -at double -dv 0 $groupName;
}

for($item in $lockY)
connectAttr -f ($groupName+".offset") $item;


if(!`objExists ($groupName+".init")`)
{
addAttr -ln "init"  -dt "string"  $groupName;
}

setAttr -type "string" ($groupName+".init") $init;

if(!`objExists ($groupName+".attachment")`)
{
addAttr -ln "attachment"  -dt "string"  $groupName;
}


if(!`objExists ($groupName+".msl")`)
{
addAttr -ln "msl"  -dt "string"  $groupName;
}

if(!`objExists ($groupName+".sections")`)
addAttr -ln "sections" -at long  -dv $attachments $groupName;

if(!`objExists ($groupName+".pose")`)
{
addAttr -ln "pose"  -dt "string"  $groupName;
}

for($i=0;$i<size($locators);$i++)
{
       
if(!`objExists ($groupName+".loc"+$i)`)
addAttr -ln ("loc"+$i) -dt "string"  $groupName;

setAttr -type "string" ($groupName+".loc"+$i) $locators[$i];

}

setAttr -type "string" ($groupName+".attachment") $iso;
setAttr -type "string" ($groupName+".msl") $name;

//=== end

if(!`objExists ($name+"_SEL")`);
sets -name ($name+"_SEL") $selGroup;

select $selGroup; sets -add ($name+"_SEL");

select $curveParentLoc;
string $command = ("getAttr "+$curveParentLoc+"_mpa.uValue");
eval($command);
return $surf_CRV;

}

//============================================================
//============================================================
//============================================================
//============================================================

global proc string[] fxCopyMsl(string $name)
{

string $selection[] = `ls -sl`;
string $groupName = ($name+"_GRP");


string $allAttrs[] = `listAttr -ud $groupName`;
string $mslLocs[];
string $list[];

    for($item in $allAttrs)
    {
        if(`gmatch $item "loc*"`)
        {
        string $porcatroiachepalleinventarsinominuovidivariabili = `getAttr ($name+"_GRP."+$item)`;
        $mslLocs[size($mslLocs)] = $porcatroiachepalleinventarsinominuovidivariabili;
        $list[size($list)] = ($name + "_"+$porcatroiachepalleinventarsinominuovidivariabili+"_MSL");
        }
    }

if(`gmatch $selection[0] "*_GRP"`)
if(`objExists ($selection[0]+".msl")`)
{
print "\ngotcha";
select $list[0];
}

if(!`objExists ($groupName+".attachment")`)
{
addAttr -ln "attachment"  -dt "string"  $groupName;
}

if(!`objExists ($groupName+".msl")`)
{
addAttr -ln "msl"  -dt "string"  $groupName;
}

setAttr -type "string" ($groupName+".msl") $name;

//=== curve origin

string $history[] = `listHistory ($name+"_CRVShape")`;
string $curveNode[] = `ls -type curveFromSurfaceIso $history`;

float $value = `getAttr ($curveNode[0]+".isoparmValue")`;
int $intDir = `getAttr ($curveNode[0]+".isoparmDirection")`;
string $dir = "v";

if($intDir == 1)
$dir = "u";

string $nurb[] = `listConnections -type nurbsSurface $curveNode[0]`;
string $iso = ($nurb[0]+"."+$dir+"["+$value+"]");

setAttr -type "string" ($groupName+".attachment") $iso;


//=== original locators

string $locators[];
string $parLocs[];

    for($i=0;$i<size($list);$i++)
    {
    string $conns[] = `listConnections -type transform ($list[$i]+"Shape")`;
    select $conns;
    string $pip[] = `ls -sl`;
    $locators[size($locators)] = $pip[size($pip)-1];
       
    if(!`objExists ($groupName+".loc"+$i)`)
    addAttr -ln ("loc"+$i) -dt "string"  $groupName;

    setAttr -type "string" ($groupName+".loc"+$i) $pip[size($pip)-1];

    }

//=== sections

string $list[] = `ls ($name+"*"+$locators[0]+"_MSLShape")`;
int $attachments = `getAttr ($list[0]+".numCS")`;

if(!`objExists ($groupName+".sections")`)
addAttr -ln "sections" -at long  -dv $attachments $groupName;

setAttr ($groupName+".sections") $attachments ;

//=== locator parents

//=== store pose
//=== store pose
//=== store pose
//=== store pose
//=== store pose
//=== store pose

string $mslStrings[];

for($item in $locators)
{
//string $lista[] = `ls `;
$mslStrings[size($mslStrings)] = ($name+"_"+$item+"_MSLShape");
}

//=== exporting poses for crv_LOC pos and muscle sections

//select ($name+"*LOC_mpa")  ($name+"*parent_LOC")($name+"*_2_CLH") $locators ($name+"*_MSLShape") ($name+"_GRP");
select -cl;
for($item in $locators)
{
select -add ($name+"_"+$item+"*_LOC_mpa") ($name+"_"+$item+"*parent_LOC") ($name+"_"+$item+"_upv_LOC") $item ($name+"_"+$item+"*_MSLShape");
}

if(`objExists ($name+"*sticky*")`)
select -d ($name+"*sticky*");

for($item in $mslStrings)
{
int $sect = `getAttr ($item+".numCS")`;

    for($i=0;$i<$sect;$i++)
    {
    select -add ($item+".state[0].section["+$i+"]");
    }
}


string $POSE = `exportPose ("/tmp/"+$name) 0`;

//========================================
//========================================
//=== store mirror info

string $fromSide;
string $toSide;
string $baseName = $name;

if(`gmatch $name "r_*"`)
{
$fromSide = "r_";
$toSide = "l_";
$baseName = substring($name, 3, size($name));
}

if(`gmatch $name "l_*"`)
{
$fromSide = "l_";
$toSide = "r_";
$baseName = substring($name, 3, size($name));
}

string $init = `getAttr ($groupName+".init")`;
string $allWords[];
tokenize($init, " ", $allWords);

string $MirrorPOSE = `exportPose ("/tmp/"+$toSide+$baseName) 1`;
system("replace "+$fromSide+" "+$toSide+" -- /tmp/"+$toSide+$baseName);
//string $com = ("replace \" "+$fromSide+"\" \" "+$toSide+"\" -- /tmp/"+$toSide+$baseName);
//system($com);
//string $com = ("replace \"_"+$fromSide+"\" \"_"+$toSide+"\" -- /tmp/"+$toSide+$baseName);
//system($com);

exportPose ("/tmp/"+$toSide+$baseName+"_init") 1;
system("replace "+$fromSide+" "+$toSide+" -- /tmp/"+$toSide+$baseName+"_init");
//string $com = ("replace \" "+$fromSide+"\" \" "+$toSide+"\" -- /tmp/"+$toSide+$baseName);
//system($com);
//string $com = ("replace \"_"+$fromSide+"\" \"_"+$toSide+"\" -- /tmp/"+$toSide+$baseName);
//system($com);


//========================================
//========================================

//=== store pose in the top node

if(!`objExists ($groupName+".pose")`)
{
addAttr -ln "pose"  -dt "string"  $groupName;
}

setAttr -type "string" ($groupName+".pose") $POSE;
select $groupName;


//=== cleanup

string $listLock[] =
{
"tx",
"ty",
"tz",
"rx",
"ry",
"rz",
"sx",
"sy",
"sz"
};

for($item in $listLock)
setAttr -lock true -keyable false ($groupName+"."+$item);

if(size($selection))
select $selection;

print ("\n"+$name +" STORED");

return {$name, $nurb[0], $iso, $attachments};

}


//==================================================================
//==================================================================
//==================================================================


global proc fxBuildMsl()
{

//=== selected node needs to be the group

string $list[] = `ls -sl`;

for($msl in $list)
{

    string $groupName = $msl;

//=== get the needed attributes

    string $attachment = `getAttr ($groupName+".attachment")`;
    string $name = `getAttr ($groupName+".msl")`;
    int $sections = `getAttr ($groupName+".sections")`;

//=== figure out the locators

    string $locators[];
    string $allAttrs[] = `listAttr -ud $groupName`;

        for($a in $allAttrs)
        {
            if(`gmatch $a "loc*"`)
            {
            string $loc = `getAttr ($groupName+"."+$a)`;
            $locators[size($locators)] = $loc;
            }
        }

//=== create locators if they don't exist

        for($item in $locators)
        {
            if(!`objExists $item`)
            spaceLocator -name $item;
        }

//=== create muscle

    string $init = `getAttr ($groupName+".init")`;
    string $comIn = ("source \"/tmp/"+$name+"_init\"");
    if(size($init))
    eval($init);
    else
    eval($comIn);
   
    select $attachment $locators;
    iso2locRig $name $sections;

//=== read setup

    string $command =`getAttr ($groupName+".pose")`;

        if(!`size($command)`)
        {
        $command = ("source \"/tmp/"+$name+"\"");
        }

    eval($command);


//=== make sticky if necessary

//=== figure out the muscles to make stick

    string $stickThis[];

        for($a in $allAttrs)
        {
            if(`gmatch $a "*MSL"`)
            {
            $stickThis[size($stickThis)] = $a;
            }
        }


        for($item in $stickThis)
        {
        select $item; fxStick;
        }


    select $list;
}

}


//=======================================================
//=======================================================
//=======================================================
//=======================================================


global proc redoIso2locRig(string $name, int $storedInfo)
{

fxCopyMsl $name;

//==============
//=== deleting current muscles

fxStripMsl;

//=============
//=== recreate muscles

fxBuildMsl;
   
//==== end

print ("\ndone rebuilding "+$name+" muscle");

}

//=======================================================
//=======================================================
//=======================================================
//=======================================================


global proc fxSaveSelectedMsl()
{
string $name;
string $list[] = `ls -sl`;
    for($item in $list)
    {
        if(`gmatch $item "*_MSL"`)
        {
        select $item;
        $name = `fxUpdateMsl 0`;
        }
       
        if(`gmatch $item "*_GRP"`)
        {
            if(`objExists ($item+".msl")`)
            {
            $name = `getAttr ($item+".msl")`;
            string $allAttrs[] = `listRelatives -type transform $item`;
           
                for($c in $allAttrs)
                    if(`gmatch $c "*_MSL"`)
                    select $c;
            $name = `fxUpdateMsl 0`;
            }
        }
   
    fxCopyMsl $name;
    }
   
}


//=======================================================
//=======================================================
//=======================================================
//=======================================================


global proc fxStripMsl()
{

    for($item in `ls -sl`)
    {
    select $item;
    string $name = `fxUpdateMsl 0`;
   
    select `ls -type transform ($name+"_*")`; select -d ($name+"_GRP");
    delete `ls -sl`;

    select ($name+"_GRP");
    print ("\n"+$name +" stripped successfully");
    }

}

//=======================================================
//=======================================================
//=======================================================
//=======================================================

global proc fxStick()
{
string $list[] = `ls -sl`;

for($item in $list)
{
select $item;
string $name = `fxUpdateMsl 0`;
string $groupName = ($name+"_GRP");
string $iso = `getAttr ($name+"_GRP.attachment")`;
string $tmp[];

tokenize($iso, ".", $tmp);
string $nurb = $tmp[0];

string $stringName = substring($item, 1, (size($item)-4));
fxMakeMslSticky $stringName $nurb;
}

select $list;
}


//=======================================================
//=======================================================
//=======================================================
//=======================================================

global proc fxResetStringMsl()
{
string $list[] = `ls -sl`;

if(`gmatch $list[0] "*.cv*"`)
{
string $tmp[];
string $tmp[];
string $merda[];
string $secca[];
tokenize($list[0], ".", $tmp);
tokenize($list[0], "[", $merda);
tokenize($merda[1], "]", $secca);
setAttr ($tmp[0]+"Shape.state[0].section["+$secca[0]+"].translate") -type double3 0 0 0;
setAttr ($tmp[0]+"Shape.state[0].section["+$secca[0]+"].rotate") -type double3 0 0 0;
setAttr ($tmp[0]+"Shape.state[0].section["+$secca[0]+"].scale") -type double3 1 1 1;
}
else
{
    for($item in $list)
    {

    int $sections = `getAttr ($item+"Shape.numCS")`;

        for($i=0;$i<$sections;$i++)
        {
        setAttr ($item+"Shape.state[0].section["+$i+"].translate") -type double3 0 0 0;
        setAttr ($item+"Shape.state[0].section["+$i+"].rotate") -type double3 0 0 0;
        setAttr ($item+"Shape.state[0].section["+$i+"].scale") -type double3 1 1 1;
        }
    }
}

select $list;
}


//=======================================================
//=======================================================
//=======================================================
//=======================================================

global proc string fxUpdateMsl(int $doit)
{

string $name;
string $groupName;
string $iso;
string $list[] = `ls -sl`;

    if(`gmatch $list[0] "*_MSL"`)
    {

    string $locs[];
    clear $locs;


//=== figure out current muscle string stuff

    int $crap = `getAttr  ($list[0]+"Shape.numCS")`;
    int $attachments = ($crap+2);
    string $startLoc;
    string $crvLoc;

        for($i=0;$i<$attachments;$i++)
        {
        string $loc[] = `listConnections -s 1 -d 0 ($list[0]+".attach["+$i+"].attMat")`;
        $locs[size($locs)] = $loc[0];
        }

    int $ref = size($locs[0]);

            for($item in $locs)
            {
                if(size($item)<$ref)
                $startLoc = $item;
       
                if(`gmatch $item "*crv*"`)
                {
                string $papa[] = `listRelatives -ap $item`;
                if(`gmatch $papa[0] "*LOC"`)
                $crvLoc = $papa[0];
                else
                $crvLoc = $item;
                }
            }

//=== find if there are any other muscle strings

    string $mpa[] = `listConnections -s 1 -d 0 ($crvLoc+".t")`;
    string $crv[] = `listConnections -s 1 -d 0 ($mpa[0]+".geometryPath")`;
    string $allMpas[] = `listConnections -s 0 -d 1 ($crv[0]+"Shape.worldSpace[0]")`;
    string $crvParents[];
    string $allCrvLocs[];
    string $locators[];

        for($item in $allMpas)
        {
        string $conns[] = `listConnections -type transform -s 0 -d 1 ($item+".allCoordinates")`;

            for($con in $conns)
                if(`gmatch $con "*parent*"`||`gmatch $con "*_crv_LOC"`)
                $crvParents[size($crvParents)] = $con;
            }

        for($item in $crvParents)
        {

            if(!`gmatch $item  "*_crv_LOC"`)
            {
            string $sun[] = `listRelatives -c -type transform $item`;
            string $figlio;
   
                for($item in $sun)
                {
                    if(`gmatch $item "*crv_LOC"`)
                    $allCrvLocs[size($allCrvLocs)] = $item;
                }
            }
            else
            {
            $allCrvLocs[size($allCrvLocs)] = $item;
            }
        }
   
    string $mslStrings[];

        for($i=0;$i<size($allCrvLocs);$i++)
        {
        string $tmp[] = `listConnections $allCrvLocs[$i]`;

            for($item in $tmp)
                if(`gmatch $item "*MSL"`)
                $mslStrings[size($mslStrings)] = $item;
            }


        for($item in $mslStrings)
        {
        string $locs[];
        clear $locs;
            for($i=0;$i<$attachments;$i++)
            {
            string $loc[] = `listConnections -s 1 -d 0 ($item+".attach["+$i+"].attMat")`;
            $locs[size($locs)] = $loc[0];
            }

        int $ref = size($locs[0]);

            for($item in $locs)
            {
                if(size($item)<$ref)
                $locators[size($locators)] = $item;
            }
        }

    string $crvFromSurfNode[] = `listConnections ($crv[0]+"Shape.create")`;

    float $isoValue = `getAttr ($crvFromSurfNode[0]+".isoparmValue")`;
    int $isoDir = `getAttr ($crvFromSurfNode[0]+".isoparmDirection")`;
    string $isoUV = "v";

        if($isoDir>0)
        $isoUV = "u";

    string $nurb[] = `listConnections -s 1 -d 0 ($crvFromSurfNode[0]+".inputSurface")`;


    string $daddio[];

        for($i=0;$i<size($locators);$i++)
        {
        string $daddy[] = `listRelatives -ap $locators[$i]`;
        $daddio[size($daddio)] = $daddy[0];
        parent -w $locators[$i];
        }

    select $locators;
    string $init = `exportPose ("/tmp/"+$name+"_init") 0`;

        for($i=0;$i<size($locators);$i++)
        parent $locators[$i] $daddio[$i];

//==== and the name is...

    $name = substring($crv[0], 1, (size($crv[0])-4));
    $groupName = ($name+"_GRP");
    $iso = ($nurb[0]+"."+$isoUV+"["+$isoValue+"]");


//=== create attrs

        if(!$doit==0)
        {

            if(!`objExists ($groupName+".init")`)
            addAttr -ln "init"  -dt "string"  $groupName;
        setAttr -type "string" ($groupName+".init") $init;

            if(!`objExists ($groupName+".attachment")`)
            addAttr -ln "attachment"  -dt "string"  $groupName;
        setAttr -type "string" ($groupName+".attachment") $iso;


            if(!`objExists ($groupName+".msl")`)
            addAttr -ln "msl"  -dt "string"  $groupName;
        setAttr -type "string" ($groupName+".msl") $name;

            if(!`objExists ($groupName+".sections")`)
            addAttr -ln "sections" -at long $groupName;
        setAttr ($groupName+".sections") $crap;

            if(!`objExists ($groupName+".pose")`)
            addAttr -ln "pose"  -dt "string"  $groupName;

            for($i=0;$i<size($locators);$i++)
            {
                if(!`objExists ($groupName+".loc"+$i)`)
                addAttr -ln ("loc"+$i) -dt "string"  $groupName;
            setAttr -type "string" ($groupName+".loc"+$i) $locators[$i];
            }
   
        select -cl;
   
            for($item in $mslStrings)
            {
            string $papa[] = `listRelatives -ap $item`;
                if(!`gmatch $papa[0] $groupName`)
                parent $item $groupName;
            }
        }
    }
    else
    {
   
        if(`gmatch $list[0] "*_GRP"`)
        {
            if(`objExists ($list[0]+".msl")`)
            {
            $groupName = $list[0];
            $name = `getAttr ($groupName+".msl")`;
            $iso = `getAttr ($groupName+".attachment")`;
            }
        }

    }
   
select $list;
return $name;
print ($name+" updated");
}

//=======================================================
//=======================================================
//=======================================================
//=======================================================

global proc fxAllignStringMsl()
{
string $list[] = `ls -sl`;

    if(`gmatch $list[0] "*.cv*"`)
    {
    string $tmp[];
    string $tmp[];
    string $merda[];
    string $secca[];
    tokenize($list[0], ".", $tmp);
    tokenize($list[0], "[", $merda);
    tokenize($merda[1], "]", $secca);

    spaceLocator -name ref;

    setAttr ($tmp[0]+"Shape.state[0].section["+$secca[0]+"].translate") -type double3 0 0 0;
    setAttr ($tmp[0]+"Shape.state[0].section["+$secca[0]+"].rotate") -type double3 0 0 0;
    setAttr ($tmp[0]+"Shape.state[0].section["+$secca[0]+"].scale") -type double3 1 1 1;
    }
    else
    {
        for($item in $list)
        {

        int $sections = `getAttr ($item+"Shape.numCS")`;

            for($i=0;$i<$sections;$i++)
            {
            setAttr ($item+"Shape.state[0].section["+$i+"].translate") -type double3 0 0 0;
            setAttr ($item+"Shape.state[0].section["+$i+"].rotate") -type double3 0 0 0;
            setAttr ($item+"Shape.state[0].section["+$i+"].scale") -type double3 1 1 1;
            }
        }
    }

select $list;
}

//=======================================================
//=======================================================
//=======================================================
//=======================================================
//=======================================================
//=======================================================
//=======================================================
//=======================================================

global proc fxMirrorMsl(string $name)
{
string $fromSide;
string $toSide;
string $baseName = $name;

if(`gmatch $name "r_*"`)
{
$fromSide = "r_";
$toSide = "l_";
$baseName = substring($name, 3, size($name));
}

if(`gmatch $name "l_*"`)
{
$fromSide = "l_";
$toSide = "r_";
$baseName = substring($name, 3, size($name));
}

string $fromFile = ("/tmp/"+$fromSide+$baseName);
string $toFile = ("/tmp/"+$toSide+$baseName);
string $fromGroup = ($fromSide+$baseName+"_GRP");
string $toGroup = ($toSide+$baseName+"_GRP");

//==== copy group and change attrs

string $children[] = `listRelatives -f -type transform -c $fromGroup`;
select $fromGroup;

if(size($children))
fxSaveSelectedMsl;

duplicate -name $toGroup $fromGroup;

string $children[] = `listRelatives -f -type transform -c $toGroup`;
if(size($children))
delete $children;

if(!`objExists ($toSide+"side")`)
group -empty -name ($toSide+"side");

parent $toGroup ($toSide+"side");

string $allAttr[] = `listAttr -ud $toGroup`;

for($a in $allAttr)
{

string $type = `getAttr -type ($toGroup+"."+$a)`;

    if(`gmatch $a ($fromSide+"*")`)
    {
        string $newAttr;
        string $tokens[];
        tokenize($a, $fromSide, $tokens);
       

        if(`gmatch $a ("*_"+$fromSide+"*")`)
        {
        $newAttr = ($tokens[0]+"_"+$toSide+$tokens[1]);
        if(!`objExists ($toGroup+"."+$a)`)
        renameAttr ($toGroup+"."+$a) $newAttr;
        }
        else
        {
        renameAttr ($toGroup+"."+$a) ($toSide+(substring($a, 3, size($a))));
        string $newAttr = ($toSide+(substring($a, 3, size($a))));
        }
    }
   

    if(`gmatch $type "string"`)
    {
        if(`gmatch $a "pose"`)
        {
        print ("\npose: looking for file /tmp/"+$toSide+$baseName);
           
            if(`filetest -f ("/tmp/"+$toSide+$baseName)`)
            {
            string $tmpFile = ("/tmp/"+$toSide+$baseName);
            $fileId = `fopen $tmpFile "r"`;

            string $nextLine = `fgetline $fileId`;
            string $attr=$nextLine;
            //====loop
                while(size($nextLine)>0)
                {
                $nextLine = `fgetline $fileId`;
                $attr+=$nextLine;
                }
               
            setAttr -type "string" ($toGroup+"."+$a) $attr;
            }
            else
            {
            setAttr -type "string" ($toGroup+"."+$a) "";
            }
        }
        else
        {
            if(`gmatch $a "init"`)
            {
            string $mirrorInit = `getAttr ($fromGroup+".mirrorInit")`;
            setAttr -type "string" ($toGroup+"."+$a) $mirrorInit;
            }
            else
            {
            string $tmp = `getAttr ($toGroup+"."+$a)`;
            if(`gmatch $tmp ($fromSide+"*")`)
            setAttr -type "string" ($toGroup+"."+$a) ($toSide+substring($tmp, 3, size($tmp)));
            }
        }
    }   
}

//=== build it

select $toGroup;
fxBuildMsl;

}

//============================================================================================
//============================================================================================
//============================================================================================
//============================================================================================
//============================================================================================
//============================================================================================
//============================================================================================


global proc fxMirrorSelectedMsls()
{
string $list[] = `ls -sl`;
    for($item in $list)
    {
    select $item;
    string $name = `fxUpdateMsl 0`;
    fxMirrorMsl $name;
    }
}

//============================================================================================
//============================================================================================
//============================================================================================


global proc fxFlipStringMsl(string $attr)
{
string $list[] = `ls -sl`;

if(`gmatch $list[0] "*.cv*"`)
{
string $tmp[];
string $tmp[];
string $merda[];
string $secca[];
tokenize($list[0], ".", $tmp);
tokenize($list[0], "[", $merda);
tokenize($merda[1], "]", $secca);

float $oldValue = `getAttr ($tmp[0]+"Shape.state[0].section["+$secca[0]+"]."+$attr)`;

if(`gmatch $attr "rotate*"`)
setAttr ($tmp[0]+"Shape.state[0].section["+$secca[0]+"]."+$attr) ($oldValue+=180);
if(`gmatch $attr "translate*"`)
setAttr ($tmp[0]+"Shape.state[0].section["+$secca[0]+"]."+$attr) ($oldValue*-1);
if(`gmatch $attr "scale*"`)
setAttr ($tmp[0]+"Shape.state[0].section["+$secca[0]+"]."+$attr) ($oldValue*-1);

}
else
{
    for($item in $list)
    {

    int $sections = `getAttr ($item+"Shape.numCS")`;

        for($i=0;$i<$sections;$i++)
        {
            float $oldValue = `getAttr ($item+"Shape.state[0].section["+$i+"]."+$attr)`;

            if(`gmatch $attr "rotate*"`)
            setAttr ($item+"Shape.state[0].section["+$i+"]."+$attr) ($oldValue+=180);
            if(`gmatch $attr "translate*"`)
            setAttr ($item+"Shape.state[0].section["+$i+"]."+$attr) ($oldValue*-1);
            if(`gmatch $attr "scale*"`)
            setAttr ($item+"Shape.state[0].section["+$i+"]."+$attr) ($oldValue*-1);
        }
    }
}

select $list;
}


//============================================================================================
//============================================================================================
//============================================================================================


global proc fxOffsetStringMsl(string $attr)
{
string $list[] = `ls -sl`;

for($item in $list)
{

if(`gmatch $item "*.cv*"`)
{
string $tmp[];
string $tmp[];
string $merda[];
string $secca[];
tokenize($item, ".", $tmp);
tokenize($item, "[", $merda);
tokenize($merda[1], "]", $secca);

string $item = $tmp[0];
float $oldValue[] = `getAttr ($item+"Shape.state[0].section["+$secca[0]+"]."+$attr)`;

    if(`gmatch $attr "rotate"`)
    setAttr ($item+"Shape.state[0].section["+$secca[0]+"]."+$attr) ($oldValue[0]+=10) ($oldValue[1]+=10) ($oldValue[2]+=10);

    if(`gmatch $attr "scale"`)
    {
    setAttr ($item+"Shape.state[0].section["+$secca[0]+"]."+$attr) ($oldValue[0]+=.4) ($oldValue[1]+=.4) ($oldValue[2]+=.4) ;}
    }

else
{
    for($item in $list)
    {

    int $sections = `getAttr ($item+"Shape.numCS")`;

        for($i=0;$i<$sections;$i++)
        {
            float $oldValue[] = `getAttr ($item+"Shape.state[0].section["+$i+"]."+$attr)`;

            if(`gmatch $attr "rotate"`)
            setAttr ($item+"Shape.state[0].section["+$i+"]."+$attr) ($oldValue[0]+=10) ($oldValue[1]+=10) ($oldValue[2]+=10);
           
            if(`gmatch $attr "scale"`)
            {
            setAttr ($item+"Shape.state[0].section["+$i+"]."+$attr) ($oldValue[0]+=.4) ($oldValue[1]+=.4) ($oldValue[2]+=.4) ;
            }
           
        }
    }
}
}

select $list;
}


//=======================================================
//=======================================================
//=======================================================
//=======================================================

//============================================================================================
//============================================================================================
//============================================================================================


global proc fxScaleMsls(float $offset)
{

string $list[] = `ls "*MSL"`;

string $attr = "scale";

for($item in $list)
{
    int $sections = `getAttr ($item+"Shape.numCS")`;

        for($i=0;$i<$sections;$i++)
        {
            float $oldValue[] = `getAttr ($item+"Shape.state[0].section["+$i+"]."+$attr)`;

            if(`gmatch $attr "scale"`)
            {
            setAttr ($item+"Shape.state[0].section["+$i+"]."+$attr) ($oldValue[0]*$offset) ($oldValue[1]*$offset) ($oldValue[2]*$offset) ;
            }
           
    }
}

}






// source "/proj/avatar/dev/GEN/base/cre/work/felix/scripts/rigFinger3.mel";
// source "/usr/home/fbalbas/maya/scripts/fx_utilities.mel";
// source "/proj/avatar/dev/GEN/base/cre/work/felix/scripts/fxUtil.mel";
// source "/proj/avatar/dev/GEN/base/cre/work/felix/scripts/bridgeChain.mel";
// source "wmSaveSoftSkinWeights.mel";
// source "/usr/home/lkraatz/mayaStuff/mel/skinning/skin_paintUI.mel";
// source "/proj/avatar/dev/GEN/base/cre/work/felix/scripts/fingerTendon.mel";

global proc string copyHandWeights(string $side, string $sourceFile, string $skinFileDir)
{

string $skinFile;
string $confirm;
string $wrongJoints[] = `listRelatives -ad -type joint ($side+"_low_arm")`;
rename ($side+"_low_arm") ("WRONG_"+$side+"_low_arm");
rename ($side+"_handHero") ("WRONG_"+$side+"_handHero");
rename root TMP_root;

for($i=0;$i<size($wrongJoints);$i++)
{
rename $wrongJoints[$i] ("WRONG_"+$wrongJoints[$i]);
}
$wrongJoints[size($wrongJoints)] = ("WRONG_"+$side+"_low_arm");

//=== import the scene to copy weights from

string $newNodes[] = `importSceneForFuckSake $sourceFile`;
group -name DELETELATER $newNodes;
rename root DELETE_root;

//==== delete stuff

string $type[] = {"ikHandle", "wire", "sculpt"};
for($item in $type)
{
string $pippo[] = `ls -type $item`;
if(`objExists $pippo[0]`)
delete `ls -type $item`;
}



string $rightJoints[] = `listRelatives -ad -type joint ($side+"_low_arm")`;
rename ($side+"_low_arm") ("RIGHT_"+$side+"_low_arm");

string $conn[] = `listConnections -s 0 -d 1 ($side+"_mid_fing_1")`;
string $pippo[] = `ls -type skinCluster $conn`;

string $meshes[];
string $origGeo;

for($item in $pippo)
{
string $nodes[] = `listConnections -type mesh -s 0 -d 1 $item`;
$meshes[size($meshes)] = $nodes[0];
}

for($item in $meshes)
{
if(`gmatch $item ("*"+$side+"_hand*")`)
$origGeo = $item;
}

rename $origGeo ("RIGHT_"+$side+"_handHero");

for($i=0;$i<size($rightJoints);$i++)
{
rename $rightJoints[$i] ("RIGHT_"+$rightJoints[$i]);
}

$rightJoints[size($rightJoints)] = ("RIGHT_"+$side+"_low_arm");


///======= find the joints in common

string $myIntersector = `stringArrayIntersector`;
stringArrayIntersector -edit -intersect $wrongJoints $myIntersector;
stringArrayIntersector -edit -intersect $rightJoints $myIntersector;
string $diff[] = `stringArrayIntersector -query $myIntersector`;


//=== contraint joints to each other

for($i=0;$i<size($diff);$i++)
{
    CBunlockAttr ("RIGHT_"+$diff[$i]+".tx");
    CBunlockAttr ("RIGHT_"+$diff[$i]+".ty");
    CBunlockAttr ("RIGHT_"+$diff[$i]+".tz");
    CBunlockAttr ("RIGHT_"+$diff[$i]+".rx");
    CBunlockAttr ("RIGHT_"+$diff[$i]+".ry");
    CBunlockAttr ("RIGHT_"+$diff[$i]+".rz");
    CBunlockAttr ("RIGHT_"+$diff[$i]+".sx");
    CBunlockAttr ("RIGHT_"+$diff[$i]+".sy");
    CBunlockAttr ("RIGHT_"+$diff[$i]+".sz");
   
    CBdeleteConnection ("RIGHT_"+$diff[$i]+".tx");
    CBdeleteConnection ("RIGHT_"+$diff[$i]+".ty");
    CBdeleteConnection ("RIGHT_"+$diff[$i]+".tz");
    CBdeleteConnection ("RIGHT_"+$diff[$i]+".rx");
    CBdeleteConnection ("RIGHT_"+$diff[$i]+".ry");
    CBdeleteConnection ("RIGHT_"+$diff[$i]+".rz");
    CBdeleteConnection ("RIGHT_"+$diff[$i]+".sx");
    CBdeleteConnection ("RIGHT_"+$diff[$i]+".sy");
    CBdeleteConnection ("RIGHT_"+$diff[$i]+".sz");
   
    transformLimits -tx 0 0 -etx 0 0  ("RIGHT_"+$diff[$i]);
    transformLimits -ty 0 0 -ety 0 0  ("RIGHT_"+$diff[$i]);
    transformLimits -tz 0 0 -etz 0 0  ("RIGHT_"+$diff[$i]);
    transformLimits -rx 0 0 -erx 0 0  ("RIGHT_"+$diff[$i]);
    transformLimits -ry 0 0 -ery 0 0  ("RIGHT_"+$diff[$i]);
    transformLimits -rz 0 0 -erz 0 0  ("RIGHT_"+$diff[$i]);
   
    select ("WRONG_"+$diff[$i]) ("RIGHT_"+$diff[$i]);
    parentConstraint; scaleConstraint;
}


//=== renaming of geo and joints for saving

for($i=0;$i<size($wrongJoints);$i++)
{
if(`objExists ("WRONG_"+$wrongJoints[$i])`)
rename ("WRONG_"+$wrongJoints[$i]) $wrongJoints[$i];
}

rename ("WRONG_"+$side+"_handHero") ($side+"_handHero");
rename ("WRONG_"+$side+"_low_arm") ($side+"_low_arm");

//=== copying skin cluster


for($i=0;$i<size($rightJoints);$i++)
{
if(`objExists ("RIGHT_"+$rightJoints[$i])`)
rename ("RIGHT_"+$rightJoints[$i]) $rightJoints[$i];
}
rename ("RIGHT_"+$side+"_low_arm") ($side+"_low_arm");


string $skinCluster = `findRelatedSkinCluster ($side+"_handHero")`;

if(!`size($skinCluster)`)
{
select $rightJoints ($side+"_handHero"); skinCluster;
}

select ("RIGHT_"+$side+"_handHero") ($side+"_handHero");
copySkinWeights  -noMirror -surfaceAssociation closestPoint -influenceAssociation name -influenceAssociation name -influenceAssociation name;

string $skinCluster = `findRelatedSkinCluster ($side+"_handHero")`;

//select($side+"_handHero"); removeUnusedInfluences;


if(size($skinFileDir)>0)
{

    if(!`gmatch $skinFileDir "*/"`)
    $skinFileDir = ($skinFileDir+"/");

$skinFile = ($skinFileDir+$side+"_handHero.mel");

if(!`file -q -ex $skinFileDir`)
system("mkdir "+$skinFileDir);
rename TMP_root root;

select ($side+"_handHero");
$confirm = `writeSkinClusterFile $skinFile "mel"`;
}

delete DELETELATER;

if(size(`ls "persp?"`)>0)
delete `ls "persp?"`;

return $confirm;

}


//=================================================================================================
//=================================================================================================
//=================================================================================================
//=================================================================================================
//=================================================================================================
//=================================================================================================


global proc rigHand(string $side, string $skinFile, string $bonesDir, string $wmSmoothDir, string $wmBulgeDir, string $wireDir)
{

string $wires[];
string $mesh = ($side+"_handHero");
int $pos;
int $neg;
int $min;
int $max;

if(`gmatch $side "l"`)
{
$pos = 1;$neg = 0;
}

if(`gmatch $side "r"`)
{
$pos = 0;$neg = 1;
}
//=== XTRA JOINTS

string $prefix = "_for_meat";
int $doExtraThumb = 0;

string $crv[];


for($item in `ls -type joint ($side+"_hand_?")`)
{
string $pippo[] = `ls $item`;

    if($doExtraThumb == 1)
    {
        if(`gmatch  $pippo[0] ($side+"_hand_1")`)
        {
        select -cl;
        joint -name ($side+$prefix+"_hand_1");
        parent ($side+$prefix+"_hand_1") ($side+"_hand_1");
        setAttr ($side+$prefix+"_hand_1.t") 0 0 0;
        setAttr ($side+$prefix+"_hand_1.r") 0 0 0;
        setAttr ($side+$prefix+"_hand_1.jointOrient") 0 0 0;
   
        joint -name ($side+$prefix+"_up_fing_1");
        parent ($side+$prefix+"_up_fing_1") ($side+"_up_fing_1");
        setAttr ($side+$prefix+"_up_fing_1.t") 0 0 0;
        setAttr ($side+$prefix+"_up_fing_1.r") 0 0 0;
        setAttr ($side+$prefix+"_up_fing_1.jointOrient") 0 0 0;
   
        parent ($side+$prefix+"_up_fing_1") ($side+$prefix+"_hand_1");
        select ($side+"_hand_1") ($side+"_mid_fing_1") ($side+"_up_fing_1") ($side+$prefix+"_up_fing_1"); pointConstraint -mo;
   
        select -cl;
        joint -name ($side+$prefix+"_mid_fing_1");
        parent ($side+$prefix+"_mid_fing_1") ($side+"_mid_fing_1");
        setAttr ($side+$prefix+"_mid_fing_1.t") 0 0 0;
        setAttr ($side+$prefix+"_mid_fing_1.r") 0 0 0;
        setAttr ($side+$prefix+"_mid_fing_1.jointOrient") 0 0 0;
   
        parent ($side+$prefix+"_mid_fing_1") ($side+$prefix+"_up_fing_1");
        //select ($side+"_mid_fing_1") ($side+$prefix+"_mid_fing_1"); parentConstraint;
   
        select ($side+$prefix+"_up_fing_1") ($side+$prefix+"_mid_fing_1"); ikHandle -s sticky -name ($side+$prefix+"_thumb_1_IKH");
        parent ($side+$prefix+"_thumb_1_IKH") ($side+"_mid_fing_1");
   
        select -cl;
        joint -name ($side+$prefix+"_low_fing_1");
        parent ($side+$prefix+"_low_fing_1") ($side+"_low_fing_1");
        setAttr ($side+$prefix+"_low_fing_1.t") 0 0 0;
        setAttr ($side+$prefix+"_low_fing_1.r") 0 0 0;
        setAttr ($side+$prefix+"_low_fing_1.jointOrient") 0 0 0;
   
        parent ($side+$prefix+"_low_fing_1") ($side+$prefix+"_mid_fing_1");
        //select ($side+"_low_fing_1") ($side+$prefix+"_low_fing_1"); parentConstraint;
   
        select ($side+$prefix+"_mid_fing_1") ($side+$prefix+"_low_fing_1"); ikHandle -s sticky -name ($side+$prefix+"_thumb_2_IKH");
        parent ($side+$prefix+"_thumb_2_IKH") ($side+"_low_fing_1");


        select -cl;
        joint -name ($side+$prefix+"_low_fing_1_end");
        parent ($side+$prefix+"_low_fing_1_end") ($side+"_low_fing_1_end");
        setAttr ($side+$prefix+"_low_fing_1_end.t") 0 0 0;
        setAttr ($side+$prefix+"_low_fing_1_end.r") 0 0 0;
        setAttr ($side+$prefix+"_low_fing_1_end.jointOrient") 0 0 0;
   
        parent ($side+$prefix+"_low_fing_1_end") ($side+$prefix+"_low_fing_1");
        //select ($side+"_low_fing_1_end") ($side+$prefix+"_low_fing_1_end"); parentConstraint;

        select ($side+$prefix+"_low_fing_1") ($side+$prefix+"_low_fing_1_end"); ikHandle -s sticky -name ($side+$prefix+"_thumb_3_IKH");
        parent ($side+$prefix+"_thumb_3_IKH") ($side+"_low_fing_1_end");
       
        string $pippo[] = `rigFinger3 ($side+$prefix+"_hand_1")`;
       
        for($pip in $pippo)
        $crv[size($crv)] = $pip;
        }
        else
        {
        string $pippo[] =  `rigFinger3 $item`;
       
        for($pip in $pippo)
        $crv[size($crv)] = $pip;
        }
    }
    else
    {
    string $pippo[] =  `rigFinger3 $item`;
       
    for($pip in $pippo)
    $crv[size($crv)] = $pip;
    }

}

if(!`objExists ($side+$prefix+"_up_fing_1_meat_mid_JNT")`)
$prefix = "";

lockTrans ($side+$prefix+"_up_fing_1_meat_mid_JNT") $neg $pos 0 0 1;

string $points[] = `findMeatPoints ($side+"_hand_2") ($side+$prefix+"_mid_fing_1") "x" $neg 7`;
select $points[0] $points[1] $points[2];
string $joints[] = `build_joints ($side+$prefix+"_up_fing_1_up_meat") 1`;

parent $joints[size($joints)-1] $points[2];
parent $points[2] ($side+$prefix+"_up_fing_1");
parent $joints[0] ($side+"_hand_1_dum");
select -cl;

        joint -name ($side+$prefix+"_up_fing_1_up_meat_JNT");
        parent ($side+$prefix+"_up_fing_1_up_meat_JNT") $points[1];
        select $joints[1] ($side+$prefix+"_up_fing_1_up_meat_JNT"); pointConstraint;
        setAttr ($side+$prefix+"_up_fing_1_up_meat_JNT.r") 0 0 0;
        setAttr ($side+$prefix+"_up_fing_1_up_meat_JNT.jointOrient") 0 0 0;
        lockTrans ($side+$prefix+"_up_fing_1_up_meat_JNT") $neg $pos 1 0 0;
        lockTrans ($side+$prefix+"_up_fing_1_up_meat_JNT") $neg $pos 0 0 1;

//======================= WIRES


if(size($wireDir)>0)
{
string $list[] = `ls ($side+"_up_fing_?")`;

for($i=1;$i<(size($list)+1);$i++)
{
string $tendons[] = `fingerTendon $mesh $i`;

for($item in $tendons)
$wires[size($wires)] = $item;

}

}

//=== XTRA WRIST JOINTS

//=========

spaceLocator -name ($side+"_fing_3_up_wrist_ref_LOC");
parent ($side+"_fing_3_up_wrist_ref_LOC") ($side+"_hand_3");
setAttr ($side+"_fing_3_up_wrist_ref_LOC.t") 0 0 0;
setAttr ($side+"_fing_3_up_wrist_ref_LOC.r") 0 0 0;

if(`gmatch $side "l"`)
setAttr ($side+"_fing_3_up_wrist_ref_LOC.tx") -2;
if(`gmatch $side "r"`)
setAttr ($side+"_fing_3_up_wrist_ref_LOC.tx") 2;

//===

spaceLocator -name ($side+"_fing_3_up_wrist_upfing_ref_LOC");
parent ($side+"_fing_3_up_wrist_upfing_ref_LOC") ($side+"_up_fing_3");
setAttr ($side+"_fing_3_up_wrist_upfing_ref_LOC.t") 0 0 0;
setAttr ($side+"_fing_3_up_wrist_upfing_ref_LOC.r") 0 0 0;

if(`gmatch $side "l"`)
setAttr ($side+"_fing_3_up_wrist_upfing_ref_LOC.tx") -2;
if(`gmatch $side "r"`)
setAttr ($side+"_fing_3_up_wrist_upfing_ref_LOC.tx") 2;

parent ($side+"_fing_3_up_wrist_upfing_ref_LOC") ($side+"_hand_3");

//==========

string $curves[];
select ($side+"_low_arm_twist") ($side+"_hand_3_dum") ($side+"_hand_3") ($side+"_up_fing_3");
$curves[size($curves)] = `bridgeChain "low_wrist" "x" $pos 5`;

select ($side+"_low_arm_twist") ($side+"_fing_3_up_wrist_ref_LOC") ($side+"_fing_3_up_wrist_upfing_ref_LOC") ($side+"_up_fing_3");
$curves[size($curves)] = `bridgeChain "up_wrist" "x" $neg 5`;


//======================= SKIN_CLUSTER

if(size($skinFile))
{
string $skinCluster = `findRelatedSkinCluster $mesh`;

    if(size($skinCluster))
    delete $skinCluster;

string $com = ("source \""+$skinFile+"\"");
eval($com);
}
else
{
select ($side+"_low_arm_twist") $mesh; skinCluster  -foc;
}


//========================= EXTRA DEFORMERS

//======================= SCULPTS

if(size($bonesDir)>0)
loadAllSculpts $bonesDir $mesh;


//=== wmBulge

if(size($wmBulgeDir)>0)
fxLoadAllWmBulge $wmBulgeDir $mesh;

//=== wm Smooth

if(size($wmSmoothDir)>0)
fxLoadAllWmSmooth $wmSmoothDir $mesh;

//=== wire deformers maps

if(size($wireDir)>0)
fxLoadAllWires $wireDir $mesh;


//===========================================================
//===========================================================
//==================== reorder

string $skinCluster = `findRelatedSkinCluster $mesh`;

if(size($skinCluster)||size($wires))
 catchQuiet(`reorderDeformers $wires[0] $skinCluster $mesh`);

createDisplayLayer -name ($side+"_handRigging") `ls -type transform ($side +"*wrist*") ($side +"*meat*") ($side +"*CRV")`;
setAttr ($side+"_handRigging.v") 0;

string $groupies[] = `ls $wires $curves $crv`;

group -name ($side+"_handRig") `ls $groupies`;

print ("\ngrouping ");
print $groupies;
print "\n";

if(`objExists noTransform`)
parent ($side+"_handRig") noTransform;
else
if(`objExists doNotTouch`)
parent ($side+"_handRig") doNotTouch;

//=== puppet shit

if(`objExists VisibilityControls`)
{
    // hook up the visibility to a toggle on the main node...

    if(!`objExists VisibilityControls.smoothSkinHands`)
    addAttr -ln "smoothSkinHands" -at bool -k 1 VisibilityControls;
   
    //setAttr -e -keyable true VisibilityControls.smoothSkinHands;
    connectAttr -f VisibilityControls.smoothSkinHands ($side+"_handHero.v");
   
    if(!`objExists smoothSkinHandsVisReverse`)
    {
    shadingNode -name "smoothSkinHandsVisReverse" -asUtility reverse;
    connectAttr -f VisibilityControls.smoothSkinHands smoothSkinHandsVisReverse.inputX;
    }
   
    // select all the hand geo and connect up this attribute to the visibility...
    string $mesh[] = `ls ($side+"_low_fing_?_geo") ($side+"_up_fing_?_geo") ($side+"_mid_fing_?_geo") ($side+"_hand_?_geo")`;
    for($geo in $mesh)
    {
    connectAttr smoothSkinHandsVisReverse.outputX ($geo + ".v");
    }

    // ok, start cleaning up and connect up the shader whie you're at it...
    editDisplayLayerMembers mesh ($side+"_handHero");
}


}



//// source "/usr/home/fbalbas/maya/scripts/fx_utilities.mel";
//// source "/proj/avatar/dev/GEN/base/cre/work/felix/scripts/fxUtil.mel";
// source "wmSaveSoftSkinWeights.mel";
// source "/usr/home/lkraatz/mayaStuff/mel/skinning/skin_paintUI.mel";
source "generateChannelMenu.mel" ;

//=== utilities

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

global proc invConnect(string $input, string $output)
{

string $invNode = `shadingNode -asUtility reverse`;
connectAttr -f $input ($invNode+".inputX");
connectAttr -f ($invNode+".outputX") $output;

}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

global proc float closestValueOnCurve(int $mode)
{
//=== select an object and a curve

float $max = 1.000;
string $nodes[] = `ls -sl`;
string $curve = $nodes[1];
string $node = $nodes[0];

select $curve $node;
delete `geometryConstraint`;

select -cl;
spaceLocator -name tmp;
select $node tmp;delete `pointConstraint`;

$mpath = `createNode motionPath`;

if($mode == 0)
setAttr ($mpath + ".fractionMode") (!false);
else
{
setAttr ($mpath + ".fractionMode") (!true);
string $command = ("ls "+$curve+".u[\"*\"]");
print "/n";;
print $command;
print "/n";;
string $totalU[] = eval($command);
string $tmp[];
string $tmp2[];
tokenize($totalU[0], ":", $tmp);
tokenize($tmp[1], "]", $tmp2);
$max = $tmp2[0];
}

connectAttr ($curve + ".worldSpace[0]") ($mpath + ".geometryPath");
connectAttr -f ($mpath + ".allCoordinates") tmp.translate;
rename $mpath tmp_mpa;
CBdeleteConnection tmp_mpa.u;




$dist = `distanceDimension -sp 100 100 100 -ep 200 200 200`;
string $dispensable[] =  `listConnections $dist`;

if(`objExists ($node + ".worldPosition")`)
{
connectAttr -f ($node + ".worldPosition") ($dist + ".startPoint");
}
else
{
spaceLocator -name pippo;
select $node pippo;delete `pointConstraint`;
connectAttr -f pippo.worldPosition ($dist + ".startPoint");
}

connectAttr -f tmpShape.worldPosition ($dist + ".endPoint");
delete $dispensable;

float $i;
float $distances[];
float $Uvalue;
float $Uvalues[];

for($i = 0.000; $i < $max;$i+=.001)
{
setAttr tmp_mpa.u $i;
float $distanza = `getAttr ($dist + ".distance")`;
$distances[size($distances)] = $distanza;
$Uvalues[size($Uvalues)] = $i;
}

float $sorted[] = `sort $distances`;
float $smallest = $sorted[0];

for($n = 0; $n < size($distances);$n++)
{
if($distances[$n] == $smallest)
$Uvalue = $Uvalues[$n];
}


delete tmp;

$mpath = `createNode motionPath`;
connectAttr ($curve + ".worldSpace[0]") ($mpath + ".geometryPath");
connectAttr -f ($mpath + ".allCoordinates") ($node+".translate");
rename $mpath ($node + "_mpa");
setAttr ($node + "_mpa.u") $Uvalue;

if(`objExists pippo`)
{
delete pippo;
}

select -cl;
return $Uvalue;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

global proc string[] build_joints(string $baseName, int $ikh)
{
   
    int $num;
    string $joints[];
    string $pref;
    string $suff;
    string $list[] = `ls -sl`;
    string $item;
    select -cl;

    if(size($list) == 0)
    {
    print "\nselect objects to match in order\n";
    }
    else
    {
   
        for($i=0;$i<size($list);$i++)
        {
        string $name = ($baseName+"_"+($i+1));
        string $jnt;

            if(size($joints) == 0)
            {
            float $pos[] = `xform -q -ws -t $list[$i]`;
            float $rot[] = `xform -q -ws -ro $list[$i]`;
            $jnt = `joint -p $pos[0] $pos[1] $pos[2] -sc false -name ($name +  "_JNT")`;
            setAttr ($jnt + ".jointOrient") 0 0 0;
            $joints[`size $joints`] = $jnt;
            select $jnt;
            }
            else
            {
            float $pos[] = `xform -q -ws -t $list[$i]`;
            float $rot[] = `xform -q -ws -ro $list[$i]`;
            $jnt = `joint -p $pos[0] $pos[1] $pos[2] -sc off -name ($name +  "_JNT")`;
            joint -e -zso -oj zyx $joints[(size($joints)-1)];
            $joints[`size $joints`] = $jnt;
            select $jnt;
            }
        }
    }
   

    if($ikh>0)
    {
    select $joints[0] $joints[size($joints)-1];
    string $nodes[] = `ikHandle -s sticky`;
    rename $nodes[0] ($baseName+"_IKH");
    $joints[`size $joints`] = ($baseName+"_IKH");
    }

    select $joints;
    joint -e -spa;

    select -cl;

    return $joints;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
/*

global proc float get_distance()
{

string $locs[] = `ls -sl`;
float $uno[] = `xform -query -worldSpace -translation $locs[0]`;
float $due[] = `xform -query -worldSpace -translation $locs[1]`;
               
float $X = $uno[0] - $due[0];
float $Y = $uno[1] - $due[1];
float $Z = $uno[2] - $due[2];

float $dist = sqrt($X*$X + $Y*$Y + $Z*$Z);

return $dist;
}
*/

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

global proc string[] returnChildren(string $root, string $type)
{
string $lista[] = `ls -sl`;
string $nodes[];

select -hi $root;
string $list[] = `ls -type $type -sl`;;

for($item in $list)
{

string $current[] = `ls $item`;

    if(!`gmatch $current[0] $root`)
    $nodes[size($nodes)] = $current[0];

}


return $nodes;
select $lista;

}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


global proc lockTrans(string $obj, int $min, int $max, int $X, int $Y, int $Z)
{
int $switches[] = {$X,$Y,$Z};
string $axes[] = {"x","y","z"};

    for($i=0;$i<3;$i++)
    {
    string $comm = ("transformLimits -t"+$axes[$i]+" (`getAttr "+$obj+".t"+$axes[$i]+"`) (`getAttr "+$obj+".t"+$axes[$i]+"`) -et"+$axes[$i]+" "+$min+" "+ $max+" "+$obj+";");
        if($switches[$i]>0)
        eval($comm);
    }
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

global proc lockRot(string $obj, int $min, int $max, int $X, int $Y, int $Z)
{
int $switches[] = {$X,$Y,$Z};
string $axes[] = {"x","y","z"};

    for($i=0;$i<3;$i++)
    {
    string $comm = ("transformLimits -r"+$axes[$i]+" (`getAttr "+$obj+".r"+$axes[$i]+"`) (`getAttr "+$obj+".r"+$axes[$i]+"`) -er"+$axes[$i]+" "+$min+" "+ $max+" "+$obj+";");
        if($switches[$i]>0)
        eval($comm);
    }
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//=== scripts


global proc string[] findMeatPoints(string $root, string $end, string $dir, int $pos, int $ratio)
{

string $return[];

string $list[] = `ls -sl`;
select $root $end;
float $dist = `get_distance`;

string $rootLoc = ($root+"_root_meat_LOC");
string $rootREF = ($root+"_meat_REF");
string $midLoc = ($root+"_mid_meat_LOC");
string $endLoc = ($root+"_end_meat_LOC");

if(`objExists $rootLoc`)
$rootLoc = ($root+"_xtra_root_meat_LOC");
if(`objExists $midLoc`)
$midLoc = ($root+"_xtra_mid_meat_LOC");
if(`objExists $endLoc`)
$endLoc = ($root+"_xtra_end_meat_LOC");

spaceLocator -name $midLoc;

select $root $end $midLoc;
delete `pointConstraint`;
parent $midLoc $root;
setAttr ($midLoc+".r") 0 0 0;

if($pos!=0)
setAttr ($midLoc+".t"+$dir) (1.2*($dist/$ratio));
else
setAttr ($midLoc+".t"+$dir) (-1.2*($dist/$ratio));

duplicate -name $rootLoc $midLoc;
duplicate -name $endLoc $midLoc;


select $root $rootLoc; delete `parentConstraint`;
select $end $endLoc; delete `parentConstraint`;

duplicate -name $rootREF $rootLoc;

if($pos!=0)
setAttr ($rootREF+".t"+$dir) ($dist/$ratio);
else
setAttr ($rootREF+".t"+$dir) (-1*($dist/$ratio));


$return[size($return)] = $rootLoc;
$return[size($return)] = $midLoc;
$return[size($return)] = $endLoc;
$return[size($return)] = $rootREF;

select $list;
return $return;
}

//====================================================================================================================================
//====================================================================================================================================
//====================================================================================================================================

global proc string[] rigFinger3(string $root)
{

string $list[] = `ls -sl`;
//=== variables

string $locators[];
string $children[] = {$root};
string $nodes[] = `returnChildren $root "joint"`;
string $chainPoints[];
string $refChainPoints[];
string $prevPoints[];
string $thisPoints[];
string $meatJoints[];
string $crvPoints[];
string $refLocs[];
int $pos;
int $min;
int $max;

if(`gmatch $root "l_*"`)
{
$pos = 1; $min = 1; $max = 0;
}

if(`gmatch $root "r_*"`)
{
$pos = 0; $min = 0; $max = 1;
}


for($item in $nodes)
$children[size($children)] = $item;


//==== loop


    for($i=1;$i<(size($children));$i++)
    {
   
   
        //=== create temporary reference locators for PREVIOUS node
        if($i==1)
        $prevPoints = `findMeatPoints $children[$i-1] $children[$i] "x" $pos 7`;
        else
        $prevPoints = $thisPoints;
       
        //=== create temporary reference locators for THIS node
       
        if(`objExists $children[$i+1]`)
        {
        $thisPoints = `findMeatPoints $children[$i] $children[$i+1] "x" $pos 7`;
        //select $children[$i-1] $children[$i] $thisPoints[3];
        //parentConstraint -mo;
        //pointConstraint -mo;
        }

       
        //=== ref for main chain
       
        if(!`objExists $children[$i+1]`)
        $chainPoints = {$prevPoints[3], $thisPoints[1], $thisPoints[2]};
        else
        $chainPoints = {$prevPoints[3], $prevPoints[1], $thisPoints[3]};

        //=== keep in mind points for curve

        $refLocs[size($refLocs)] = $chainPoints[0];
        $crvPoints[size($crvPoints)] = $chainPoints[0];
       
       
        if($i==(size($children)-1))
        $crvPoints[size($crvPoints)] = $chainPoints[2];

        //=== create chains using the reference locators
       
        select $chainPoints;
        $meatJoints = `build_joints ($children[$i-1]+"_meat") 1`;
       
        if(`objExists $children[$i-1]`)
        {
        parent $meatJoints[0] $children[$i-1];
        }
        //=== create xtra chain for hand finger
       
        if($i==2)
        {
        select -cl;
        joint -name ($children[$i-2]+"_meat_3q_JNT");
        parent ($children[$i-2]+"_meat_3q_JNT")($children[$i-2]);
        select ($children[$i-2]+"_meat_2_JNT") ($children[$i-1]+"_meat_2_JNT") ($children[$i-2]+"_meat_3q_JNT"); pointConstraint;
        spaceLocator -name ($children[$i-2]+"_meat_3q_upv_LOC");
       
        //select ($children[$i-2]+"_meat_2_JNT") ($children[$i-1]+"_meat_2_JNT") ($children[$i-2]+"_meat_3q_upv_LOC"); pointConstraint;
        parent ($children[$i-2]+"_meat_3q_upv_LOC") $children[$i-1]; setAttr ($children[$i-2]+"_meat_3q_upv_LOC.t") 0 0 0;
       
        parent ($children[$i-2]+"_meat_3q_upv_LOC") $children[$i-2];
        setAttr ($children[$i-2]+"_meat_3q_upv_LOC.r") 0 0 0;
        select  ($children[$i-1]+"_meat_2_JNT") ($children[$i-2]+"_meat_3q_JNT");
        aimConstraint -aimVector 1 0 0 -upVector 0 -1 0 -worldUpType "object" -worldUpObject ($children[$i-2]+"_meat_3q_upv_LOC");

        lockTrans ($children[$i-2]+"_meat_3q_upv_LOC") 1 1 1 0 0;
        lockTrans ($children[$i-2]+"_meat_3q_upv_LOC") 1 1 1 0 0;
        lockTrans ($children[$i-2]+"_meat_3q_JNT") $min $max 1 0 0;

        select -cl;
        }
     
       
        //=== create mid joint for weights
       
        select -cl;
        joint -name ($children[$i-1]+"_meat_mid_JNT");
        parent ($children[$i-1]+"_meat_mid_JNT") ($chainPoints[1]);
        select $meatJoints[1] ($children[$i-1]+"_meat_mid_JNT"); pointConstraint;
        setAttr ($children[$i-1]+"_meat_mid_JNT.r") 0 0 0;
        setAttr ($children[$i-1]+"_meat_mid_JNT.jointOrient") 0 0 0;

        lockTrans ($children[$i-1]+"_meat_mid_JNT") $min $max 1 0 0;
   
    //========================================
    //=== for deleting later   
    $locators[size($locators)] = $prevPoints[0];
    $locators[size($locators)] = $prevPoints[1];
    $locators[size($locators)] = $prevPoints[2];
    $locators[size($locators)] = $thisPoints[0];
    $locators[size($locators)] = $thisPoints[1];
    $locators[size($locators)] = $thisPoints[2];
       
        if(`gmatch $root "*hand_1"`)
        {
            if($i==2)
            {
            parent $chainPoints[1] $root;
            lockTrans ($children[$i-1]+"_meat_mid_JNT") 1 1 0 0 1;
            lockTrans ($children[$i-1]+"_meat_mid_JNT") $max $min 0 1 0;
            }
        }
   
   
        //=== parenting
        parent $meatJoints[0] $chainPoints[0];
        parent $meatJoints[3] $chainPoints[2];
       
    }
   
//=== build curves

//=== curve1, for lower finger

string $crv1 = ($root+"_meat_1_CRV");
string $command1 = ("curve -d 2 -name " + $crv1 + " ");

    for($i = 0; $i<3;$i++)
    {
    float $p[] = `xform -q -a -ws -t $crvPoints[$i]`;
    string $point = (" -p " + $p[0] + " " + $p[1] + " " + $p[2]);
    $command1 += $point;
    }

eval $command1;

select -cl;

for($i=0;$i<3;$i++)
{

if(`objExists $children[$i]`)
select -add $children[$i];

}

select -add  $crv1;
skinCluster -name ($root+"_1_meat_SKC") -tsb -mi 5 -dr 4 -rui true;


//=== curve2, for upper finger


string $crv2 = ($root+"_meat_2_CRV");
string $command2 = ("curve -d 2 -name " + $crv2 + " ");
    for($i = 1; $i<size($crvPoints);$i++)
    {
    float $p[] = `xform -q -a -ws -t $crvPoints[$i]`;
    string $point = (" -p " + $p[0] + " " + $p[1] + " " + $p[2]);
    $command2 += $point;
    }

eval $command2;


select -cl;

for($i=1;$i<size($children);$i++)
{

if(`objExists $children[$i]`)
select -add $children[$i];

}

select -add $crv2;
skinCluster -name ($root+"_2_meat_SKC") -tsb -mi 5 -dr 4 -rui true;

//=== motionPath ref locators

string $currentCrv;

    for($i=0;$i<size($refLocs);$i++)
    {
   
    if($i<2)
    $currentCrv = $crv1;
    else
    $currentCrv = $crv2;
   
    string $crvREF = ($children[$i]+"_meat_crv_REF");
    string $posREF = ($children[$i]+"_meat_pos_REF");
   
    spaceLocator -name $crvREF;
    string $papa[] = `listRelatives -ap $refLocs[$i]`;
    parent $crvREF $papa[0];
    select $refLocs[$i] $crvREF; delete `parentConstraint`;
   
    select $crvREF $currentCrv; closestValueOnCurve 0;
    setAttr ($crvREF+".inheritsTransform") 0;


    spaceLocator -name $posREF;
    string $papa[] = `listRelatives -ap $refLocs[$i]`;

    if($i>0)
    parent $posREF $children[$i-1];
    else
    parent $posREF $papa[0];

    select $refLocs[$i] $posREF; delete `parentConstraint`;
   
   
        if(!`objExists ($crvREF+"_POC")`)
        {
        select $crvREF $posREF $refLocs[$i];
        pointConstraint -name ($crvREF+"_POC");
   
            if(`objExists ($crvREF+"_POC."+$crvREF+"W0")`)
            {
            invConnect ($crvREF+"_POC."+$crvREF+"W0") ($crvREF+"_POC."+$posREF+"W1");
           
            if($i<2)
            setAttr ($crvREF+"_POC."+$crvREF+"W0") .2;
            else
            setAttr ($crvREF+"_POC."+$crvREF+"W0") .5;
           
            }
   
        }

    }



//=== end

select $list;
return {$crv1, $crv2};

}


//====================================================================================================================================
//====================================================================================================================================
//====================================================================================================================================


global proc string[] findMeatPoints(string $root, string $end, string $dir, int $pos, int $ratio)
{

string $return[];

string $list[] = `ls -sl`;
select $root $end;
float $dist = `get_distance`;

string $loc[] = `spaceLocator`;
string $rootLoc = $loc[0];
string $loc[] = `spaceLocator`;
string $rootREF = $loc[0];
string $loc[] = `spaceLocator`;
string $midLoc = $loc[0];
string $loc[] = `spaceLocator`;
string $endLoc = $loc[0];



select $root $end $midLoc;
delete `pointConstraint`;
parent $rootLoc $rootREF $midLoc $endLoc $root;
setAttr ($midLoc+".r") 0 0 0;

if($pos!=0)
setAttr ($midLoc+".t"+$dir) (1.2*($dist/$ratio));
else
setAttr ($midLoc+".t"+$dir) (-1.2*($dist/$ratio));


select $root $rootLoc; delete `parentConstraint`;
select $end $endLoc; delete `parentConstraint`;
select $rootLoc $rootREF; delete `parentConstraint`;

if($pos!=0)
setAttr ($rootREF+".t"+$dir) ($dist/$ratio);
else
setAttr ($rootREF+".t"+$dir) (-1*($dist/$ratio));


$return[size($return)] = $rootLoc;
$return[size($return)] = $midLoc;
$return[size($return)] = $endLoc;
$return[size($return)] = $rootREF;

select $list;
return $return;
}

//=================================

global proc string bridgeChain(string $name, string $dir, int $pos, int $ratio)
{

string $joints[] = `ls -sl`;
//=== variables

string $locators[];
string $chainPoints[];
string $refChainPoints[];
string $prevPoints[];
string $thisPoints[];
string $meatJoints[];
string $crvPoints[];
string $refLocs[];
string $root = $joints[0];

int $min = 0;
int $max =0;
int $x=0;
int $y=0;
int $z=0;

if($dir == "x")
$x = 1;
$y = 0;
$z = 0;
if($dir == "y")
$x = 0;
$y = 1;
$z = 0;
if($dir == "z")
$x = 0;
$y = 0;
$z = 1;

if($pos == 1)
{
$min = 1;
$max = 0;
}
else
{
$min = 0;
$max = 1;
}
//==== loop


    for($i=1;$i<(size($joints));$i++)
    {
   
   
        //=== create temporary reference locators for PREVIOUS node
       
        if($i==1)
        $prevPoints = `findMeatPoints $joints[$i-1] $joints[$i] $dir $pos $ratio`;
        else
        $prevPoints = $thisPoints;
       
        //=== create temporary reference locators for THIS node
       
        if(`objExists $joints[$i+1]`)
        {
        $thisPoints = `findMeatPoints $joints[$i] $joints[$i+1] $dir $pos $ratio`;
        }

       
        //=== ref for main chain
       
        if(!`objExists $joints[$i+1]`)
        $chainPoints = {$prevPoints[3], $thisPoints[1], $thisPoints[2]};
        else
        $chainPoints = {$prevPoints[3], $prevPoints[1], $thisPoints[3]};

        //=== keep in mind points for curve

        $refLocs[size($refLocs)] = $chainPoints[0];
        $crvPoints[size($crvPoints)] = $chainPoints[0];
       
        if($i==(size($joints)-1))
        $crvPoints[size($crvPoints)] = $chainPoints[2];

        //=== create chains using the reference locators
       
        select $chainPoints;
        $meatJoints = `build_joints ($joints[$i-1]+"_"+$name) 1`;
       
        if(`objExists $joints[$i-1]`)
        parent $meatJoints[0] $joints[$i-1];
       
        //=== create xtra chain for hand finger
       
        if($i==2)
        {
        select -cl;
        joint -name ($joints[$i-2]+"_"+$name+"_3q_JNT");
        parent ($joints[$i-2]+"_"+$name+"_3q_JNT")($joints[$i-2]);

        setAttr ($joints[$i-2]+"_"+$name+"_3q_JNT.r") 0 0 0;
        setAttr ($joints[$i-2]+"_"+$name+"_3q_JNT.t") 0 0 0;
        setAttr ($joints[$i-2]+"_"+$name+"_3q_JNT.jointOrient") 0 0 0;
       
        select $joints[1] ($joints[$i-2]) ($joints[$i-2]+"_"+$name+"_3q_JNT");
        orientConstraint;
       
        select -cl;
        joint -name ($joints[$i-1]+"_"+$name+"_rev_chain_root_JNT");
        joint -name ($joints[$i-1]+"_"+$name+"_rev_chain_end_JNT");
        select ($joints[$i-1]+"_"+$name+"_2_JNT") ($joints[$i-1]+"_"+$name+"_rev_chain_root_JNT"); delete `parentConstraint`;
        parent ($joints[$i-1]+"_"+$name+"_rev_chain_root_JNT") ($joints[$i-1]+"_"+$name+"_2_JNT");
        select ($joints[$i-2]+"_"+$name+"_2_JNT") ($joints[$i-1]+"_"+$name+"_rev_chain_end_JNT");delete `parentConstraint`;
        select ($joints[$i-1]+"_"+$name+"_rev_chain_root_JNT") ($joints[$i-1]+"_"+$name+"_rev_chain_end_JNT");
        string $pippo[] = `ikHandle -s sticky`;
        rename $pippo[0] ($joints[$i-1]+"_"+$name+"_rev_chain_IKH");
        parent ($joints[$i-1]+"_"+$name+"_rev_chain_IKH") ($joints[$i-2]+"_"+$name+"_2_JNT");
        select $joints[1] ($joints[$i-1]+"_"+$name+"_rev_chain_IKH"); delete `pointConstraint`;
        select $root $joints[1] ($joints[$i-1]+"_"+$name+"_rev_chain_IKH"); parentConstraint -mo;
        select ($joints[$i-1]+"_"+$name+"_rev_chain_end_JNT") ($joints[$i-2]+"_"+$name+"_3q_JNT"); pointConstraint;
       
       
       
        if($dir == "x")
        {
        lockTrans ($joints[$i-2]+"_"+$name+"_3q_JNT") 1 1 0 1 0;
        lockTrans ($joints[$i-2]+"_"+$name+"_3q_JNT") $min $max 1 0 0;
        lockTrans ($joints[$i-2]+"_"+$name+"_3q_JNT") $min $max 0 0 1;
        }
        select -cl;
        }
     
       
        //=== create mid joint for weights
       
        select -cl;
        joint -name ($joints[$i-1]+"_"+$name+"_mid_JNT");
        parent ($joints[$i-1]+"_"+$name+"_mid_JNT") ($chainPoints[1]);
        select $meatJoints[1] ($joints[$i-1]+"_"+$name+"_mid_JNT"); pointConstraint;
        setAttr ($joints[$i-1]+"_"+$name+"_mid_JNT.r") 0 0 0;
        setAttr ($joints[$i-1]+"_"+$name+"_mid_JNT.jointOrient") 0 0 0;
        lockTrans ($joints[$i-1]+"_"+$name+"_mid_JNT") $min $max $x $y $z;
   
    //========================================
    //=== for deleting later   
    $locators[size($locators)] = $prevPoints[0];
    $locators[size($locators)] = $prevPoints[1];
    $locators[size($locators)] = $prevPoints[2];
    $locators[size($locators)] = $thisPoints[0];
    $locators[size($locators)] = $thisPoints[1];
    $locators[size($locators)] = $thisPoints[2];
   
   
        //=== parenting
        parent $meatJoints[0] $chainPoints[0];
        parent $meatJoints[3] $chainPoints[2];
       
    }
   
//=== build curve

string $crv = ($root+"_"+$name+"_CRV");
string $command = ("curve -d 2 -name " + $crv + " ");

    for($i = 0; $i<size($crvPoints);$i++)
    {
    float $p[] = `xform -q -a -ws -t $crvPoints[$i]`;
    string $point = (" -p " + $p[0] + " " + $p[1] + " " + $p[2]);
    $command += $point;
    }

eval $command;

select -cl;
for($item in $joints)
{
if(`objExists $item`)
select -add $item;
}
select -add  $crv;
skinCluster -name ($root+"_"+$crv+"_SKC") -tsb -mi 5 -dr 4 -rui true;

//=== motionPath ref locators


    for($i=0;($i<size($refLocs)-1);$i++)
    {

    string $crvREF = ($joints[$i]+"_"+$name+"_crv_REF");
    string $posREF = ($joints[$i]+"_"+$name+"_pos_REF");
   
    spaceLocator -name $crvREF;
    string $papa[] = `listRelatives -ap $refLocs[$i]`;
    parent $crvREF $papa[0];
    select $refLocs[$i] $crvREF; delete `parentConstraint`;
   
    select $crvREF $crv; closestValueOnCurve 0;
    setAttr ($crvREF+".inheritsTransform") 0;


    spaceLocator -name $posREF;
    string $papa[] = `listRelatives -ap $refLocs[$i]`;

    if($i>0)
    parent $posREF $joints[$i-1];
    else
    parent $posREF $papa[0];

    select $refLocs[$i] $posREF; delete `parentConstraint`;
   
   
    if(!`objExists ($crvREF+"_POC")`)
    {
    //print ("\n"+$crvREF+"_POC doesn't exist\n");
    //print ("\nselect "+" "+$crvREF+" "+ $posREF+" "+$refLocs[$i]);
    select $crvREF $posREF $refLocs[$i];
    //print ("\npointConstraint -name "+$crvREF+"_POC");
    pointConstraint -name ($crvREF+"_POC");
    //print ("\ninvConnect "+$crvREF+"_POC."+$crvREF+"W0 "+$crvREF+"_POC."+$posREF+"W1\n");
    invConnect ($crvREF+"_POC."+$crvREF+"W0") ($crvREF+"_POC."+$posREF+"W1");
    //setAttr ($crvREF+"_POC."+$crvREF+"W0") ($i/(size($refLocs)-1));
    //print ("\nsetAttr "+$crvREF+"_POC."+$crvREF+"W0 .5\n");
    setAttr ($crvREF+"_POC."+$crvREF+"W0") .5;
    }

    }

return $crv;

//=== end
}


//=================================================================================================
//=================================================================================================
//=================================================================================================


global proc string copyHandWeights(string $side, string $sourceFile, string $skinFileDir)
{

string $skinFile;
string $confirm;
string $wrongJoints[] = `listRelatives -ad -type joint ($side+"_low_arm")`;
rename ($side+"_low_arm") ("WRONG_"+$side+"_low_arm");
rename ($side+"_handHero") ("WRONG_"+$side+"_handHero");
rename root TMP_root;

for($i=0;$i<size($wrongJoints);$i++)
{
rename $wrongJoints[$i] ("WRONG_"+$wrongJoints[$i]);
}
$wrongJoints[size($wrongJoints)] = ("WRONG_"+$side+"_low_arm");

//=== import the scene to copy weights from

string $newNodes[] = `importSceneForFuckSake $sourceFile`;
group -name DELETELATER $newNodes;
rename root DELETE_root;

//==== delete stuff

string $type[] = {"ikHandle", "wire", "sculpt"};
for($item in $type)
{
string $pippo[] = `ls -type $item`;
if(`objExists $pippo[0]`)
delete `ls -type $item`;
}



string $rightJoints[] = `listRelatives -ad -type joint ($side+"_low_arm")`;
rename ($side+"_low_arm") ("RIGHT_"+$side+"_low_arm");

string $conn[] = `listConnections -s 0 -d 1 ($side+"_mid_fing_1")`;
string $pippo[] = `ls -type skinCluster $conn`;

string $meshes[];
string $origGeo;

for($item in $pippo)
{
string $nodes[] = `listConnections -type mesh -s 0 -d 1 $item`;
$meshes[size($meshes)] = $nodes[0];
}

for($item in $meshes)
{
if(`gmatch $item ("*"+$side+"_hand*")`)
$origGeo = $item;
}

rename $origGeo ("RIGHT_"+$side+"_handHero");

for($i=0;$i<size($rightJoints);$i++)
{
rename $rightJoints[$i] ("RIGHT_"+$rightJoints[$i]);
}

$rightJoints[size($rightJoints)] = ("RIGHT_"+$side+"_low_arm");


///======= find the joints in common

string $myIntersector = `stringArrayIntersector`;
stringArrayIntersector -edit -intersect $wrongJoints $myIntersector;
stringArrayIntersector -edit -intersect $rightJoints $myIntersector;
string $diff[] = `stringArrayIntersector -query $myIntersector`;


//=== contraint joints to each other

for($i=0;$i<size($diff);$i++)
{
    CBunlockAttr ("RIGHT_"+$diff[$i]+".tx");
    CBunlockAttr ("RIGHT_"+$diff[$i]+".ty");
    CBunlockAttr ("RIGHT_"+$diff[$i]+".tz");
    CBunlockAttr ("RIGHT_"+$diff[$i]+".rx");
    CBunlockAttr ("RIGHT_"+$diff[$i]+".ry");
    CBunlockAttr ("RIGHT_"+$diff[$i]+".rz");
    CBunlockAttr ("RIGHT_"+$diff[$i]+".sx");
    CBunlockAttr ("RIGHT_"+$diff[$i]+".sy");
    CBunlockAttr ("RIGHT_"+$diff[$i]+".sz");
   
    CBdeleteConnection ("RIGHT_"+$diff[$i]+".tx");
    CBdeleteConnection ("RIGHT_"+$diff[$i]+".ty");
    CBdeleteConnection ("RIGHT_"+$diff[$i]+".tz");
    CBdeleteConnection ("RIGHT_"+$diff[$i]+".rx");
    CBdeleteConnection ("RIGHT_"+$diff[$i]+".ry");
    CBdeleteConnection ("RIGHT_"+$diff[$i]+".rz");
    CBdeleteConnection ("RIGHT_"+$diff[$i]+".sx");
    CBdeleteConnection ("RIGHT_"+$diff[$i]+".sy");
    CBdeleteConnection ("RIGHT_"+$diff[$i]+".sz");
   
    transformLimits -tx 0 0 -etx 0 0  ("RIGHT_"+$diff[$i]);
    transformLimits -ty 0 0 -ety 0 0  ("RIGHT_"+$diff[$i]);
    transformLimits -tz 0 0 -etz 0 0  ("RIGHT_"+$diff[$i]);
    transformLimits -rx 0 0 -erx 0 0  ("RIGHT_"+$diff[$i]);
    transformLimits -ry 0 0 -ery 0 0  ("RIGHT_"+$diff[$i]);
    transformLimits -rz 0 0 -erz 0 0  ("RIGHT_"+$diff[$i]);
   
    select ("WRONG_"+$diff[$i]) ("RIGHT_"+$diff[$i]);
    parentConstraint; scaleConstraint;
}


//=== renaming of geo and joints for saving

for($i=0;$i<size($wrongJoints);$i++)
{
if(`objExists ("WRONG_"+$wrongJoints[$i])`)
rename ("WRONG_"+$wrongJoints[$i]) $wrongJoints[$i];
}

rename ("WRONG_"+$side+"_handHero") ($side+"_handHero");
rename ("WRONG_"+$side+"_low_arm") ($side+"_low_arm");

//=== copying skin cluster


for($i=0;$i<size($rightJoints);$i++)
{
if(`objExists ("RIGHT_"+$rightJoints[$i])`)
rename ("RIGHT_"+$rightJoints[$i]) $rightJoints[$i];
}
rename ("RIGHT_"+$side+"_low_arm") ($side+"_low_arm");


string $skinCluster = `findRelatedSkinCluster ($side+"_handHero")`;

if(!`size($skinCluster)`)
{
select $rightJoints ($side+"_handHero"); skinCluster;
}

select ("RIGHT_"+$side+"_handHero") ($side+"_handHero");
copySkinWeights  -noMirror -surfaceAssociation closestPoint -influenceAssociation name -influenceAssociation name -influenceAssociation name;

string $skinCluster = `findRelatedSkinCluster ($side+"_handHero")`;

//select($side+"_handHero"); removeUnusedInfluences;


if(size($skinFileDir)>0)
{

    if(!`gmatch $skinFileDir "*/"`)
    $skinFileDir = ($skinFileDir+"/");

$skinFile = ($skinFileDir+$side+"_handHero.mel");

if(!`file -q -ex $skinFileDir`)
system("mkdir "+$skinFileDir);
rename TMP_root root;

select ($side+"_handHero");
$confirm = `writeSkinClusterFile $skinFile "mel"`;
}

delete DELETELATER;

if(size(`ls "persp?"`)>0)
delete `ls "persp?"`;

return $confirm;

}


//=================================================================================================
//=================================================================================================
//=================================================================================================


global proc rigHand(string $side, string $skinFile, string $bonesDir, string $wmSmoothDir, string $wmBulgeDir, string $wireDir)
{

string $wires[];
string $mesh = ($side+"_handHero");
int $pos;
int $neg;
int $min;
int $max;

if(`gmatch $side "l"`)
{
$pos = 1;$neg = 0;
}

if(`gmatch $side "r"`)
{
$pos = 0;$neg = 1;
}
//=== XTRA JOINTS

string $prefix = "_for_meat";
int $doExtraThumb = 0;

string $crv[];


for($item in `ls -type joint ($side+"_hand_?")`)
{
string $pippo[] = `ls $item`;

    if($doExtraThumb == 1)
    {
        if(`gmatch  $pippo[0] ($side+"_hand_1")`)
        {
        select -cl;
        joint -name ($side+$prefix+"_hand_1");
        parent ($side+$prefix+"_hand_1") ($side+"_hand_1");
        setAttr ($side+$prefix+"_hand_1.t") 0 0 0;
        setAttr ($side+$prefix+"_hand_1.r") 0 0 0;
        setAttr ($side+$prefix+"_hand_1.jointOrient") 0 0 0;
   
        joint -name ($side+$prefix+"_up_fing_1");
        parent ($side+$prefix+"_up_fing_1") ($side+"_up_fing_1");
        setAttr ($side+$prefix+"_up_fing_1.t") 0 0 0;
        setAttr ($side+$prefix+"_up_fing_1.r") 0 0 0;
        setAttr ($side+$prefix+"_up_fing_1.jointOrient") 0 0 0;
   
        parent ($side+$prefix+"_up_fing_1") ($side+$prefix+"_hand_1");
        select ($side+"_hand_1") ($side+"_mid_fing_1") ($side+"_up_fing_1") ($side+$prefix+"_up_fing_1"); pointConstraint -mo;
   
        select -cl;
        joint -name ($side+$prefix+"_mid_fing_1");
        parent ($side+$prefix+"_mid_fing_1") ($side+"_mid_fing_1");
        setAttr ($side+$prefix+"_mid_fing_1.t") 0 0 0;
        setAttr ($side+$prefix+"_mid_fing_1.r") 0 0 0;
        setAttr ($side+$prefix+"_mid_fing_1.jointOrient") 0 0 0;
   
        parent ($side+$prefix+"_mid_fing_1") ($side+$prefix+"_up_fing_1");
        //select ($side+"_mid_fing_1") ($side+$prefix+"_mid_fing_1"); parentConstraint;
   
        select ($side+$prefix+"_up_fing_1") ($side+$prefix+"_mid_fing_1"); ikHandle -s sticky -name ($side+$prefix+"_thumb_1_IKH");
        parent ($side+$prefix+"_thumb_1_IKH") ($side+"_mid_fing_1");
   
        select -cl;
        joint -name ($side+$prefix+"_low_fing_1");
        parent ($side+$prefix+"_low_fing_1") ($side+"_low_fing_1");
        setAttr ($side+$prefix+"_low_fing_1.t") 0 0 0;
        setAttr ($side+$prefix+"_low_fing_1.r") 0 0 0;
        setAttr ($side+$prefix+"_low_fing_1.jointOrient") 0 0 0;
   
        parent ($side+$prefix+"_low_fing_1") ($side+$prefix+"_mid_fing_1");
        //select ($side+"_low_fing_1") ($side+$prefix+"_low_fing_1"); parentConstraint;
   
        select ($side+$prefix+"_mid_fing_1") ($side+$prefix+"_low_fing_1"); ikHandle -s sticky -name ($side+$prefix+"_thumb_2_IKH");
        parent ($side+$prefix+"_thumb_2_IKH") ($side+"_low_fing_1");


        select -cl;
        joint -name ($side+$prefix+"_low_fing_1_end");
        parent ($side+$prefix+"_low_fing_1_end") ($side+"_low_fing_1_end");
        setAttr ($side+$prefix+"_low_fing_1_end.t") 0 0 0;
        setAttr ($side+$prefix+"_low_fing_1_end.r") 0 0 0;
        setAttr ($side+$prefix+"_low_fing_1_end.jointOrient") 0 0 0;
   
        parent ($side+$prefix+"_low_fing_1_end") ($side+$prefix+"_low_fing_1");
        //select ($side+"_low_fing_1_end") ($side+$prefix+"_low_fing_1_end"); parentConstraint;

        select ($side+$prefix+"_low_fing_1") ($side+$prefix+"_low_fing_1_end"); ikHandle -s sticky -name ($side+$prefix+"_thumb_3_IKH");
        parent ($side+$prefix+"_thumb_3_IKH") ($side+"_low_fing_1_end");
       
        string $pippo[] = `rigFinger3 ($side+$prefix+"_hand_1")`;
       
        for($pip in $pippo)
        $crv[size($crv)] = $pip;
        }
        else
        {
        string $pippo[] =  `rigFinger3 $item`;
       
        for($pip in $pippo)
        $crv[size($crv)] = $pip;
        }
    }
    else
    {
    string $pippo[] =  `rigFinger3 $item`;
       
    for($pip in $pippo)
    $crv[size($crv)] = $pip;
    }

}

if(!`objExists ($side+$prefix+"_up_fing_1_meat_mid_JNT")`)
$prefix = "";

lockTrans ($side+$prefix+"_up_fing_1_meat_mid_JNT") $neg $pos 0 0 1;

string $points[] = `findMeatPoints ($side+"_hand_2") ($side+$prefix+"_mid_fing_1") "x" $neg 7`;
select $points[0] $points[1] $points[2];
string $joints[] = `build_joints ($side+$prefix+"_up_fing_1_up_meat") 1`;

parent $joints[size($joints)-1] $points[2];
parent $points[2] ($side+$prefix+"_up_fing_1");
parent $joints[0] ($side+"_hand_1_dum");
select -cl;

        joint -name ($side+$prefix+"_up_fing_1_up_meat_JNT");
        parent ($side+$prefix+"_up_fing_1_up_meat_JNT") $points[1];
        select $joints[1] ($side+$prefix+"_up_fing_1_up_meat_JNT"); pointConstraint;
        setAttr ($side+$prefix+"_up_fing_1_up_meat_JNT.r") 0 0 0;
        setAttr ($side+$prefix+"_up_fing_1_up_meat_JNT.jointOrient") 0 0 0;
        lockTrans ($side+$prefix+"_up_fing_1_up_meat_JNT") $neg $pos 1 0 0;
        lockTrans ($side+$prefix+"_up_fing_1_up_meat_JNT") $neg $pos 0 0 1;

//======================= WIRES


if(size($wireDir)>0)
{
string $list[] = `ls ($side+"_up_fing_?")`;

for($i=1;$i<(size($list)+1);$i++)
{
string $tendons[] = `fingerTendon $mesh $i`;

for($item in $tendons)
$wires[size($wires)] = $item;

}

}

//=== XTRA WRIST JOINTS

//=========

spaceLocator -name ($side+"_fing_3_up_wrist_ref_LOC");
parent ($side+"_fing_3_up_wrist_ref_LOC") ($side+"_hand_3");
setAttr ($side+"_fing_3_up_wrist_ref_LOC.t") 0 0 0;
setAttr ($side+"_fing_3_up_wrist_ref_LOC.r") 0 0 0;

if(`gmatch $side "l"`)
setAttr ($side+"_fing_3_up_wrist_ref_LOC.tx") -2;
if(`gmatch $side "r"`)
setAttr ($side+"_fing_3_up_wrist_ref_LOC.tx") 2;

//===

spaceLocator -name ($side+"_fing_3_up_wrist_upfing_ref_LOC");
parent ($side+"_fing_3_up_wrist_upfing_ref_LOC") ($side+"_up_fing_3");
setAttr ($side+"_fing_3_up_wrist_upfing_ref_LOC.t") 0 0 0;
setAttr ($side+"_fing_3_up_wrist_upfing_ref_LOC.r") 0 0 0;

if(`gmatch $side "l"`)
setAttr ($side+"_fing_3_up_wrist_upfing_ref_LOC.tx") -2;
if(`gmatch $side "r"`)
setAttr ($side+"_fing_3_up_wrist_upfing_ref_LOC.tx") 2;

parent ($side+"_fing_3_up_wrist_upfing_ref_LOC") ($side+"_hand_3");

//==========

string $curves[];
select ($side+"_low_arm_twist") ($side+"_hand_3_dum") ($side+"_hand_3") ($side+"_up_fing_3");
$curves[size($curves)] = `bridgeChain "low_wrist" "x" $pos 5`;

select ($side+"_low_arm_twist") ($side+"_fing_3_up_wrist_ref_LOC") ($side+"_fing_3_up_wrist_upfing_ref_LOC") ($side+"_up_fing_3");
$curves[size($curves)] = `bridgeChain "up_wrist" "x" $neg 5`;


//======================= SKIN_CLUSTER

if(size($skinFile))
{
string $skinCluster = `findRelatedSkinCluster $mesh`;

    if(size($skinCluster))
    delete $skinCluster;

string $com = ("source \""+$skinFile+"\"");
eval($com);
}
else
{
select ($side+"_low_arm_twist") $mesh; skinCluster  -foc;
}


//========================= EXTRA DEFORMERS

//======================= SCULPTS

if(size($bonesDir)>0)
loadAllSculpts $bonesDir $mesh;


//=== wmBulge

if(size($wmBulgeDir)>0)
fxLoadAllWmBulge $wmBulgeDir $mesh;

//=== wm Smooth

if(size($wmSmoothDir)>0)
fxLoadAllWmSmooth $wmSmoothDir $mesh;

//=== wire deformers maps

if(size($wireDir)>0)
fxLoadAllWires $wireDir $mesh;


//===========================================================
//===========================================================
//==================== reorder

string $skinCluster = `findRelatedSkinCluster $mesh`;

if(size($skinCluster)||size($wires))
 catchQuiet(`reorderDeformers $wires[0] $skinCluster $mesh`);

createDisplayLayer -name ($side+"_handRigging") `ls -type transform ($side +"*wrist*") ($side +"*meat*") ($side +"*CRV")`;
setAttr ($side+"_handRigging.v") 0;

string $groupies[] = `ls $wires $curves $crv`;

group -name ($side+"_handRig") `ls $groupies`;

print ("\ngrouping ");
print $groupies;
print "\n";

if(`objExists noTransform`)
parent ($side+"_handRig") noTransform;
else
if(`objExists doNotTouch`)
parent ($side+"_handRig") doNotTouch;

//=== puppet shit

if(`objExists VisibilityControls`)
{
    // hook up the visibility to a toggle on the main node...

    if(!`objExists VisibilityControls.smoothSkinHands`)
    addAttr -ln "smoothSkinHands" -at bool -k 1 VisibilityControls;
   
    //setAttr -e -keyable true VisibilityControls.smoothSkinHands;
    connectAttr -f VisibilityControls.smoothSkinHands ($side+"_handHero.v");
   
    if(!`objExists smoothSkinHandsVisReverse`)
    {
    shadingNode -name "smoothSkinHandsVisReverse" -asUtility reverse;
    connectAttr -f VisibilityControls.smoothSkinHands smoothSkinHandsVisReverse.inputX;
    }
   
    // select all the hand geo and connect up this attribute to the visibility...
    string $mesh[] = `ls ($side+"_low_fing_?_geo") ($side+"_up_fing_?_geo") ($side+"_mid_fing_?_geo") ($side+"_hand_?_geo")`;
    for($geo in $mesh)
    {
    connectAttr smoothSkinHandsVisReverse.outputX ($geo + ".v");
    }

    // ok, start cleaning up and connect up the shader whie you're at it...
    editDisplayLayerMembers mesh ($side+"_handHero");
   
    if(`objExists skinnedLegGeo_neytiri_puppetGeo_neytiri_mocapGeo_neytiri_pasted__neytiri_mocapGeo_faceSG72`)
    {
    defaultNavigation -source skinnedLegGeo_neytiri_puppetGeo_neytiri_mocapGeo_neytiri_pasted__neytiri_mocapGeo_faceSG72 -destination ($side+"_handHeroShape.instObjGroups[0]") -connectToExisting;
    select ($side+"_handHero.map[0:*]") ;
    polyEditUV -pu 0.5 -pv 0.8 -su .001 -sv .001 ;
    }
   
}


}


//=================================================================================================
//=================================================================================================
//=================================================================================================

global proc string[] fingerTendon(string $mesh, int $num)
{


string $axes = "x"; //axes to offset the tendon in
int $axesDir; //positive 1, negative -1
float $value = 2;

string $side;


if(`gmatch $mesh "l_*"`)
{
$axesDir = "-1";
$side = "l_";
}

if(`gmatch $mesh "r_*"`)
{
$axesDir = "1";
$side = "r_";
}

float $offset = (0.1*$num)*$axesDir;

string $name = ($side + "fing_"+$num+"_tendon");


string $curve = ($name+"_CRV");
string $baseCurve = ($name+"_base_CRV");
string $wire = ($name+"_WRD");

string $lo_arm = ($side+"low_arm_twist");
string $wrist = ($side+"hand");
string $hand = ($side+"hand_"+$num);
string $up_fing = ($side+"up_fing_"+$num);
string $mid_fing = ($side+"mid_fing_"+$num);
string $low_fing = ($side+"low_fing_"+$num);
string $low_fing_end = ($side+"low_fing_"+$num+"_end");



//string $finger[] = {$lo_arm, $wrist, $hand, $up_fing, $mid_fing, $low_fing, $low_fing_end};
string $finger[];

if($num>1)
$finger = {$lo_arm, $wrist, $wrist, $up_fing, $mid_fing, $low_fing, $low_fing_end};
else
$finger = {$lo_arm, $wrist, $up_fing, $mid_fing, $low_fing, $low_fing_end};

//=== build reference locators

string $locs[];
string $geoCON[];

for($i=0;$i<size($finger);$i++)
{
    if(!`objExists ($finger[$i]+"_"+($i+1)+"_LOC")`)
    spaceLocator -name ($finger[$i]+"_"+($i+1)+"_LOC");

 catchQuiet(`parent ($finger[$i]+"_"+($i+1)+"_LOC") $finger[$i]`);
setAttr ($finger[$i]+"_"+($i+1)+"_LOC"+".t") 0 0 0;
setAttr ($finger[$i]+"_"+($i+1)+"_LOC"+".r") 0 0 0;
setAttr ($finger[$i]+"_"+($i+1)+"_LOC"+".s") 1 1 1;
setAttr ($finger[$i]+"_"+($i+1)+"_LOC"+".t"+$axes) ($value*$axesDir);

if($i>0)
{
select $mesh ($finger[$i]+"_"+($i+1)+"_LOC");
$geoCON = `geometryConstraint`;
}

getAttr ($finger[$i]+"_"+($i+1)+"_LOC"+".t");
$locs[size($locs)] = ($finger[$i]+"_"+($i+1)+"_LOC");

if(`objExists $geoCON[0]`)
delete $geoCON[0];

if($num >1)
{
if($i==1||$i==2)
setAttr ($finger[$i]+"_"+($i+1)+"_LOC"+".t"+$axes) (`getAttr ($finger[$i]+"_"+($i+1)+"_LOC"+".t"+$axes)`-(2*$offset));
}

if($i==1)
{
setAttr ($finger[$i-1]+"_"+$i+"_LOC"+".t"+$axes) (`getAttr ($finger[$i]+"_"+($i+1)+"_LOC"+".t"+$axes)`-$offset);
}
else
{
setAttr ($finger[$i]+"_"+($i+1)+"_LOC"+".t"+$axes) (`getAttr ($finger[$i]+"_"+($i+1)+"_LOC"+".t"+$axes)`-$offset);
}

}

string $baseLocs[];

for($i=0;$i<size($finger);$i++)
{

    if(!`objExists ($finger[$i]+"_baseLoc_"+($i+1)+"_LOC")`)
    spaceLocator -name ($finger[$i]+"_baseLoc_"+($i+1)+"_LOC");

 catchQuiet(`parent ($finger[$i]+"_baseLoc_"+($i+1)+"_LOC") ($finger[$i]+"_"+($i+1)+"_LOC")`);
setAttr ($finger[$i]+"_baseLoc_"+($i+1)+"_LOC"+".t") 0 0 0;
setAttr ($finger[$i]+"_baseLoc_"+($i+1)+"_LOC"+".r") 0 0 0;
setAttr ($finger[$i]+"_baseLoc_"+($i+1)+"_LOC"+".s") 1 1 1;
setAttr ($finger[$i]+"_baseLoc_"+($i+1)+"_LOC"+".t"+$axes) ((-.2*$axesDir));

$baseLocs[size($baseLocs)] = ($finger[$i]+"_baseLoc_"+($i+1)+"_LOC");
}

//=== build wire curve

string $command = ("curve -name "+$curve+" -d 2 ");

for($item in $locs)
{
parent -w $item;
float $trans[] = `getAttr ($item+".t")`;
$command += ("-p "+$trans[0]+" "+$trans[1]+" "+$trans[2]+" ");
}

eval($command);

//=== build base curve shape

string $command = ("curve -name "+$baseCurve+" -d 2 ");

for($item in $baseLocs)
{
parent -w $item;
float $trans[] = `getAttr ($item+".t")`;
$command += ("-p "+$trans[0]+" "+$trans[1]+" "+$trans[2]+" ");
}

eval($command);


//=== wire

string $elem[] = `wire -gw true -ce 0.1 -w $curve $mesh`;
rename $elem[0] $wire;

connectAttr -f ($baseCurve+".worldSpace[0]") ($curve+"BaseWire.create");

select $baseCurve $finger; skinCluster -name ($name+"_tendon_baseWire_SKC");
select $finger $curve; skinCluster -tsb -name ($name+"_tendon_wire_SKC");


//=== cleaup

//wireCleanSet $wire 2.5;
delete $locs $baseLocs;


//=== end

return `ls ($curve+"Group") $baseCurve`;

}


//==============================================================================================
//==============================================================================================
//==============================================================================================

global proc string wmNavi_returnHeroMeshLocal()
{
    string $wmInfo[] = `ls -type wmInfo`;
    string $largest;
    int $num = 0;
    int $temp[0];
    for ($w in $wmInfo)
    {
        int $type = `getAttr ($w + ".type")`;
        if ($type == 9)
        {
            string $parent[] = `listRelatives -p $w`;    //list out parent of info node shape
            string $mesh[] = `listRelatives -c -ad -type mesh $parent[0]`;    //then list out all of its decendents that are meshes
           
            for ($m in $mesh)
            {   
                $temp = `polyEvaluate -v $m`; //get face count of mesh
   
                if($temp[0] > $num)  //if face count is bigger then last make that the biggest
                {
                    $largest = $m;   
                    $num = $temp[0];   
                }
            }
        }
    }
    string $return;
    if (`objExists $largest`)
    {
        string $p[] = `listRelatives -p $largest`; //since the mesh is a shape at this point return its parent
        $return = $p[0];
    }
    else
        $return = "none";
   
    return $return;
}

//==============================================================================================
//==============================================================================================
//==============================================================================================


global proc fxNavi_importWrapGeo(string $type, int $updateShapes)
{
    print ("\n--------------wmNavi_importWrapGeo "+$type+ " ------------------\n");

    select -cl;
    string $creatureName[] = `wmQueryCreature`;

    //==============================================
    //  check for existence of wrap directory
    //==============================================   
    string $wrapDir = ("/" + $creatureName[0] + "/dev/" + $creatureName[1] + "/" + $creatureName[2] +
        "/cre/scripts/creatureRigScripts/data/wrapGeo/");

    int $heroGeo, $heroChunk, $wrapChunk;
    string $heroMesh, $heroChunkMesh, $wrapMesh;
    $heroMesh = `wmNavi_returnHeroMeshLocal`;
   
    print ($heroMesh + " = heroMesh\n");
    if ($heroMesh != "none")
        $heroGeo = 1;

    if (`filetest -d $wrapDir`)
    {
        //
        string $file = ($wrapDir + $type + "Geo.mb");
       
        if (`filetest -f $file`)
        {
            file -import -type "mayaBinary" -gr -gn ($type+"Wrap_geo")   -options "v=0"  -pr -loadReferenceDepth "all" $file;
        }
        else
        print ($type + "Geo.mb file NOT found in wrap directory!!");
    }
    else
        print ("Wrap geo must be placed in a /scripts/creatureRigScripts/wrapGeo/ directory.  Directory not found!!!!\n");
}

global proc string returnSkinPath(string $type)
{
    print ("\n--------------wmNavi_importSkinWeights "+$type+ " ------------------\n");
    string $creatureName[] = `wmQueryCreature`;

    string $skinDir = ("/proj/" + $creatureName[0] + "/dev/" + $creatureName[1] + "/" + $creatureName[2] + "/cre/scripts/creatureRigScripts/data/skinWeights/");
    string $file = ($skinDir + $type + "Hero.mel");
return $file;
}

global proc string returnBonesDir(string $type)
{
    print ("\n--------------wmNavi_importBones "+$type+ " ------------------\n");
    string $creatureName[] = `wmQueryCreature`;

    string $skinDir = ("/proj/" + $creatureName[0] + "/dev/" + $creatureName[1] + "/" + $creatureName[2] + "/cre/scripts/creatureRigScripts/data/sculptDeformers/");
    string $file = ($skinDir + $type);
return $file;
}

global proc string returnWmSmoothDir(string $type)
{
    print ("\n--------------wmNavi_importWmSmooth "+$type+ " ------------------\n");
    string $creatureName[] = `wmQueryCreature`;

    string $skinDir = ("/proj/" + $creatureName[0] + "/dev/" + $creatureName[1] + "/" + $creatureName[2] + "/cre/scripts/creatureRigScripts/data/wmSmooth/");
    string $file = ($skinDir + $type);
return $file;
}

global proc string returnWmBulgeDir(string $type)
{
    print ("\n--------------wmNavi_importWmBulge "+$type+ " ------------------\n");
    string $creatureName[] = `wmQueryCreature`;

    string $skinDir = ("/proj/" + $creatureName[0] + "/dev/" + $creatureName[1] + "/" + $creatureName[2] + "/cre/scripts/creatureRigScripts/data/wmBulge/");
    string $file = ($skinDir + $type);
return $file;
}

global proc string returnWireDir(string $type)
{
    print ("\n--------------wmNavi_importWires "+$type+ " ------------------\n");
    string $creatureName[] = `wmQueryCreature`;

    string $skinDir = ("/proj/" + $creatureName[0] + "/dev/" + $creatureName[1] + "/" + $creatureName[2] + "/cre/scripts/creatureRigScripts/data/wireDeformers/");
    string $file = ($skinDir + $type);
return $file;
}


//=================================================================================================
//=================================================================================================
//=================================================================================================
//=================================================================================================

//=== I use this instead of wmNavi_handSetup

global proc string[] wmFxHandSetup (string $side, int $updateShapes, string $skin)
{

    // add the data of this command to the build summary node
    string $data = ("wmNavi_handSetup " + $side + " " + $updateShapes + " " + $skin);
    if(!`objExists VisibilityControls`)
    wmNavi_addToBuildSummary ($side + "_handSetup") $data;
   
    // get the correct hand geo in
    string $wrap[];
   
    if(`objExists VisibilityControls`)
    {
    print "\nthis is a puppet\n";
    fxNavi_importWrapGeo ($side + "_hand") $updateShapes;
    }
    else
    $wrap = `wmNavi_importWrapGeo ($side + "_hand") $updateShapes`;

    // now start rigging the transforms for the skinning...

    string  $skinFile = `returnSkinPath ($side + "_hand")`;
//    string  $bonesDir = `returnBonesDir ($side + "_hand")`;
    string  $bonesDir = "";
    string  $wmSmoothDir = `returnWmSmoothDir ($side + "_hand")`;
    string  $wmBulgeDir = `returnWmBulgeDir ($side + "_hand")`;
    string  $wireDir = `returnWireDir ($side + "_hand")`;
   
    if(`objExists VisibilityControls`)
    rigHand $side $skinFile "" "" "" "";
    else
    rigHand $side $skinFile $bonesDir $wmSmoothDir $wmBulgeDir $wireDir;
   
    return {"",$wrap[1]};
}

//=================================================================================================
//=================================================================================================
//=================================================================================================
//=================================================================================================

//=== I use this instead of wmLoadAvatarHiresHands in the puppet mel script

global proc wmLoadHiresHands()
{
wmFxHandSetup "l" 0 0;
wmFxHandSetup "r" 0 0;
}




// source "/usr/home/fbalbas/maya/scripts/fx_utilities.mel";


global proc wmFxCopyDMaps(string $orig, string $copy)
{

string $listCon[] = `listConnections ($orig+"Shape")`;

string $types[] = {"wmSmooth","wmBulge","wmUnSmooth"};
string $defu[];
string $tmp[];

    for($item in $listCon)
    {
        for($deformer in $types)
        {
        $tmp = `listConnections -type $deformer $item`;
        $defu[size($defu)] = $tmp[0];
        }
    }

string $def[] = stringArrayRemoveDuplicates($defu);

string $poses[] = `ls "*Bindpose"`;
float $env;
string $type;

//=== attributes
for($name in $def)
{
    string $deformer;

    if(`objExists $name`)
    {
    string $pip[] = `ls -st $name`;

        if(`gmatch $pip[1] "wmSmooth"`)
        {
        $type = "smooth";
        $deformer = "wmSmooth";
        }
       
        if(`gmatch $pip[1] "wmUnSmooth"`)
        {
        $type = "unSmooth";
        $deformer = "wmUnSmooth";
        }
       
        if(`gmatch $pip[1] "wmBulge"`)
        {
        $type = "bulge";
        $deformer = "wmBulge";
        }
       
    string $command = ("rename "+$name+" old_"+$name+"; select "+ $copy+"; rename `"+$deformer+"` "+$name+";");
       
    //string $mapName = ("/tmp/"+$name+".dam");
    string $mapName = ("/tmp/"+$name);

    print ("\nwmSaveDMap -f "+$mapName+" -d "+$type+"Map  -s "+$orig);
   
    select $name;
    if(`gmatch $type "unSmooth"`)
    {
    wmSaveDMap -f $mapName -d ("smoothMap") -s $orig;
    wmSaveDMap -f ($mapName+"_UN") -d ("unSmoothMap") -s $orig;
    }
    else
    {
    wmSaveDMap -f $mapName -d ($type+"Map") -s $orig;
    }
   
        if(!`objExists $copy`)
        {
        wmAssumePoseCmd $poses;
        string $commandu = ("rename `"+$pip[1]+"` "+$copy);
        select ($copy);
        eval($commandu);
        setAttr ($copy+".envelope") 0;
        }
   
        if(`gmatch $type "bulge"`)
        {
        print "\n/============";
        print "THIS IS BULGE";
        print "\n";
        print "getting attributes from ";
        print $name;
        print "\n";
   
        $env = `getAttr ($name+".envelope")`;
        int $mode = `getAttr ($name+".bulgeMode")`;
        float $blur = `getAttr ($name+".blur")`;
        float $multBeforeRemap = `getAttr ($name+".multBeforeRemap")`;
        float $multAfterRemap = `getAttr ($name+".multAfterRemap")`;
        float $curveControl1 = `getAttr ($name+".curvatureControl[0].curvatureControl_FloatValue")`;
        float $curveControl2 = `getAttr ($name+".curvatureControl[1].curvatureControl_FloatValue")`;
   
        print "\n";
        print "setting attributes for ";
        print $name;
        print "\n/============";
        print "\n";
   
        eval($command);
       
        setAttr ($name+".bulgeMode") $mode;
        setAttr ($name+".blur") $blur;
        setAttr ($name+".multBeforeRemap") $multBeforeRemap;
        setAttr ($name+".multAfterRemap") $multAfterRemap;
        setAttr ($name+".curvatureControl[0].curvatureControl_FloatValue") $curveControl1;
        setAttr ($name+".curvatureControl[1].curvatureControl_FloatValue") $curveControl2;

        dgdirty $name;
        }
   
        if(`gmatch $type "smooth"`)
        {
        print "\n/============";
        print "THIS IS SMOOTH";
        print "\n";
        print "getting attributes from ";
        print $name;
        print "\n";
   
        $env = `getAttr ($name+".envelope")`;
        int $mode = `getAttr ($name+".smoothMode")`;
        int $space = `getAttr ($name+".space")`;
        int $iter = `getAttr ($name+".iter")`;
        float $borderPull = `getAttr ($name+".borderPull")`;
        int $quality = `getAttr ($name+".quality")`;
        float $qualiTrigger = `getAttr ($name+".qualiTrigger")`;
        float $blur = `getAttr ($name+".blur")`;
        float $mult = `getAttr ($name+".mult")`;
        float $add = `getAttr ($name+".add")`;
        float $clampLo = `getAttr ($name+".clampLo")`;
        float $clampHi = `getAttr ($name+".clampHi")`;
        int $volumeMode = `getAttr ($name+".volumeMode")`;
        float $volume = `getAttr ($name+".volume")`;
        float $volumeBlur = `getAttr ($name+".volumeBlur")`;
        int $volumeIter = `getAttr ($name+".volumeIter")`;
        int $difMapMode = `getAttr ($name+".difMapMode")`;
        float $difMapMult = `getAttr ($name+".difMapMult")`;
        float $difMapMin = `getAttr ($name+".difMapMin")`;
        float $difMapMax = `getAttr ($name+".difMapMax")`;
        float $difMapBlur = `getAttr ($name+".difMapBlur")`;
        float $curveControl1 = `getAttr ($name+".curvatureControl[0].curvatureControl_FloatValue")`;
        float $curveControl2 = `getAttr ($name+".curvatureControl[1].curvatureControl_FloatValue")`;
   
        print "\n";
        print "setting attributes for ";
        print $name;
        print "\n/============";
        print "\n";

        eval($command);


        setAttr ($name+".smoothMode") $mode;
        setAttr ($name+".space") $space;
        setAttr ($name+".iter") $iter;
        setAttr ($name+".borderPull") $borderPull;
        setAttr ($name+".quality") $quality;
        setAttr ($name+".qualiTrigger") $qualiTrigger;
        setAttr ($name+".blur") $blur;
        setAttr ($name+".mult") $mult;
        setAttr ($name+".add") $add;
        setAttr ($name+".clampLo") $clampLo;
        setAttr ($name+".clampHi") $clampHi;
        setAttr ($name+".volumeMode") $volumeMode;
        setAttr ($name+".volume") $volume;
        setAttr ($name+".volumeBlur") $volumeBlur;
        setAttr ($name+".volumeIter") $volumeIter;
        setAttr ($name+".difMapMode") $difMapMode;
        setAttr ($name+".difMapMult") $difMapMult;
        setAttr ($name+".difMapMin") $difMapMin;
        setAttr ($name+".difMapMax") $difMapMax;
        setAttr ($name+".difMapBlur") $difMapBlur;
        setAttr ($name+".curvatureControl[0].curvatureControl_FloatValue") $curveControl1;
        setAttr ($name+".curvatureControl[1].curvatureControl_FloatValue") $curveControl2;

        dgdirty $name;
        }

        if(`gmatch $type "unSmooth"`)
        {
        print "\n/============";
        print "THIS IS SMOOTH";
        print "\n";
        print "getting attributes from ";
        print $name;
        print "\n";
   
        $env = `getAttr ($name+".envelope")`;
        int $mode = `getAttr ($name+".unSmoothMode")`;
        int $space = `getAttr ($name+".space")`;
        int $iter = `getAttr ($name+".iter")`;
        float $borderPull = `getAttr ($name+".borderPull")`;
        float $blur = `getAttr ($name+".blur")`;
        float $mult = `getAttr ($name+".mult")`;
        float $add = `getAttr ($name+".add")`;
        int $volumeMode = `getAttr ($name+".volumeMode")`;
        float $volume = `getAttr ($name+".volume")`;
        float $volumeBlur = `getAttr ($name+".volumeBlur")`;
        int $volumeIter = `getAttr ($name+".volumeIter")`;
        /*
        float $clampLo = `getAttr ($name+".clampLo")`;
        float $clampHi = `getAttr ($name+".clampHi")`;
        int $difMapMode = `getAttr ($name+".difMapMode")`;
        float $difMapMult = `getAttr ($name+".difMapMult")`;
        float $difMapMin = `getAttr ($name+".difMapMin")`;
        float $difMapMax = `getAttr ($name+".difMapMax")`;
        float $difMapBlur = `getAttr ($name+".difMapBlur")`;
        float $curveControl1 = `getAttr ($name+".curvatureControl[0].curvatureControl_FloatValue")`;
        float $curveControl2 = `getAttr ($name+".curvatureControl[1].curvatureControl_FloatValue")`;
        */
        print "\n";
        print "setting attributes for ";
        print $name;
        print "\n/============";
        print "\n";

        eval($command);


        setAttr ($name+".unSmoothMode") $mode;
        setAttr ($name+".space") $space;
        setAttr ($name+".iter") $iter;
        setAttr ($name+".borderPull") $borderPull;
        setAttr ($name+".blur") $blur;
        setAttr ($name+".mult") $mult;
        setAttr ($name+".add") $add;
        setAttr ($name+".volumeMode") $volumeMode;
        setAttr ($name+".volume") $volume;
        setAttr ($name+".volumeBlur") $volumeBlur;
        setAttr ($name+".volumeIter") $volumeIter;
        /*
        setAttr ($name+".clampLo") $clampLo;
        setAttr ($name+".clampHi") $clampHi;
        setAttr ($name+".difMapMode") $difMapMode;
        setAttr ($name+".difMapMult") $difMapMult;
        setAttr ($name+".difMapMin") $difMapMin;
        setAttr ($name+".difMapMax") $difMapMax;
        setAttr ($name+".difMapBlur") $difMapBlur;
        setAttr ($name+".curvatureControl[0].curvatureControl_FloatValue") $curveControl1;
        setAttr ($name+".curvatureControl[1].curvatureControl_FloatValue") $curveControl2;
        */
        dgdirty $name;
        }

    select $name;
    if(`gmatch $type "unSmooth"`)
    {
    wmLoadDMap -f ($mapName+".dam") -d ("smoothMap") -s $copy;
    wmLoadDMap -f ($mapName+"_UN.dam") -d ("unSmoothMap") -s $copy;
    }
    else
    {
    wmLoadDMap -f ($mapName+".dam") -d ($type+"Map") -ws -s $copy;
    }
   
    setAttr ($name+".initalize") 1;
    setAttr ($name+".envelope") $env;
    print ("\n"+$name + " done!");

    }
}

}

global proc wmFxMirrorHandDMaps()
{

string $list[] = `ls -sl`;
string $mesh = $list[0];
string $deformer;

//=============================


    string $mirrorSide;
    string $orig;
    string $copy;
    string $neutralName = substring($mesh, 3, size($mesh));
    string $side = substring($mesh, 1, 1);

        if(`gmatch $side "l"`)
        {
        $mirrorSide="r";
        }
        else
        {
        $mirrorSide="l";
        }

string $otherMesh = ($mirrorSide+"_"+$neutralName);
string $tmpu[] = `listHistory $otherMesh`;
delete `ls -type wmSmooth -type wmBulge -type wmUnSmooth $tmpu`;

//=============================


string $tmp[] = `listHistory $mesh`;
string $def[] = `ls -type wmSmooth -type wmBulge -type wmUnSmooth $tmp`;
string $poses[] = `ls "*Bindpose"`;
float $env;

string $deformers[] = `reverseString $def`;

print "\n";
print $deformers;
print "\n";

string $type;


for($name in $deformers)
{
if(`objExists $name`)
{
    string $pip[] = `ls -st $name`;

    if(`gmatch $pip[1] "wmSmooth"`)
    {
    $type = "smooth";
    $deformer = "wmSmooth";
    }
    if(`gmatch $pip[1] "wmBulge"`)
    {
    $type = "bulge";
    $deformer = "wmBulge";
    }


    string $mirrorSide;


    string $orig;
    string $copy;
    string $neutralName = substring($name, 3, size($name));
    string $side = substring($name, 1, 1);

        if(`gmatch $side "l"`)
        {
        $mirrorSide="r";
        }
        else
        {
        $mirrorSide="l";
        }

    $orig = ($side+"_"+$neutralName);
    $copy = ($mirrorSide+"_"+$neutralName);

//=== attributes

   

    string $mapName = ("/tmp/"+$name+".dam");

    select $orig;
    wmSaveDMap -f $mapName -d ($type+"Map") -s $mesh;

string $command = ("select "+$otherMesh+"; rename `"+$deformer+"` "+$copy+";");


    if(`gmatch $type "bulge"`)
    {
    print "\n/============";
    print "THIS IS BULGE";
    print "\n";
    print "getting attributes from ";
    print $orig;
    print "\n";
   
    $env = `getAttr ($orig+".envelope")`;
    int $mode = `getAttr ($orig+".bulgeMode")`;
    float $blur = `getAttr ($orig+".blur")`;
    float $multBeforeRemap = `getAttr ($orig+".multBeforeRemap")`;
    float $multAfterRemap = `getAttr ($orig+".multAfterRemap")`;
    float $curveControl1 = `getAttr ($orig+".curvatureControl[0].curvatureControl_FloatValue")`;
    float $curveControl2 = `getAttr ($orig+".curvatureControl[1].curvatureControl_FloatValue")`;
   
    print "\n";
    print "setting attributes for ";
    print $copy;
    print "\n/============";
    print "\n";
   
    eval($command);
    //setAttr ($copy+".envelope") $env;
    setAttr ($copy+".bulgeMode") $mode;
    setAttr ($copy+".blur") $blur;
    setAttr ($copy+".multBeforeRemap") $multBeforeRemap;
    setAttr ($copy+".multAfterRemap") $multAfterRemap;
    setAttr ($copy+".curvatureControl[0].curvatureControl_FloatValue") $curveControl1;
    setAttr ($copy+".curvatureControl[1].curvatureControl_FloatValue") $curveControl2;

    dgdirty $copy;
    }
   
    if(`gmatch $type "smooth"`)
    {
    print "\n/============";
    print "THIS IS SMOOTH";
    print "\n";
    print "getting attributes from ";
    print $orig;
    print "\n";
   
    $env = `getAttr ($orig+".envelope")`;
    int $mode = `getAttr ($orig+".smoothMode")`;
    int $space = `getAttr ($orig+".space")`;
    int $iter = `getAttr ($orig+".iter")`;
    float $borderPull = `getAttr ($orig+".borderPull")`;
    int $quality = `getAttr ($orig+".quality")`;
    float $qualiTrigger = `getAttr ($orig+".qualiTrigger")`;
    float $blur = `getAttr ($orig+".blur")`;
    float $mult = `getAttr ($orig+".mult")`;
    float $add = `getAttr ($orig+".add")`;
    float $clampLo = `getAttr ($orig+".clampLo")`;
    float $clampHi = `getAttr ($orig+".clampHi")`;
    int $volumeMode = `getAttr ($orig+".volumeMode")`;
    float $volume = `getAttr ($orig+".volume")`;
    float $volumeBlur = `getAttr ($orig+".volumeBlur")`;
    int $volumeIter = `getAttr ($orig+".volumeIter")`;
    int $difMapMode = `getAttr ($orig+".difMapMode")`;
    float $difMapMult = `getAttr ($orig+".difMapMult")`;
    float $difMapMin = `getAttr ($orig+".difMapMin")`;
    float $difMapMax = `getAttr ($orig+".difMapMax")`;
    float $difMapBlur = `getAttr ($orig+".difMapBlur")`;
    float $curveControl1 = `getAttr ($orig+".curvatureControl[0].curvatureControl_FloatValue")`;
    float $curveControl2 = `getAttr ($orig+".curvatureControl[1].curvatureControl_FloatValue")`;
   
    print "\n";
    print "setting attributes for ";
    print $copy;
    print "\n/============";
    print "\n";

    eval($command);
    //setAttr ($copy+".envelope") $env;
    setAttr ($copy+".smoothMode") $mode;
    setAttr ($copy+".space") $space;
    setAttr ($copy+".iter") $iter;
    setAttr ($copy+".borderPull") $borderPull;
    setAttr ($copy+".quality") $quality;
    setAttr ($copy+".qualiTrigger") $qualiTrigger;
    setAttr ($copy+".blur") $blur;
    setAttr ($copy+".mult") $mult;
    setAttr ($copy+".add") $add;
    setAttr ($copy+".clampLo") $clampLo;
    setAttr ($copy+".clampHi") $clampHi;
    setAttr ($copy+".volumeMode") $volumeMode;
    setAttr ($copy+".volume") $volume;
    setAttr ($copy+".volumeBlur") $volumeBlur;
    setAttr ($copy+".volumeIter") $volumeIter;
    setAttr ($copy+".difMapMode") $difMapMode;
    setAttr ($copy+".difMapMult") $difMapMult;
    setAttr ($copy+".difMapMin") $difMapMin;
    setAttr ($copy+".difMapMax") $difMapMax;
    setAttr ($copy+".difMapBlur") $difMapBlur;
    setAttr ($copy+".curvatureControl[0].curvatureControl_FloatValue") $curveControl1;
    setAttr ($copy+".curvatureControl[1].curvatureControl_FloatValue") $curveControl2;

    dgdirty $copy;
    }
   
    setAttr -lock 0 ($otherMesh+".sx");
    setAttr ($otherMesh+".sx") -1;
    select $copy;
    wmLoadDMap -f $mapName -d ($type+"Map") -ws -s ($otherMesh);


    setAttr ($otherMesh+".sx") 1;
    setAttr ($copy+".initalize") 1;
    setAttr ($copy+".envelope") $env;
    print ("\n"+$copy + " done!");
}
}

}


global proc wmFxSaveDeformerMaps(string $dir)
{

string $mapName;

string $obj[] = `ls -sl`;
string $mesh = $obj[0];
string $history[] = `listHistory $mesh`;
//string $alldefs[] = `ls -type wmSmooth -type wmBulge -type wmUnSmooth $history`;
string $alldefs[] = `ls -type wmSmooth -type wmBulge $history`;

for($name in $alldefs)
{
$mapName = ($dir+"/"+$name+".dam");
string $type;
string $pip[] = `ls -st $name`;

if(`gmatch $pip[1] "wmSmooth"`)
$type = "smooth";

if(`gmatch $pip[1] "wmBulge"`)
$type = "bulge";

select $name;
wmSaveDMap -f $mapName -d ($type+"Map") -s $mesh;

}

}

global proc wmFxMirrorDeformerMaps(string $dir, string $mesh)
{
string $what = ("system (\"ls "+$dir+"*.dam\")");
string $pip = eval($what);

string $pippo[];
tokenize($pip, "/", $pippo);
string $defmaps[];
string $defs[];


for($item in $pippo)
{
if(`gmatch $item "*.dam*"`)
$defmaps[size($defmaps)] = $item;
}

for($item in $defmaps)
{
string $anotherString[];
tokenize($item, ".", $anotherString);
$defs[size($defs)] = $anotherString[0];
}

for($item in $defs)
{

if(`objExists $item`)
{
string $attr;

if(`gmatch $item "*wmSmooth*"`)
$attr = "smoothMap";
if(`gmatch $item "*wmBulge*"`)
$attr = "bulgeMap";

select -add $item;
wmLoadDMap -f ($dir+$item+".dam") -d $attr -mn -a "x" -s $mesh;
select -d $item;
}


}

}



global proc wmFxSaveShapeMap(string $fileName, string $shape)
{

string $line;

string $command  = ("getAttr -s "+$shape+".it[0].itg[0].tw");
int $vtx = `eval($command)`;

for($i=0;$i<($vtx);$i++)
{
string $comm  = ("getAttr "+$shape+".it[0].itg[0].tw["+$i+"]");
float $val = `eval($comm)`;
$line+= ("setAttr "+$shape+".it[0].itg[0].tw["+$i+"] "+ $val+";\n");
}

$fileId = `fopen $fileName "w"`;
fprint $fileId $line;
fclose $fileId;

}



global proc string wmFxSaveWireMap(string $wire)
{

string $line;

string $command  = ("getAttr -s "+$wire+".weightList[0].weights");
int $vtx = `eval($command)`;

for($i=0;$i<($vtx);$i++)
{
string $comm  = ("getAttr "+$wire+".weightList[0].weights["+$i+"]");
float $val = `eval($comm)`;
$line+= ("setAttr "+$wire+".weightList[0].weights["+$i+"] "+ $val+";\n");
}

return $line;

}

//=================================================================================================
//=================================================================================================
//=================================================================================================
//=================================================================================================

global proc string swap_suffix(string $node, string $new)
{
select $node;
string $name[] = `strip_suffix 1`;
rename $name[0] ($name[0]+"_"+$new); 

return ($name[0]+"_"+$new);
}


//=================================================================================================
//=================================================================================================
//=================================================================================================
//=================================================================================================

global proc fxDeleteEmptyLayers()
{

string $dsp[] = `ls -type displayLayer`;
string $members[];

    for($item in $dsp)
    {
    $members = `editDisplayLayerMembers -q $item`;
	    if(!size($members))
	    delete $item;
    }
}



//=================================================================================================
//=================================================================================================
//=================================================================================================
//=================================================================================================

proc fxPrefixNode(string $prefix, string $node)
{	
	// check if it is a transform or derived from transform.
	// We don't rename shapes since they will likely be renamed
	// when we renamed their parent transform.
	//
	string $isType[]	= `ls -type transform $node`;
	if (size($isType) > 0 ) {

		// extract the name of this node from its full path
		//
		string $nodeName = `substitute ".*|" $node ""`;

		// rename this node
		//
		string $newName = `rename $node ( $prefix + $nodeName )`;
	}
}

global proc fxPrefixHierarchy(string $prefix)
{
		string $currentNodes[] = eval("listRelatives -pa -ad `ls -sl -l`");
	
		// add the prefix to each descendent node
		//
		if ( size( $currentNodes ) > 0 ) 
        {
			for( $i=0; $i < size( $currentNodes ); $i++ ) 
            {
				fxPrefixNode( $prefix, $currentNodes[$i] );
			}
		}

		// get a list of nodes on the list
		$currentNodes = `ls -sl -l`;
	
		// add the prefix to each node on the active list
		//
		if ( size( $currentNodes ) > 0 ) 
        {
			for( $i=0; $i < size( $currentNodes ); $i++ ) 
            {
				fxPrefixNode( $prefix, $currentNodes[$i] );
			}
		}
}

//=================================================================================================
//=================================================================================================
//=================================================================================================
//=================================================================================================


global proc string dnJointShape(string $jnt)
{

string $children[] = `listRelatives -c -type joint $jnt`;
string $child = $children[0];


    if(size($child))
    {
    select $jnt $child;
    float $height = `get_distance`;
    float $scale = ($height/6);
    polyCube -name orecchietteconlecimedirapa -w $scale -h $height -d $scale -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 1;
    select $jnt orecchietteconlecimedirapa; delete `parentConstraint`;
    select $jnt $child orecchietteconlecimedirapa;
    delete `pointConstraint`;
    parent orecchietteconlecimedirapa $jnt;
    makeIdentity -a 1 -s 1 -t 1 -r 1 orecchietteconlecimedirapa;
    ResetTransformations;
    changeShape orecchietteconlecimedirapa "cube" ($height * 0.2);
    parent -r -s orecchietteconlecimedirapaShape $jnt;
    delete orecchietteconlecimedirapa;
    setAttr orecchietteconlecimedirapaShape.overrideEnabled 1;
    setAttr orecchietteconlecimedirapaShape.overrideShading 0;
    rename orecchietteconlecimedirapaShape ($jnt+"Shape");

    return ($jnt+"Shape");
    }
    else
    return "";
}

//=================================================================================================
//=================================================================================================
//=================================================================================================
//=================================================================================================

global proc string[] build_fk_joints(int $StripPrefix, string $suffix)
{
   
    int $num;
    string $joints[];
    string $pref;
    string $suff;
    string $name;
    string $list[] = `ls -sl`;
    string $item;
    select -cl;

    if(size($list) == 0)
    {
    print "\nselect objects to match in order\n";
    }
    else
    {
   
        for($item in $list)
        {
            if(`gmatch $item "*_???"` == 1)
            {
            $suff = `match "_...$" $item`;
            }
            else
            {
            $suff = "";
            }
       
            if(`gmatch $item "??_?_*"` == 1)
            {
            $num = 6;
            }
            else
            {
                if(`gmatch $item "??_*"` == 1)
                {
                $num = 4;
                }
                else
                {
                $num = 1;
                }
            }
   
       
        if($StripPrefix == 1)
        {   
        $name = substring($item,$num,(size($item) - size($suff)));
        }
        else
        {
        $name = substring($item,1,(size($item) - size($suff)));
        }

        string $jnt;

            if(size($joints) == 0)
            {
            float $pos[] = `xform -q -ws -t $item`;
            float $rot[] = `xform -q -ws -ro $item`;
            $jnt = `joint -p $pos[0] $pos[1] $pos[2] -sc false -name ($name +  "_"+$suffix)`;
            select $item $jnt;
            copyR;
            makeIdentity -a 1 -r 1 $jnt;
            setAttr ($jnt + ".rotateOrder") 3;
           
            select $jnt;
            $joints[`size $joints`] = $jnt;
            }
            else
            {
            float $pos[] = `xform -q -ws -t $item`;
            float $rot[] = `xform -q -ws -ro $item`;
            $jnt = `joint -p $pos[0] $pos[1] $pos[2] -sc off -name ($name +  "_"+$suffix)`;
            select $item $jnt;
            copyR;
            makeIdentity -a 1 -r 1 $jnt;
            setAttr ($jnt + ".rotateOrder") 2;
           
            select $jnt;
            $joints[`size $joints`] = $jnt;
            }
               
        }
    }


select $joints;
joint -e -spa;

if(size($joints)>1)
for($i=0;$i<(size($joints)-1);$i++)
dnJointShape $item;

select -cl;

return $joints;
}

//=================================================================================================
//=================================================================================================
//=================================================================================================
//=================================================================================================

//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================

global proc dnDoConstraint(string $type)
{
string $objs[] = `ls -sl`;
string $contraint = "Constraint";
string $conType;
string $command;
string $constName = ($objs[2]+"_"+$type);

if(`gmatch "PAC" $type`)
{
$conType = "parent";
$command = ("rename `"+$conType+$contraint+" -mo`"+$constName);
}

if(`gmatch "POC" $type`)
$conType = "point";

if(`gmatch "ORC" $type`)
$conType = "orient";


$command = ("rename `"+$conType+$contraint+"`"+$constName);

if(`size($objs)`>2)
select $objs[0] $objs[1] $objs[2];
else
select $objs[0] $objs[1];
eval($command);

    if(`size($objs)`>2)
    {
        if(!`objExists ($objs[2]+".fcWeight"+$type)`)
        addAttr -ln ("fcWeight"+$type) -k 1 -at double  -min 0 -max 1 -dv 0.5 $objs[2];
        
    setAttr ($objs[2]+".fcWeight"+$type) 0.5;
    string $revName = `shadingNode -asUtility reverse`;
    connectAttr -f ($constName+"."+$objs[0]+"W0") ($revName+".inputX");
    connectAttr -f ($revName+".outputX") ($constName+"."+$objs[1]+"W1");
    connectAttr -f ($objs[2]+".fcWeight"+$type) ($constName+"."+$objs[0]+"W0");
    }
select $objs[2];
}


//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================


global proc fuckThePass()
{
if(`objExists "*defaultPass*"`)
delete "*defaultPass*";
}

//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================


global proc adjustIkChainLength(string $crv)
{
string $shapes[] = `listRelatives -s $crv`;
string $shape = $shapes[0];
string $ikHandles[] = `listConnections -type ikHandle ($shape+".worldSpace[0]")`;
string $root[];
string $effector[];
int $num;
int $spans;
string $arcNode;
float $arcLength;
float $trans;
float $offset;

    for($ik in $ikHandles)
    {
    $root = `listConnections ($ik+".startJoint")`;
    $effector = `listConnections ($ik+".ikSolver")`;
    $num = size(`listRelatives -type joint -ad $root[0]`);
    $spans = `getAttr ($shape + ".spans")`;
    $arcNode = `arcLengthDimension ($shape + ".u[" + $spans + "]")`;
    setAttr ($arcNode +".uParamValue") 10000000;
    $arcLength = `getAttr ($arcNode + ".arcLength")`;
    select $root[0];

        for($i=0;$i<$num;$i++)
        {
        pickWalk -d down;
        string $joints[] = `ls -sl`;
        //$trans = `getAttr ($joints[0]+".tx")`;
            //if($trans != 0)
            setAttr ($joints[0]+".tx") ($arcLength/$num);
        //$trans = `getAttr ($joints[0]+".ty")`;
            //if($trans != 0)
            //setAttr ($joints[0]+".ty") ($arcLength/$num);
        //$trans = `getAttr ($joints[0]+".tz")`;
            //if($trans != 0)
            //setAttr ($joints[0]+".tz") ($arcLength/$num);
        }


    }

}

//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================


global proc dnSwapEnvs(string $list[])
{
    for($item in $list)
    {
    string $children[] =  `listRelatives -c -type transform $item`;
        
        if(`size($children)`)
        delete $children;
    
    string $baseName = `swap_suffix $item "env_LOC"`;
    
    
    select ($baseName+"_env_LOC");
    joint -name $item;
    }

}


//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================


global proc updateConstraints()
{

string $cons[] = `ls -typ constraint`;

if(size($cons) > 0)
{
    for($i = 0; $i < size($cons); $i++)
    {
    catch(`setAttr ($cons[$i] + ".nodeState") 0`);
    dgdirty $cons[$i];
    }
}

}


//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================
// a fantastic felix ripoff :)

global proc averageSkinWeights(float $weightChangeTolerance, int $numIterations)
{
    string $currentSelection[] = `ls -sl`;
	
	$weightChangeTolerance /= 100.0;

	int $foundSkin = 0;	    
	
	string $buff[];
	tokenize($currentSelection[0],".",$buff);
	string $sCluster = findRelatedSkinCluster($buff[0]);

	if ("" != $sCluster) 
    {
    $foundSkin = 1;
                
                string $cmd = ("skinCluster -e -sw "+$weightChangeTolerance+" -swi "+ $numIterations + " " +$sCluster);
                eval($cmd);	    
/*    
    string $cmd = ("skinCluster -sw "+$weightChangeTolerance+" -q " +$sCluster);
*/
    int $vertsToSmooth[];
    $vertsToSmooth = `eval($cmd)`;
    select -cl;
    string $geomName = $buff[0];
        for($vert in $vertsToSmooth) {
        string $vtxName = $geomName + ".vtx[";
        $vtxName += $vert;
        $vtxName += "]";
        select -add $vtxName;
        }                
    }		        									

select $currentSelection;

}

//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================
//=========================================================
// my try

global proc fxSmooth()
{


string $sel[] = `ls -sl`;
string $vtx;
string $neighbours[];
float $itemV[];
float $prevV[];
float $currV[];
float $values[];
string $jnt;
float $average = 0;


//=========================================================
//=== find obj and skincluster
//=========================================================

string $buff[];
tokenize($sel[0], ".", $buff);
string $obj = $buff[0];
string $skinCluster = `findRelatedSkinCluster $obj`;

//=========================================================
//=== joints
//=========================================================

select $sel[0];
string $joints[] = `skinPercent -q -t $skinCluster`;

    //=========================================================
    //=== find neighbours
    //=========================================================

    for($j=0;$j<size($joints);$j++)
    {
        for($item in $sel)
        {
        select $item;
        GrowPolygonSelectionRegion; 
        select -d $item;
        $neighbours = `ls -sl -fl`;

            for($i=0;$i<size($neighbours);$i++)
            {
            select $neighbours[$i];
            $currV = `skinPercent -q -v $skinCluster`;
            $values[size($values)] = $currV[$j];
            $average += ($currV[$j]/size($neighbours));
            print ("\n"+$average+"\n");
            }
        skinPercent -tv $joints[$j] $average $skinCluster $item;
        $average = 0;
        }
    }
select $sel;
}


//=========================================================
//=========================================================
//=========================================================


global proc toParametric(string $motionPaths[])
{

    for($item in $motionPaths)
    {
    string $crv[] = `listConnections ($item + ".geometryPath")`;
    string $curve = $crv[0];
    string $nodes[] = `listConnections ($item + ".allCoordinates")`;
    string $node = $nodes[0];
    delete $item;
    select $node $curve;
    closestValueOnCurve 1;
    }
}

//=========================================================
//=========================================================
//=========================================================

global proc make_sec (string $name)
{
        addAttr -ln "sec"  -at bool $name;
        setAttr ($name+".sec") 1;
        connectAttr -f ($name+".sec") ($name+"Shape.v");
}

//=========================================================
//=========================================================
//=========================================================

global proc connect_sec()
{
string $roots[] = `ls "*_ROOT"`;
string $root = $roots[0];

    string $list[] = `ls "*ctrl" "*xtra*ctrl"`;
    string $newList[];
    
    for($i = 0; $i < size($list);$i++)
    {
        if(`objExists ($list[$i] + ".sec")`)
        {
            if(`getAttr ($list[$i] + ".sec")` == 1)
            {
            $newList[size($newList)] = $list[$i];
            }
        }
    }

    
    for($i = 0; $i < size($newList);$i++)
    {
    catchQuiet(`connectAttr -f ($root+".sec_ctls") ($newList[$i] + ".sec")`);
    }

}

//=========================================================
//=========================================================
//=========================================================

global proc string myMotionPath()
{
string $list[] = `ls -sl`;
string $curve = $list[0];
string $node = $list[1];
string $mpath = `createNode motionPath`;
setAttr ($mpath + ".fractionMode") (!false);
connectAttr ($curve + ".worldSpace[0]") ($mpath + ".geometryPath");
connectAttr -f ($mpath + ".allCoordinates") ($node + ".translate");
return $mpath;
}

//===============================================================
//===============================================================
//===============================================================

global  proc string cluster_circle(string $name, int $degrees)
{

string $nodes[] = `ls -sl`;
float $coord[];
int $size = size($nodes);
string $return[] = {$name};   
string $command = ("circle -name "+$name+" -d " + $degrees+" -s "+$size);

eval($command);
string $shapeName[] = `listRelatives -f -c -s $name`;
rename $shapeName[0] ($name+"Shape");


    for($i = 0;$i<$size;$i++)
    {
    string $POCO = `createNode  pointConstraint`;
   
    if(!`objExists ($nodes[$i]+"_WSN")`)
    {
    rename $POCO ($nodes[$i]+"_WSN");
    $POCO = ($nodes[$i]+"_WSN");
    }
   
    connectAttr ($nodes[$i]+".rotatePivotTranslate") ($POCO+".target[0].targetRotateTranslate");
    connectAttr ($nodes[$i]+".rotatePivot") ($POCO+".target[0].targetRotatePivot");
    connectAttr ($nodes[$i]+".t") ($POCO+".target[0].targetTranslate");
    connectAttr ($nodes[$i]+".parentMatrix[0]") ($POCO+".target[0].targetParentMatrix");
   
    connectAttr ($POCO+".constraintTranslateX") ($name+".controlPoints["+$i+"].xValue");
    connectAttr ($POCO+".constraintTranslateY") ($name+".controlPoints["+$i+"].yValue");
    connectAttr ($POCO+".constraintTranslateZ") ($name+".controlPoints["+$i+"].zValue");
    $return[size($return)] = $POCO;
    }

select $return;
group -name ($name+"_GRP");
select $nodes;
return ($name+"_GRP");

}


//===============================================================
//===============================================================
//===============================================================

global proc string[] locs_on_path(string $locName, int $num)
{

cycleCheck -e off;

    string $names[];
   
    if(size($locName) == 0)
    {
    print "select a curve and type a number of joints\n";
    }


string $curve[] = `ls -sl`;

    if(size($curve) == 0)
    {
    print "no curve selected\n";
    }
    else
    {

string $mPATH;

//===================== loop


float $path_value = (1.00/($num - 1));
if($num < 3)
{
float $path_value = 1.00;
}



    for( $i=1; $i < ($num +1); $i++ )
        {
        string $pext = ($locName +"_"+ $i+"_MPA");
        string $name = ($locName +"_"+ $i+"_LOC");
        $names[size($names)] = $name;
        select -cl;
        spaceLocator -name $name;

       
        select $name $curve[0];
        $mpath = `pathAnimation -fractionMode true -follow true -followAxis x -upAxis y -worldUpType
        "normal" -inverseUp false -inverseFront false -bank false -startTimeU 0`;
        $mPATH = `rename $mpath $pext`;
   
   
        CBdeleteConnection ($name + ".rx");
        CBdeleteConnection ($name + ".ry");
        CBdeleteConnection ($name + ".rz");
        CBdeleteConnection ($name +  ".rotateOrder");
        string $pip[] =  `listConnections -d 1 -c 1 -p 1 ($name +  ".transMinusRotatePivotZ")`;
        disconnectAttr $pip[0] $pip[1];
        string $pip[] =  `listConnections -d 1 -c 1 -p 1 ($name +  ".transMinusRotatePivotY")`;
        disconnectAttr $pip[0] $pip[1];
        string $pip[] =  `listConnections -d 1 -c 1 -p 1 ($name +  ".transMinusRotatePivotX")`;
        disconnectAttr $pip[0] $pip[1];


   
        setAttr ($name + ".rotateX") 0;
        setAttr ($name + ".rotateY") 0;
        setAttr ($name + ".rotateZ") 0;
   
        CBdeleteConnection ($mPATH + ".u");
        setAttr ($mPATH + ".u") ($path_value * ($i -1));
            if($i == ($num + 1))
            {
            setAttr ($mPATH + ".u") 1;
            }
        }
   
   
    }

cycleCheck -e on;
   
select -cl;
return $names;
}


//===============================================================
//===============================================================
//===============================================================


global proc float returnClosestValueOnCurve(int $mode)
{
//=== select an object and a curve

float $max = 1.000;
string $nodes[] = `ls -sl`;
string $curve = $nodes[1];
string $node = $nodes[0];

select $curve $node;
delete `geometryConstraint`;

select -cl;
spaceLocator -name tmp;
select $node tmp;delete `pointConstraint`;

$mpath = `createNode motionPath`;

if($mode == 0)
setAttr ($mpath + ".fractionMode") (!false);
else
{
setAttr ($mpath + ".fractionMode") (!true);
string $command = ("ls "+$curve+".u[\"*\"]");
string $totalU[] = eval($command);
string $tmp[];
string $tmp2[];
tokenize($totalU[0], ":", $tmp);
tokenize($tmp[1], "]", $tmp2);
$max = $tmp2[0];
}

connectAttr ($curve + ".worldSpace[0]") ($mpath + ".geometryPath");
connectAttr -f ($mpath + ".allCoordinates") tmp.translate;
rename $mpath tmp_mpa;
CBdeleteConnection tmp_mpa.u;




$dist = `distanceDimension -sp 100 100 100 -ep 200 200 200`;
string $dispensable[] =  `listConnections $dist`;

if(`objExists ($node + ".worldPosition")`)
{
connectAttr -f ($node + ".worldPosition") ($dist + ".startPoint");
}
else
{
spaceLocator -name pippo;
select $node pippo;delete `pointConstraint`;
connectAttr -f pippo.worldPosition ($dist + ".startPoint");
}

connectAttr -f tmpShape.worldPosition ($dist + ".endPoint");
delete $dispensable;

float $i;
float $distances[];
float $Uvalue;
float $Uvalues[];

for($i = 0.000; $i < $max;$i+=.001)
{
setAttr tmp_mpa.u $i;
float $distanza = `getAttr ($dist + ".distance")`;
$distances[size($distances)] = $distanza;
$Uvalues[size($Uvalues)] = $i;
}

float $sorted[] = `sort $distances`;
float $smallest = $sorted[0];

for($n = 0; $n < size($distances);$n++)
{
if($distances[$n] == $smallest)
$Uvalue = $Uvalues[$n];
}


delete tmp;

if(`objExists pippo`)
{
delete pippo;
}

select -cl;
return $Uvalue;
}


//===============================================================
//===============================================================
//===============================================================

global proc sumTwoAttr(string $srcAttr1, string $srcAttr2, string $destAttr)
{
string $add = `shadingNode -asUtility plusMinusAverage`;

connectAttr -f $srcAttr1 ($add+".input1D[0]");
connectAttr -f $srcAttr2 ($add+".input1D[1]");
connectAttr -f ($add+".output1D") $destAttr;
}

//===============================================================
//===============================================================
//===============================================================

global proc subTwoAttr(string $srcAttr1, string $srcAttr2, string $destAttr)
{
string $add = `shadingNode -asUtility plusMinusAverage`;

connectAttr -f $srcAttr1 ($add+".input1D[0]");
connectAttr -f $srcAttr2 ($add+".input1D[1]");
connectAttr -f ($add+".output1D") $destAttr;
setAttr ($add+".operation") 2;
}

//===============================================================
//===============================================================
//===============================================================


global proc float[] fxGetNurbsCurveKnots(
    string $crvName )
//
//  Description :
//
{
    float $knots[] ;
    string $infoNode ;

    // create info Node.
    if( catch( $infoNode = `createNode curveInfo` ) ) {
        return $knots ;
    }

    // connect curve on to the info node.
    //
    string $outAttr = $crvName + ".local" ;
    string $inAttr = $infoNode + ".ic" ;
    connectAttr $outAttr $inAttr ;

    // read the knots.
    //
    $outAttr = $infoNode + ".knots" ;
    $knots = `getAttr $outAttr` ;

    // delete curve info node.
    //
    delete $infoNode ;

    // return the knots.
    //
    return $knots;
}

//===============================================================
//===============================================================
//===============================================================

proc fxDoMoveCurveSeam(string $crv, int $nspansToMove)
{
	// get the curve size
	int $spans = eval("getAttr " + $crv + ".spans");
	int $degree = eval("getAttr " + $crv + ".degree");
	int $form = eval("getAttr " + $crv + ".form");
	
	// get number of CVs
	int $ncvs = $spans;

	// array to hold shifted CVs
	float $cvs[];

	// array to hold a single CV
	float $cv[3];

	// move CVs and store in array
	int $u = 0; 
	for($u = 0; $u<$ncvs; $u++) {
		$cv = eval("xform -q -ws -t " + $crv + ".cv[" + $u + "]");
		int $newU = $u - $nspansToMove;
		if($newU < 0) $newU = $newU + $ncvs;
		for($dim=0; $dim<3; $dim++) {
			$cvs[3*$newU + $dim] = $cv[$dim];
		}
	}

	// copy reordered CVs from array back to curve
	for($u = 0; $u<$ncvs; $u++) {
		for($dim=0; $dim<3; $dim++) {
			$cv[$dim] = $cvs[3*$u + $dim];
		}
		eval("xform -ws -t " + $cv[0] + " " + $cv[1] + " " + $cv[2] + " " 
			 + $crv + ".cv[" + $u + "]");
	}

	return;
}


//===============================================================
//===============================================================
//===============================================================



global proc fxMoveNurbsCurveSeam(string $point) {

	// get all selected items
	
   
	// Run filter to select only NURBS curve points
	global int $gSelectCurveParmPointsBit ;
	
    string $crvList[] = `filterExpand -ex true -fullPath true -sm $gSelectCurveParmPointsBit $point`;
	int $len = size($crvList) ;
	if( $len != 1 ) {
		string $msg = (uiRes("m_moveNurbsCurveSeam.kSelectSingleError"));
		error ($msg);
		return;
	}

	// get curve from selection
	string $crv[] = `listRelatives -fullPath -parent $point`;

	// get the knot value of the selected isoparm
	string $buffer[];
	tokenize $crvList[0] "[|]" $buffer;
 	float $selectedKnot = $buffer[size($buffer) - 1];

	// get degree (U or V)
	int	$deg = eval("getAttr " + $crv[0] + ".degree");
	int	$form = eval("getAttr " + $crv[0] + ".form");

	// check that the curve is really periodic!!
	if(2 != $form) {
		string $msg = (uiRes("m_moveNurbsCurveSeam.kNotPeriodicError"));
		error ($msg);
		return;
	}

	// get the knots
	float $knots[] = fxGetNurbsCurveKnots($crv[0]);
	int $numKnots = size($knots);

	string $knotsError = (uiRes("m_moveNurbsCurveSeam.kKnotsNotUniformError"));
	// check that the knots are indeed uniform
	int $i;
	float $interval = $knots[1] - $knots[0];
	for($i=2; $i<$numKnots; $i++) {
		float $newInterval = $knots[$i] - $knots[$i-1];
		if(abs($newInterval - $interval) > 0.01*$interval) {
			error ($knotsError);
		}
	}

	// find the closest surface knot to the selected isoparm
	int $closestKnot = $deg-1;
	float $closestDistance = abs($selectedKnot - $knots[$deg-1]);
	int $i;
	for($i=$deg; $i<=($numKnots-$deg); $i++) {
		float $distance = abs($knots[$i] - $selectedKnot);
		if($distance < $closestDistance) {
			$closestDistance = $distance;
			$closestKnot = $i;
		}
	}

	// check for zero move
	if(($deg-1) == $closestKnot || ($numKnots-$deg) == $closestKnot) {
		string $msg = (uiRes("m_moveNurbsCurveSeam.kSeamLocationError"));
		error ($msg);
		return;
	}

 	// do the move
	int $numSpansToMove = $closestKnot - ($deg-1);
	fxDoMoveCurveSeam($crv[0], $numSpansToMove);
		
	return;
}

